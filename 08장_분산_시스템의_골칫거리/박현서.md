# 1. 결함과 부분 장애

분산 시스템에서는 이상화된 시스템 모델이 동작하지 않는다.

- 부분 장애 (partial failure)
    - 시스템의 어떤 부분은 잘 동작하나 다른 부분은 예측할 수 없는 방식으로 고장나는 경우
    - 비결정적이라 어려움

## 1) 클라우드 컴퓨팅과 슈퍼컴퓨팅

클라우딩 컴퓨터와 슈퍼컴퓨터의 결함 처리 방법은 다르다.

- 슈퍼컴퓨터
    - 노드 하나에 장애가 발생했을 때 저장소에 체크포인트를 저장한다.
    - 장애가 발생한 노드가 복구되면 마지막 체크포인트부터 계산을 재시작한다.
    - 시스템의 너무 부분에 장애가 생기면 전체가 죽게한다,.
- 클라우딩 컴퓨터
    - 수리를 위해 클러스터를 중단시키지 않는다.

분산 시스템은 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다.

→ 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다. (IP, TCP, …)

# 2. 신뢰성 없는 네트워크

분산 시스템은 비공유 시스템(네트워크로 연결된 다수의 장비)이다.

인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크(asynchronous packet network)다.

비동기 패킷 네트워크에서 노드는 다른 노드로 메시지를 보낼 수 있지만 언제 메세지가 도착할지, 메시지 도착 자체에 대한 보장을 하지 않는다.

전송측은 패킷이 전송됐는지 아닌지 조차 구별할 수 없다. 유일한 선택지는 수신 측에서 응답 메시지를 보내는 것이지만 응답 메시지도 손실되거나 지연될 수 있다. → 이런 문제를 다루는 흔한 방법이 타임아웃이다.

## 1) 현실의 네트워크 결함

EC2 같은 공개 클라우드 서비스는 일시적인 네트워크 결함이 자주 발생한다. 비공개 데이터센터는 더 안정적일 수 있지만 네트워크 문제를 면할 수는 없다.

- 스위치 소프트웨어 업그레이드 중 생기는 문제 → 네트워크 토폴리지 재구성 유발, 네트워크 패킷 지연
- 상어가 해저 케이블을 물어뜯어 손상

네트워크 결함 때문에 네트워크 일부가 다른 쪽과 차단되는 것을 “네트워크 분단(network partition)”, “네트워크 분리(netsplit)”이라고 부른다. (책에서는 네트워크 결함(network fault)으로 통일)

## 2) 결함 감지

시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.

하지만 네트워크 불확실성 때문에 노드 동작 여부를 구별하기 어렵다.

- 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 운영체제가 RST, FIN 패킷을 응답으로 보내서 TCP 연결을 닫거나 거부한다. 하지만 노드가 요청 처리 도중 죽었다면 원격 노드에서 데이터가 실제로 얼마나 처리됐는지 알 방법이 없다.
- 노드 프로세스가 죽었지만 노드의 운영체제는 아직 실행 중이라면 스크립트로 다른 노드에게 프로세스가 죽었다고 알린다. → 다른 노드가 타임아웃이 만료되기를 기다릴 필요 없이 빠르게 역할을 넘겨받을 수 있다.
- 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근 가능하다면 질의를 보내 하드웨어 수준의 링크 장래를 감지할 수 있다.
- 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답할 수 있다.

원격 노드가 다운되고 있다는 빠른 피드백은 유용하다. 하지만 의존할 수 없다.

요청 성공 확신이 필요하면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.

## 3) 타임아웃과 기약 없는 지연

- 중복 처리
    - 노드가 죽지 않았는데 성급하게 선언할 경우, 다른 노드가 요청을 받아 중복 처리할 수도 있다.
- 추가 부하
    - 다른 노드가 과부하로 인해 응답이 느린 것을 죽었다고 판단, 다른 노드가 과부하를 더 맞아 연쇄 장애 유발

패킷의 최대 지연 시간이 보장된 네트워크를 사용하는 가상 시스템이 있다고하자. 모든 패킷은 d 안에 전송/손실되지만 초과하지 않는다. 또 장애가 나지 않는 노드는 항상 r 시간 내에 처리할 수 있다고 하면 타임아웃을 2d + r로 잡으면 된다.

하지만 시스템 대부분은 보장해주지 않는다.

### 3-1) 네트워크 혼잡과 큐 대기

컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.

- 여러 다른 노드가 동시에 같은 목적지로 패킷을 보낼 때
    - 네트워크 스위치는 패킷을 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘긴다.
    - 네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 기다린다. → 네트워크 혼잡(network congestion)
- 패킷이 목적지 장비에 도착했을 때 모든 CPU 코어가 바쁜 상태라면
    - 네트워크에서 들어온 요청은 애플리케이션에서 처리할 준비가 될 때까지 운영체제가 큐에 넣어 둔다.
- 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 CPU 코어를 사용하는 동안 수십 밀리초 동안 멈출 때가 흔하다.
    - 가상 장비는 네트워크에서 어떤 데이터도 받아들일 수 없으므로 가상 장비 모니터가 들어오는 데이터를 큐에 넣어서 버퍼링한다.
- TCP는 흐름 제어 (flow control)를 수행한다.
    - 혼잡 회피, 배압이라는 것도 있다.
    - 흐름 제어는 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것이다. → 네트워크로 들어가기 전에도 부가적인 큐 대기를 할 수 있다.

이러한 요인들은 네트워크 지연의 변동성에 영향을 준다.

큐 대기 지연은 시스템이 최대 용량에 가까울 때 광범위하게 일어난다.

공개 클라우드, 멀티 테넌트 데이터센터는 여러 소비자가 자원을 공유하므로 맵리듀스 같은 일괄 처리 작업 부하는 네트워크 링크를 포화시키기 쉽다.

타임아웃은 실험적으로 해야하고 더 좋은 방식은 고정된 타임아웃이 아닌 시스템이 지속적으로 응답 시간과 그들의 변동성(지터(jitter))을 측정하고 관찰된 응답 시간 분포에 따라 자동으로 조절하게 하는 것이다. → 아카(Akka)와 카산드라가 있다.

## 4) 동기 네트워크 대 비동기 네트워크

패킷 전송 지연 시간의 최대치가 고정돼 있고 패킷을 유실하지 않는 네트워크에 기댈 수 있다면 분산 시스템은 단순해진다. → 하드웨어 수준에서 문제를 해결하고 네트워크를 신뢰성 있게 만들어서 소프트웨어에서 편하게 갈 수 있는 방법이 있을까?

- 동기식
    - 전화 네트워크에서 통화 시에 회선이 만들어 진다. 회선은 보장된 양의 대역폭이 할당되고 ISDN 네트워크의 경우 초당 4,000 프레임의 고정된 비율로 실행된다. 각 프레임 내에 16비트의 공간을 할당하여 양측은 250micro sec마다 정확히 16 비트의 오디오 데이터를 보낼 수 있도록 보장된다.
    - → 데이터가 여러 라우터를 거쳐도 큐 대기 문제를 겪지 않는다. → 큐 대기 지연이 없으므로 네트워크 종단 지연 시간의 최대치가 고정돼 있다. (제한 있는 지연(bounded delay)라고 한다.)

### 4-1) 그냥 네트워크 지연을 예측 가능하게 만들 수는 없을까?

전화 네트워크 회선은 TCP 연결과 다르다.

회선은 만들어져있는 동안 다른 누구도 사용할 수 없는 고정된 양의 예약된 대역폭이다.

TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다.

데이터센터 네트워크와 인터넷이 패킷 교환을 사용하는 이유는 몰리는 트래픽에 최적화됐기 때문이다.

웹 페이지, 이메일, 파일 전송 등은 가능한 빨리 완료되기를 원한다.

회선으로 사용했을 경우 고정된 대역폭을 사용해야하고 추정치가 높고 낮음에 따라 단점이 생긴다.

그래서 네트워크 용량에 맞춰 데이터 전송률을 동적으로 조절하는게 더 적합했다.

# 3. 신뢰성 없는 시계

분산시스템에서 시간은 다루기 까다롭다. 네트워크에 있는 개별 장비는 실제 핟그웨어 장치로 보통 수정 발진기(quartz crystal oscillator)로 자신의 시계를 갖고 있다. 이 장치는 완벽히 정확하지 않아서 각 장비는 자신만의 시간 개념이 있다. 이러한 시간을 어느 정도 동기화 할 수 있는 메커니즘으로는 네트워크 시간 프로토콜(Network Time Protocol, NTP)이 있다.

## 1) 단조 시계 대 일 기준 시계

- 현대 컴퓨터의 두 가지 종류의 시계
    - 일 기준 시계 (time-of-day clock)
    - 단조 시계 (monotonic lock)

### 1-1) 일 기준 시계

일 기준 시계는 직관적으로 시계에 기대하는 일을 한다.

- epoch 이래로 흐른 초
    - 리눅스 : clock_gettime(CLOCK_REALTIME)
    - 자바 : System.currentTimeMillis()

일 기준 시계는 보통 NTP로 동기화된다. 즉, 한 장비의 타임스탬프는 이상적으로 다른 장비의 타임스탬프와 동일한 의미를 지니지만, 로컬 시계가 NTP 서버보다 너무 앞서면 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보이는 현상이 있다.

### 1-2) 단조 시계

단조 시계는 타임아웃, 서비스 응답 시간 같은 지속 시간(시간 구간)을 재는 데 적합하다.

단조 시계는 항상 앞으로 흐른다는 사실에서 나왔다.

- 리눅스 : clock_gettime(CLOCK_MONOTONIC)
- 자바 : System.nanoTime()

단조 시계의 절대적인 값은 의미가 없다. → 두 대의 다른 컴퓨터에서 나온 단조 시계 값을 비교하는 것은 의미가 없다., 여러 개의 CPU 소켓이 있는 서버는 CPU마다 독립된 타이머가 있을 수도 있고, 다른 CPU와 반드시 동기화 되는 것도 아니다. OS에서는 차이를 보정해서 애플리케이션 스레드가 여러 CPU에 걸쳐 스케쥴링되더라도 시계가 단조적으로 보이게 하려고 한다. → 단조성 보장은 곧이 곧대로 받아들이지 않는게 현명하다.

## 2) 시계 동기화와 정확도

단조 시계는 동기화가 필요 없지만, 일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞추 설정돼야 유용하다. 하지만 기대만큼 신뢰성 있거나 정확하지 않다.

- 드리프트(drift) 현상
    - 시계 드리프트는 장비의 온도에 따라 변한다.
- 컴퓨터 시계와 NTP 서버와 차이
    - 차이가 크면 동기화가 거부되거나 로컬 시계가 강제로 리셋될 수도 있다.
- 방화벽 문제
    - 노드와 NTP 서버 사이가 방화벽으로 막히면 잘못된 설정이 얼마 동안 알려지지 않을 수도 있다.
- 네트워크 지연
    - NTP 동기화는 잘해야 네트워크 지연만큼 좋아질 수 있다.
- 가상 장비
    - 가상 장비에서는 하드웨어 시계가 가상화돼서 정확한 시간 엄수가 필요한 애플리케이션에게 추가적인 어려움이 생긴다.
- 완전히 제어할 수 없는 장치
    - 사용자가 하드웨어 시간을 고의로 잘못된 날짜와 시간으로 설정할 수 도 있다.

정확도는 GPS 수신기, 정밀 시간 프로토콜(Precision Time Protocol, PTP)과 세심한 배포, 모니터링을 사용해서 달성할 수 있다.

## 3) 동기화된 시계에 의존하기

시계는 함정이 있다.

견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.

시계가 잘못된 것을 눈치채기 힘든데, 장비의 수정 시계에 결함이 있거나 NTP 클랑리언트가 잘못 설정됐다면 시계는 드리프트가 생겨서 점점 실제 시간으로부터 멀어져가지만 잘 동작하는 것처럼 보인다.

따라서, 동기화된 시계가 필요한 소프트웨어를 사용하다면 필수적으로 모든 장비 사이의 시계 차이를 모니터링 해야한다. 다른 노드와 시계가 너무 차이나는 노드는 죽은 것으로 선언되고 클러스터에서 제거돼야 한다. → 너무 큰 피해를 입기 전에 고장 난 시계를 알아채도록 보장할 수 있다.

### 3-1) 이벤트 순서화용 타임스탬프

![image](https://github.com/user-attachments/assets/0ba726b2-a8b5-47fb-9834-28122336dad4)

다중 리더 복제를 쓰는 데이터베이스에서 일 기준 시간을 위험하게 쓰는 케이스이다.

1. 클라이언트 A : 노드1 (timestamp:42.004초, x=1) → 노드3에 복제
2. 클라이언트 B : 노드3(timestamp:42.003초, x+=1) → 노드1에 복제
3. 클라이언트 A : 노드2에 복제(timestamp:42.004초, x=1)
4. 클라이언트 B : 노드2에 복제(timestamp:42.003초, x=2)
5. 결과 : 노드2에 클라이언트B(x=2) 후에 클라이언트A(x=1) 처리하여 클라이언트B의 증가 연산은 손실됨.

이러한 충돌 해소 전략은 최종 쓰기 승기(last write wins, LWW)인데, 현재 문제를 다른 방식으로 해결할 수는 있지만 근본적인 문제를 바꾸지는 못한다.

올바른 순서화를 위해서는 시계 출처가 측정하려고 하는 대상보다 정확해야 한다. 이른바 **“논리적 시계”**는 진동하는 수정(quartz crystal) 대신 증가하는 카운터를 기반으로 하며 이벤트 순서화의 안전한 대안이다. 논리적 시계는 일 기준 시간이나 경과한 초 수를 측정하지 않고 이벤트의 상대적인 순서만 측정한다.

반대로 **“물리적 시계”**는 일 기준 시계, 단조 시계로 실제 경과 시간을 측정한다.

### 3-2) 시계 읽기는 신뢰 구간이 있다.

장비의 일 기준 시계를 마이크로초 해상도로, 나노초 해상도로 읽을 수도 있지만 값이 정밀성을 제공할 만큼 실제로 정확하다는 뜻은 아니다.

시계 읽기를 어떤 시점으로 생각하는 것은 타당하지 않고, 어떤 신뢰 구간에 속하는 시간의 범위로 읽는 게 낫다

불확실성 경계는 시간 출처를 기반으로 계산할 수 있다. 서버와 마지막으로 동기화한 시간 이후로 예상되는 시계 드래프트에 NTP 서버의 불확실성을 더하고 그 서버와 통신할 때 걸리는 네트워크 왕복 시간을 더한 값을 기반으로 한다.

### 3-3) 전역 스냅숏용 동기화된 시계

동기화를 충분히 잘한다면 일 기준 시계의 타임스탬프를 트랜잭션 ID로 쓸 수 있다. 시계 정확도에 관한 불확실성이 있지만, 스패너에서는 데이터센터에 걸쳐 스냅숏 격리를 구현한다.

스패너의 스냅숏 구현은 트루타임 API가 보고한 시계 신뢰 구간을 사용하며, 각각 가장 이른 타임스탬프와 가장 늦은 타임스탬프를 포함하는 두 개의 신뢰 구간이 있다. A, B 두 구간이 겹치지 않는다면 순서를 정확하게 파악할 수 있다.

```
A(A_earliest, A_latest)
B(B_earliest, B_latest)
```

**트랜잭션 타임스탬프가 인과성을 반영하는 것을 보장**하기 위해 스패너는 읽기 쓰기 트랜잭션을 커밋하기 전에 의도적으로 신뢰 구간의 길이만큼 기다린다. → 그 데이터를 읽을지도 모르는 트랜잭션은 충분히 나중에 실행되는게 보장되므로 신뢰 구간이 겹치지 않는다.

그리고 대기 시간을 가능하면 짧게 유지하기 위해 스패너는 시계 불확실성을 가능하면 작게 유지해야 한다.

이러한 아이디어는 있지만 구글 외에는 아직 주류 데이터베이스에서 구현한 사례가 없다.

## 4) 프로세스 중단

파티션마다 리더가 하나씩 있는 데이터베이스가 있다고 가정하자.

노드가 여전히 리더인지 알 수 있는 방법으로는 리더가 다른 노드들로부터 임차권을 얻는 것이다.

특정 시점에 하나의 리더만 임차권을 얻을 수 있다고 했을 때, 어떤 노드가 임차권을 획득하면 임차권이 만료될 때까지 자신이 얼마간 리더일 거라고 알 수 있다. 노드가 계속 리더로 남아 있으려면 주기적으로 갱신해야 한다. 노드에 장애가 나면 임차권 갱신을 멈추므로 임차권이 만료될 때 다른 노드가 리더 역할을 넘겨 받을 수 있다.

로직에서 동기화된 시계에 의존하게 되는데, 임차권 만료 시간은 서로 다른 장비에서 설정됐는데 로컬 시스템 시계와 비교하게 된다. **시계가 몇 초 이상으로 동기화가 깨지면 이 코드는 이상한 일을 하기 시작**한다.

또한 처리하는 스레드가 멈춰서 임차권이 만료되는 경우에 다른 노드가 리더 역할을 넘겨받게 됐는데도 스레드가 재개되면서 임차권을 두 곳에서 갖게되는 일이 생길 수도 있다.

단일 노드에서는 mutex, semaphore, atomic counter, lock-free, blocking queue 등으로 thread-safe하게 처리하도록 할 수 있지만, 분산 환경에서는 어렵다.

### 4-1) 응답 시간 보장

프로그래밍 언어와 운영체제에서 스레드, 프로세스는 기약 없는 시간 동안 중단될 수 있다.

노력하면 중단의 원인을 제거할 수 있다.

시스템에서 실시간 보장을 제공하려면 소프트웨어 스택의 모든 수준에서 지원이 필요하다.

- 실시간 운영체제(real-time operating system, RTOS)
    - 프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케줄링해줌
- 라이브러리 함수
    - 최악의 실행 시간을 문서화
- 동적 메모리 할당
    - 제한되거나 금지
- GC
    - GC가 너무 많은 일을 하지 않도록 보장해야 한다.

대부분의 서버측 데이터 처리 시스템에서 실시간 보장은 적절하지 않다. → 비실시간 환경에서 운영될 때 발생하는 중단과 시계 불안정으로부터 고통받는다.

### 4-2) 가비지 컬렉션의 영향을 제한하기

프로세스 중단의 부정적 영향은 비용이 큰 실시간 스케줄링 보장에 기대지 않고도 완화시킬 수 있다.

언어 런타림은 객체 할당률과 시간에 따라 남아 있는 여유 메모리 공간을 추적할 수 있으므로 언제 가비지 컬렉션을 할지와 관련된 어느 정도의 유연성을갖고 있다.

지연 시간에 민감한 금융 거래 시스템 중에는

GC 중단을 노드가 잠시 동안 계획적으로 중단되는 것으로 간주하고, 노드가 가비지 컬렉션을 하는 동안 클라이언트로부터의 요청을 다른 노드들이 처리하도록 하는 방법도 있다.

비슷한 아이디어로 수명이 짧은 객체만 가비지 컬렉터를 이용하고 수명이 긴 객체의 전체 GC가 필요한 만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있다.

# 4. 지식, 진실, 그리고 거짓말

분산 시스템에는 공유 메모리가 없고 지연 변동이 큰 신뢰할 수 없는 네트워크를 통해 메시지를 보낼 수 있을 뿐이다. 부분 장애, 신뢰성 없는 시계, 프로세스 중단에 시달릴 수 있다.

분산시스템에서 우리는 동작에 관해 정한 가정을 명시한다. 그리고 명시한 가정을 만족시키는 방식으로 실제 시스템을 설계하여 기반 시스템 모델이 매우 적은 보장만 제공하더라도 신뢰성 있는 동작을 달성할 수 있다.

## 1) 진실은 다수결로 결정된다.

여러 분산 알고리즘은 정족수, 즉 노드들 사이의 투표에 의존한다. 특정한 노드 하나에 대한 의존을 줄이기 위해 결정을 하려면 여러 노드로부터 최소 개수의 투표를 받아야 한다.

### 1-1) 리더와 잠금

분산 시스템에서 어떤 노드가 스스로를 “선택된 자”라고 믿을지라도 노드의 정족수도 반드시 동의한다는 뜻은 아니다.

![image](https://github.com/user-attachments/assets/edf73ba4-85a0-43c9-8fcb-0ada92604fcd)

### 1-2) 펜싱 토큰

파일 저장소 같은 리소스에 대한 접근을 보호하기 위해 잠근이나 임차권을 쓸 때, 자신이 “선택된 자”라고 믿고 있는 노드가 나머지 시스템을 방해할 수 없도록 보장해야 한다.

펜싱 기법

![image](https://github.com/user-attachments/assets/97560f8e-e6b0-4c23-969c-7f74bc5fb36f)

### 1-3) 비잔틴 결함

펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있다.

하지만 노드가 고의도 시스템의 보장을 무너뜨릴 수도 있다.

노드가 거짓말을 한다면 문제가 더 어려워지는데, 예를 들어 노드가 실제로는 받지 않은 특정 메시지를 받았다고 주장하는 동작을 “비잔틴 결함(Byzantine fault)”이라고 한다. 이렇게 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 “비잔틴 장군 문제(Byzantine Generals Problem)”라고 한다.

### 1-4) 약한 형태의 거짓말

- 체크섬
    - 네트워크 패킷은 하드웨어, 운영체제, 드라이버, 라우터 등의 버그 때문에 오염된다. 오염된 패킷은 TCP, UDP에 내장된 체크섬으로 검출되지만 때로는 검출을 피하는 경우도 있다. 이런 오염으로부터 보호하려면 애플리케이션 수준 프로토콜에서 체크섬을 쓰는 것처럼 단순한 수단을 쓰면 된다.
- 요청 값 살균
    - 사용자 입력 값이 합당한 범위인지, 메모리를 많이 차지 하는지 등에 대한 점검을 한다.

## 2) 시스템 모델과 현실

분산 시스템 문제를 해결하기 위한 알고리즘들이 설계되고 있는데, 유용하려면 다양한 결함을 견딜 수 있어야 한다.

알고리즘은 하드웨어, 소프트웨어 설정에 심하게 의존하지 않는 방식이어야 한다. 즉, 정형화가 필요하다.

- 타이밍 가정
    - 동기식 모델
        - 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정한다. 고정된 상한치를 초과하지 않는 것을 알고 처리한다. 하지만 현실 시스템 대부분에서 현실적인 모델은 아니다.
    - 부분 동기식 모델
        - 대부분의 시간에는 동기식 시스템처럼 동작하지만 때때로 네트워크 지연, 프로세스 중단, 시계 드리프트의 한계치를 초과한다는 듯이다. 대부분은 잘 동작하지만 가끔씩 타이밍 가정이 산산조각 날 수도 있다는 것을 고려해야 한다.
    - 비동기식 모델
        - 타이밍에 대한 가정을 할 수 없다. 심지어는 시계가 없을 수도 있는 제한적인 설게이;다.
- 노드 장애
    - 죽으면 중단하는 결함
        - 노드에 장애가 나는 방식은 하나뿐, 죽는 것 밖에 없다고 가정한다.
    - 죽으면 복구하는 결함
        - 어느 순간 노드가 죽을 수 있지만, 어느 순간 다시 응답할 것이라고 가정한다.
    - 비잔틴 결함
        - 다른 노드를 속이거나 기만하는 것을 포함해 무슨 일이든 할 수 있다.
    

### 2-1) 알고리즘의 정확성

펜싱 토큰을 쓴다면 알고리즘은 다음과 같은 속성을 가져야 한다.

- 유일성
    - 펜싱 토큰 요청이 같은 값을 반환하지 않는다.
- 단조 일련번호
    - 요청 x가 토큰tx를, 요청 y가 토큰 ty를 반환했고 y가 시작하기 전에 x가 완료됐다면 tx<ty를 만족한다.
- 가용성
    - 펜싱 토큰을 요청하고 죽지 않은 노드는 결국에는 응답을 받는다.

하지만 모든 노드가 죽거나 모든 네트워크 지연이 무한하게 되면 어떤 알고리즘이라도 아무것도 할 수 없다.

### 2-2) 안전성과 활동성

- 안전성
    - 비공식적으로 나쁜 일은 일어나지 않는다고 정의된다.
    - 안전성 속성이 위반되면 그 속성이 깨진 특정 시점을 가리킬 수 있다.
    - 안전성 속성이 위반된 후에는 그 위반을 취소할 수 없다.
- 활동성
    - 비공식적으로 좋은 일은 결국 일어난다고 정의한다.
    - 어떤 시점을 정하지 못할 수 있지만, 미래에는 그 속성을 만족시킬 수 있다.

### 2-3) 시스템 모델을 현실 세계에 대응시키기

추상 시스템 모델은 현실 시스템의 복잡함에서 우리가 추론할 수 있는 관리 가능한 결함의 집합을 뽑아내서, 문제를 이해하고 체계적으로 해결하려고 노력하는데 도움이 된다. 하지만 알고리즘이 올바르다고 증명됐더라도 반드시 현실 시스템에서의 구현도 언제나 올바르게 동작한다는 뜻은 아니다.
