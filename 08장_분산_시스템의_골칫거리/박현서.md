# 1. 결함과 부분 장애

분산 시스템에서는 이상화된 시스템 모델이 동작하지 않는다.

- 부분 장애 (partial failure)
    - 시스템의 어떤 부분은 잘 동작하나 다른 부분은 예측할 수 없는 방식으로 고장나는 경우
    - 비결정적이라 어려움

## 1) 클라우드 컴퓨팅과 슈퍼컴퓨팅

클라우딩 컴퓨터와 슈퍼컴퓨터의 결함 처리 방법은 다르다.

- 슈퍼컴퓨터
    - 노드 하나에 장애가 발생했을 때 저장소에 체크포인트를 저장한다.
    - 장애가 발생한 노드가 복구되면 마지막 체크포인트부터 계산을 재시작한다.
    - 시스템의 너무 부분에 장애가 생기면 전체가 죽게한다,.
- 클라우딩 컴퓨터
    - 수리를 위해 클러스터를 중단시키지 않는다.

분산 시스템은 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다.

→ 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다. (IP, TCP, …)

# 2. 신뢰성 없는 네트워크

분산 시스템은 비공유 시스템(네트워크로 연결된 다수의 장비)이다.

인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크(asynchronous packet network)다.

비동기 패킷 네트워크에서 노드는 다른 노드로 메시지를 보낼 수 있지만 언제 메세지가 도착할지, 메시지 도착 자체에 대한 보장을 하지 않는다.

전송측은 패킷이 전송됐는지 아닌지 조차 구별할 수 없다. 유일한 선택지는 수신 측에서 응답 메시지를 보내는 것이지만 응답 메시지도 손실되거나 지연될 수 있다. → 이런 문제를 다루는 흔한 방법이 타임아웃이다.

## 1) 현실의 네트워크 결함

EC2 같은 공개 클라우드 서비스는 일시적인 네트워크 결함이 자주 발생한다. 비공개 데이터센터는 더 안정적일 수 있지만 네트워크 문제를 면할 수는 없다.

- 스위치 소프트웨어 업그레이드 중 생기는 문제 → 네트워크 토폴리지 재구성 유발, 네트워크 패킷 지연
- 상어가 해저 케이블을 물어뜯어 손상

네트워크 결함 때문에 네트워크 일부가 다른 쪽과 차단되는 것을 “네트워크 분단(network partition)”, “네트워크 분리(netsplit)”이라고 부른다. (책에서는 네트워크 결함(network fault)으로 통일)

## 2) 결함 감지

시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.

하지만 네트워크 불확실성 때문에 노드 동작 여부를 구별하기 어렵다.

- 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 운영체제가 RST, FIN 패킷을 응답으로 보내서 TCP 연결을 닫거나 거부한다. 하지만 노드가 요청 처리 도중 죽었다면 원격 노드에서 데이터가 실제로 얼마나 처리됐는지 알 방법이 없다.
- 노드 프로세스가 죽었지만 노드의 운영체제는 아직 실행 중이라면 스크립트로 다른 노드에게 프로세스가 죽었다고 알린다. → 다른 노드가 타임아웃이 만료되기를 기다릴 필요 없이 빠르게 역할을 넘겨받을 수 있다.
- 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근 가능하다면 질의를 보내 하드웨어 수준의 링크 장래를 감지할 수 있다.
- 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답할 수 있다.

원격 노드가 다운되고 있다는 빠른 피드백은 유용하다. 하지만 의존할 수 없다.

요청 성공 확신이 필요하면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.

## 3) 타임아웃과 기약 없는 지연

- 중복 처리
    - 노드가 죽지 않았는데 성급하게 선언할 경우, 다른 노드가 요청을 받아 중복 처리할 수도 있다.
- 추가 부하
    - 다른 노드가 과부하로 인해 응답이 느린 것을 죽었다고 판단, 다른 노드가 과부하를 더 맞아 연쇄 장애 유발

패킷의 최대 지연 시간이 보장된 네트워크를 사용하는 가상 시스템이 있다고하자. 모든 패킷은 d 안에 전송/손실되지만 초과하지 않는다. 또 장애가 나지 않는 노드는 항상 r 시간 내에 처리할 수 있다고 하면 타임아웃을 2d + r로 잡으면 된다.

하지만 시스템 대부분은 보장해주지 않는다.

### 3-1) 네트워크 혼잡과 큐 대기

컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.

- 여러 다른 노드가 동시에 같은 목적지로 패킷을 보낼 때
    - 네트워크 스위치는 패킷을 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘긴다.
    - 네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을 때까지 기다린다. → 네트워크 혼잡(network congestion)
- 패킷이 목적지 장비에 도착했을 때 모든 CPU 코어가 바쁜 상태라면
    - 네트워크에서 들어온 요청은 애플리케이션에서 처리할 준비가 될 때까지 운영체제가 큐에 넣어 둔다.
- 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 CPU 코어를 사용하는 동안 수십 밀리초 동안 멈출 때가 흔하다.
    - 가상 장비는 네트워크에서 어떤 데이터도 받아들일 수 없으므로 가상 장비 모니터가 들어오는 데이터를 큐에 넣어서 버퍼링한다.
- TCP는 흐름 제어 (flow control)를 수행한다.
    - 혼잡 회피, 배압이라는 것도 있다.
    - 흐름 제어는 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것이다. → 네트워크로 들어가기 전에도 부가적인 큐 대기를 할 수 있다.

이러한 요인들은 네트워크 지연의 변동성에 영향을 준다.

큐 대기 지연은 시스템이 최대 용량에 가까울 때 광범위하게 일어난다.

공개 클라우드, 멀티 테넌트 데이터센터는 여러 소비자가 자원을 공유하므로 맵리듀스 같은 일괄 처리 작업 부하는 네트워크 링크를 포화시키기 쉽다.

타임아웃은 실험적으로 해야하고 더 좋은 방식은 고정된 타임아웃이 아닌 시스템이 지속적으로 응답 시간과 그들의 변동성(지터(jitter))을 측정하고 관찰된 응답 시간 분포에 따라 자동으로 조절하게 하는 것이다. → 아카(Akka)와 카산드라가 있다.

## 4) 동기 네트워크 대 비동기 네트워크

패킷 전송 지연 시간의 최대치가 고정돼 있고 패킷을 유실하지 않는 네트워크에 기댈 수 있다면 분산 시스템은 단순해진다. → 하드웨어 수준에서 문제를 해결하고 네트워크를 신뢰성 있게 만들어서 소프트웨어에서 편하게 갈 수 있는 방법이 있을까?

- 동기식
    - 전화 네트워크에서 통화 시에 회선이 만들어 진다. 회선은 보장된 양의 대역폭이 할당되고 ISDN 네트워크의 경우 초당 4,000 프레임의 고정된 비율로 실행된다. 각 프레임 내에 16비트의 공간을 할당하여 양측은 250micro sec마다 정확히 16 비트의 오디오 데이터를 보낼 수 있도록 보장된다.
    - → 데이터가 여러 라우터를 거쳐도 큐 대기 문제를 겪지 않는다. → 큐 대기 지연이 없으므로 네트워크 종단 지연 시간의 최대치가 고정돼 있다. (제한 있는 지연(bounded delay)라고 한다.)

### 4-1) 그냥 네트워크 지연을 예측 가능하게 만들 수는 없을까?

전화 네트워크 회선은 TCP 연결과 다르다.

회선은 만들어져있는 동안 다른 누구도 사용할 수 없는 고정된 양의 예약된 대역폭이다.

TCP 연결의 패킷은 가용한 네트워크 대역폭을 기회주의적으로 사용한다.

데이터센터 네트워크와 인터넷이 패킷 교환을 사용하는 이유는 몰리는 트래픽에 최적화됐기 때문이다.

웹 페이지, 이메일, 파일 전송 등은 가능한 빨리 완료되기를 원한다.

회선으로 사용했을 경우 고정된 대역폭을 사용해야하고 추정치가 높고 낮음에 따라 단점이 생긴다.

그래서 네트워크 용량에 맞춰 데이터 전송률을 동적으로 조절하는게 더 적합했다.
