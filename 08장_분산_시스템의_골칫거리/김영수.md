# 8장 분산 시스템의 골칫거리


## 결함과 부분 장애

단일 컴퓨터에서는 오류가 날 확률이 적지만, 네트워크로 연결된 분산시스템에서는 예측할 수 없는 방식으로 고장이 난다. 이것을 부분 장애 라고 한다 (partial failure).

### 클라우드 컴퓨팅과 슈퍼컴퓨팅

슈퍼컴퓨터는 단일장비에 수천개의 시피유가 있다. 단일 노드에 더 가깝다.

그러나 클라우드는 좀 다르다. 분산 시스템으로 여러 작은 컴퓨터가 연결되어있다.

분산 시스템은 부분 장애 가능성을 받아들이고, 소프트웨어에 내결함성 메커니즘을 넣어서 신뢰성을 구축해야 한다 

## 신뢰성 없는 네트워크

인터넷과 데이터 센터 내부 네트워크 대부분은 비동기 패킷 네트워크로 구현되어있다. 

노드는 다른 노드로 패킷을 보낼 수 있지만, 언제 도착할지 혹은 도착하기 할것인지 보장하지 못한다. 

이런 문제를 타임아웃으로 다뤄서 시간이 지나면 도착하지 않는다고 가정해버린다.

### 현실의 네트워크 결함

### 결함 감지

결함있는 노드를 자동 감지 할 수 있어야 한다

* 로드 밸런서는 죽은 노드로 요청을 보내면 안됌 
* 리더 복제 상황에서 리더 장애시 팔로워가 리더로 승격되어야 함

이런경우 헬스체크같은 자체 요청 응답 시스템을 통해 만료 시간이 지날동안 응답이 안오면 장애로 판단해야 한다.

### 타임아웃과 기약 없는 지연

그렇다면 타임아웃이 길면 노드가 죽었다고 선언될 떄까지 기다리는 시간이 길어진다

짧으면 빨리 발견하지만, 일시적인 느려짐인데 장애로 판별하는 문제가 생긴다 

* 노드가 죽지 않았는데 과부하로 인해 응답이 느릴수도 있음
* 이 노드의 부하를 다른 노드로 전달하면 연쇄 장애도 유발 가능함

그래서 아래의 계산식을 이용하는게 좋다

* 모든 패킷은 어떤 시간 d 내에 전송되거나 손실되지만 결코 d보다 더 걸리지 않음
* 장애가 없는 정상 노드는 항상 요청을 r 시간 내에 처리함
* 그렇다면 성공한 노드는 2d + r 시간 내 응답을 받음 => 2d + r = 타임아웃 시간

### 네트워크 혼잡과 큐 대기

네트워크에서 패킷 지연은 큐 대기 때문인 경우가 많음.

* 여러 노드가 동시에 같은 목적지로 패킷을 보내려고 하면, 스위치는 패킷을 큐에 넣고 한번에 하나씩 목적지 링크로 넘김. 네트워크가 붐비면 패킷은 슬롯을 얻을때까지 대기함. 그러나 스위치 큐를 꽉 채우면 패킷 유실이 발생할 수 있어 재전송 해야하는 케이스도 존재
* 패킷이 장비에 도착해도 CPU가 바쁘다면 네트워크에서 들어온 요청은 애플리케이션에서 처리할 준비가 될때까지 os가 큐에 넣어둠.
* TCP는 흐름제어를 수행하는데, 노드가 부하가 걸리지 않도록 자신의 송신율을 제한함.

> tcp vs udp
>
> 화상 회의, 인터넷 전화 같은 지연 시간에 민감한 애플리케이션은 UDP를 사용한다.
>
> UDP는 흐름 제어를 하지 않고 손실된 패킷을 재전송하지 않아서 지연 시간을 크게 감축한다
>
> UDP는 지연된 데이터 가치가 없는 상황에서 선택하면 좋다. 

어찌저찌해서 타임아웃값을 결정해도 지정한 값보다 지연되는 케이스도 있다.

이런 것들을 더 낫게 하기 위해 고정 타임아웃 대신 jitter값을 추가해서 타임아웃을 조정하는것이 좋다 

### 동기 네트워크 대 비동기 네트워크

전화 통화시 네트워크에서는 circuit(회선)이 만들어지는데, 그 통화에 대해 고정되고 보장된 양의 대역폭이 할당된다.

이런 방식은 동기식이다. 큐 대기가 없다. 이를 제한 있는 지연이라고 한다