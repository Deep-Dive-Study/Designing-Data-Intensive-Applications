# 08. 분산 시스템의 골칫거리
- 분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다름
  - 엔지니어로서 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축하는 것이 중요함

## 결함과 부분 장애
- 단일 컴퓨터에서는 하드웨어가 올바르게 동작하다면 같은 연산은 항상 같은 결과를 냄(결정적)
  - 결함(문제)이 있더라도, 시스템은 잘못된 결과를 반환하기 보다 완전히 실패하는 결과를 낳음
  - 즉, 중간 상태가 되지 않음 

- 하지만, 분산 시스템에서는 시스템의 어떤 부분을 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나기도 함( **`비결정적`** , **`부분 장애`** )
  - 뭐가 성공했는지, 아닌지를 알지 못할수도 있음 

### 클라우드 컴퓨팅과 슈퍼 컴퓨팅
- 대규모 컴퓨터 시스템을 구축하는 방법은 `고성능 컴퓨팅(스케일 업)`과 `클라우드 컴퓨팅(스케일 아웃)`이 있음
  - 구축 방법에 따라 결함 처리 방법도 매우 다름

- 고성능 컴퓨터는 단일 노드 컴퓨터(슈퍼 컴퓨터) 환경에 가깝기 때문에, 장애 시점부터 재시작하면 됨(비교적 장애 처리가 쉬움)
- 반면, 클라우드 컴퓨팅은 일반적인 웹(인터넷) 환경에서 동작하는 애플리케이션을 구현하는 시스템이기 때문에, 사용자에게 지연시간이 낮은 서비스를 제공해야하기 때문에 서비스를 중단할 수 없음
  - 시스템이 커질수록(노드가 많아질 수록) 구성 요소 중 하나가 고장날 가능성도 높아짐(항상 어딘가 고장이 나있는 상태라고 보는 편이 좋음)
  - 특화된 하드웨어를 이용할수 없음(실패율이 높음)

- 분산 시스템이 동작하게 만들려면 **`부분 장애 가능성을 받아들이고 내결함성 메커니즘을 넣어야 함`**
  - 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야함(이미 많은 시스템이 해당 방식으로 동작중)

- 즉, 최선의 상황을 바라기보다는 발생 가능성이 상당히 낮은 결함이더라도 광범위하게 고려해야함
  - SPoF(단일 장애 지점)이 없도록 해야함
  - 결함이 발생했을때 시스템이 어떻게 동작하는지 테스트하는 것도 중요함

## 신뢰성 없는 네트워크
- 보통의 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비로 구성된 시스템
  - 각 장비들은 네트워크를 통해야만 통신할 수 있음

- 일반적인 인터넷(웹) 기반 서비스들에서는 `비공유 분산 시스템`이 대규모 컴퓨팅 시스템을 구축하는 주된 방법임
  - 하드웨어가 상대적으로 저렴하기 때문(스케일 아웃 > 스케일 업)
  - 클라우드 서비스를 사용할 수 있기 때문
  - 지리적으로 분산시켜 높은 신뢰성과 지연 시간을 낮출수 있기 때문 

- 인터넷과 데이터센터 내부 네트워크는 대부분 **비동기 패킷 네트워크** 임(이더넷)
  - 즉, 메시지가 언제 도착할지, 도착하기는 할것인지 보장하지 않음

- 요청을 보내고 응답을 기다릴 때 잘못될 수 있는 상황이 많음
  - 요청 손실
  - 요청이 큐에서 대기하다 나중에 전송
  - 원격 노드에 장애가 발생
  - 원격 노드가 응답을 뭠췄지만 나중에 다시 응답가능
  - 원격 노드가 응답을 처리했지만 응답이 네트워크에서 손실
  - 원격 노드가 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있음

- 전송 측에서는 패킷이 정상적으로 전송됐는지 아닌지 구별할 수 없음. 유일하게 아는 정보는 응답을 받지 못했다는 사실 뿐
  - 응답을 받지 못했다면 그 이유를 아는 것은 불가능함 

  ![CleanShot 2025-05-18 at 04 52 07](https://github.com/user-attachments/assets/5b439b95-6aac-488d-b7a5-64df9a3e4d7a)

- 이런 문제를 다루는 흔한 방법 중 하나는 **`타임아웃`** 임

### 현실의 네트워크 결함
- 현실에서는 다양한 이유로 네트워크 결함이 발생함
  - 데이터센터 처럼 제어된 환경에서도 매우 흔하게 발샘함 
  - 네트워크 장비를 중복 추가한다고 기대한만큼 결함이 줄어들지 않음. 즉, 인적 오류가 주요 원인

- 반드시 네트워크 결함을 견뎌내도록(tolerating) 처리할 필요는 없음
  - 단순하게 오류메시지를 보여주어도 됨
- 다만, 소프트웨어가 네트워크 문제에 어떻게 반응하는지 알고, 시스템이 그로부터 복구할 수 있도록 보장해야함(카오스 몽키)

### 결함 감지
- 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야함
  - 로드 밸런서는 죽은 노드로 요청이 전송되지 않도록 해야함
  - 단일 리더 복제기반의 데이터베이스는 리더에서 장애가 발생하면 팔로워중 하나가 리더로 승격되어야함

- 안타깝게도, 네트워크에 관한 불확실성은 노드의 장애 여부를 판단하기 어렵게함
  - 특정한 환경에서는 노드가 동작하지 않는다고 명시적으로 피드백을 받을 수도 있음
    - 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 RST, FIN 패킷을 응답으로 보내 tcp연결을 닫음. 그러나 노드가 요청을 처리하다 죽으면 원격 노드에서 데이터가 어느정도 처리됐는지 알 수 없음
    - 노드 프로세스가 죽었지만 노드 운영체제는 실행중이라면 다른 노드에게 프로세스가 죽은 사실을 알려 타임아웃이 만료되기를 기다릴 필요 없게 할 수 있음
    - 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근 가능하다면 하드웨어 수준을 감지할 수 있음

- 어플리케이션 자체로부터 긍정적 응답을 받아야 성공적으로 요청이 처리되었다고 할 수 있음
  - 일반적인 환경에서는 아무 응답도 받지 못할 것이라고 가정하는게 합리적임
  - 어플리케이션 수준에서 재시도 후, 응답을 받지 못하면 노드가 죽었다고 선언할 수 있음

### 타임아웃과 기약 없는 지연
- 타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어짐
- 반대로, 타임아웃이 짧으면 결함을 빨리 발견하지만, 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아짐 
  - 적절한 타임 아웃 값을 설정하기 위한 정답은 없음

- 비동기 네트워크는 기약 없는 지연(unbounded delay)이 있음
  - 즉, 패킷이 도착하는 데 걸리는 시간에 상한치가 없음

### 네트워크 혼잡과 큐 대기
- 여러 장비가 같은 목적지로 트래픽을 보내면 네트워크 스위치 큐가 가득찰 수 있음

  ![CleanShot 2025-05-18 at 05 09 18](https://github.com/user-attachments/assets/63dfb569-b1a1-424f-b19a-ea00e083f861)

- 패킷 지연의 변동성은 큐 대기 때문인 경우가 많음
  - 네트워크는 잘 동작해도 스위치 큐가 꽉 채워지면 패킷이 유실되어 재전송해야함
  - 패킷이 목적지 장비에 도착했는데 cpu가 바쁜 상태라면 운영체제가 큐에 넣어둠
  - 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 cpu 코어를 사용할 때 멈추는 경우가 흔함
    - 가상 장비 모니터가 들어오는 데이터를 큐에 넣음
  - tcp는 흐름제어를 하는데 네트워크에 들어가기 전에도 큐 대기를 할 수 있음

- 고정된 타임아웃 보단 지속적으로 응답시간을 관찰해 자동 조절하게 하는 것이 좋음(파이 증가 장애 감지기)
    
### 동기 네트워크 대 비동기 네트워크
- 전화 네트워크같은 경우에는 극단적인 신뢰성을 지님
  - 통화를 할 때 회선이 만들어지고 통화에 대한 고정되고 보장된 양의 대역폭이 할당되는 방식

- 즉, 전화 네트워크는 `동기식 네트워크`라고 할 수 있음(제한 있는 지연)

#### 그냥 네트워크 지연을 예측 가능하게 만들 수는 없을까?
- 전화나 영상 통화는 전송되는 비트 개수가 고정되어 있어 회선을 사용할 수 있음
- 다만, 순간적으로 몰리는 트래픽(bursty traffic)을 회선을 처리하기에는 비효율적임
  - TCP는 네트워크 용량에 맞춰 전송률을 동적으로 조절함

- 서비스 품질(QOS)와 진입 제어를 사용해 패킷 네트워크에서 회선 교환을 흉내낼 수 있음
  - 비용 문제가 있음. 네트워크에서 변동이 큰 지연은 자연 법칙이 아닌 비용/이득의 트레이드 오프의 결과임

- 현재 기술로는 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생한다 가정해야함
    
## 신뢰성 없는 시계
- 애플리케이션에서는 다양한 방식으로 시계/시간에 의존하고 있음
  - 이 요청이 타임아웃되었는지?
  - 이 서비스의 99분위 응답 시간은 어떻게 되는지?
  - 이 서비스는 지난 5분 동안 평균 초당 몇 개의 쿼리를 처리하는지?
  - 사용자가 우리 사이트에서 시간을 얼마나 보냈는지?
  - 이 기사가 언제 게시 되었는지?
  - 며칠 몇 시에 미리 알림 이메일을 보내야하는지?
  - 이 캐시 항목은 언제 만료가 되는지?
  - 로그 파일에 남은 오류 메시지의 타임스탬프는 무엇인지?
 
- 위의 항목에서 1,2는 지속 시간을 측정하고 5,8은 시점을 기술함
- 네트워크에 있는 개별 장비들은 자신의 시계를 가지고 있으나, 이 시계는 완벽히 정확하지는 않음(서로 다름)
  - 네트워크 시간 프로토콜(NTP)를 사용하여 시계를 조정하고 있음

- 분산 시스템에서는 통신이 즉각적이지 않아 시간을 다루기 까다로움
  - 여러 장비에서 시간이 달라지게 되었을 때는 어떤 일이 발생한 순서를 알아내기 어려워짐 

### 단조 시계 대 일 기준 시계
- 현대 컴퓨터는 최소 두 가지 종류의 시계를 가
  - `일 기준 시계` : 직관적으로 시계에 기대하는 일을 하는 시계
    - Epoch 이래로 흐른 초 수를 반환(UTC 1970년 1월 1일)
    - 보통 NTP로 동기화됨
  - `단조 시계` : 단조 시계는 타임 아웃이나 서비스 응답 시간 같은 구간을 재는 데 적합한 시계
    - 단조란, 항상 앞으로 흐른다는 의미
    - 분산 시스템에서는 엄밀하게 단조가 적용되긴 어려움

- NTP는 로컬 시계가 NTP 서버보다 빠르거나 느리면 조정할 수 있음
  - 로컬 시계가 NTP 서버보다 너무 앞서면 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보일 수도 있음(0.05% 올리거나 내리는 것을 허용)
  - 단조 시계에서는 앞이나 뒤로 뛰게 할 수는 없음

### 시계 동기화와 정확도
- 정확한 시계를 알려주는 방법은 생각보다 정확하지 않을 수 있음
  - 컴퓨터 수정 시계는 아주 정확하지는 않음(온도에 따라 변화하는 드리프트 현상 발생)
  - 윤초 문제
  - 가상 장비에서 CPU 코어가 공유될 때 각 VM은 다른 VM이 실행되는 동안 수십 밀리초간 멈추는 문제가 있음

- 컴퓨터 시계가 NTP 서버와 너무 차이가 많이나면 강제 리셋됨
  - 다만, NTP와 방화벽으로 통신이 안될 수 있고, 네트워크 지연에 의존적임

- 시계 정확도가 중요해서 상당한 자원을 투입할 생각이 있다면 시계 정확도를 매우 높힐 수는 있음
  → GPS 수신기, 정밀 시간 프로토콜, 세심한 배포 및 모니터링

### 동기화된 시계에 의존하기
- 시계는 간단하고 사용하기 쉬워보이지만 생각보다 많은 함정이 존재함
- 소프트웨어의 어떤 부분이 정확히 동기화된 시계에 의존한다면, 그 결과는 극적인 고장보다는 조용하고 미묘한 데이터 손실이 발생할 가능성이 높음
  - 견고한 소프트웨어를 구축하기 위해서는 잘못된 시계에 대비할 필요가 있음
  - 따라서, 동기화된 시계가 필요하다면 모든 장비 시계 차이를 모니터링해야 함

#### 이벤트 순서화용 타임스탬프
  
![CleanShot 2025-05-25 at 03 29 26](https://github.com/user-attachments/assets/9ce07854-40c7-46e5-bd65-6df59a1447f3)

- 최종 쓰기 승리(LWW)에서 물리적 시계를 기준으로 한다면, 인과성 오류가 발생할 수 있음
  - 가장 "최근" 값을 유지하고 다른 것들을 버림으로써 충돌을 해소하고자 할때, "최근" 의 정의는 로컬 일 기준 기준 시계에 의존하게 되면 그 시계가 틀릴 수 있음을 알고 있어야함

- 논리적 시계는 증가하는 카운터를 기반으로 하면 이벤트 순서화의 안전한 대안임

#### 시계 읽기는 신뢰 구간이 있다
- 공개 인터넷에 있는 NTP 서버를 사용하면 달성 가능한 최선의 정확도는 수십 밀리초이고 혼잡이 있으면 오차는 100밀리초 이상으로 급증함
- 시간을 서버로부터 얻는다면 불확실성은 마지막 동기화한 시간 후로 `예상되는 NTP 서버의 불확실성 + 네트워크 왕복시간`이 됨
- 스패너(Spanner)에 있는 구글 트루타임 api를 요청하면 **가장 이른것** 과 **가장 늦을 것** 을 가르키는 두개의 시간 값을 받음
- 구간의 너비는 로컬 수정 시계가 더 정확한 시계 출처와 마지막으로 동기화된 이후로 얼마나 지났는지에 의존함

#### 전용 스냅숏용 동기화된 시계
- 스냅숏 격리 구현은 단조 증가하는 트랜잭션 ID가 필요함
- 여러 데이터센터에 있는 여러 장비에 데이터베이스가 있을 때는 전역 단조 증가 트랜잭션 ID를 생성하기 어려움
  - 트랜잭션 ID는 인과성을 반영해야하는데, 동기화하는 순간 병목 지점이 됨

- 구글 스패너는 유일하게 동기화된 시계를 사용하는데, 시계 신뢰구간을 측정하고 두 구간이 겹치지 않는다면 인과 관계를 파악할 수 있다는 방식으로 동작함
  - 인과성을 보장하기 위해 의도적으로 신뢰 구간의 길이만큼 커밋 전에 기다림

- 트위터에서 만든 Snowflake ID 나 TSID 같이 분산 환경에서 트랜잭션 id를 채번하기 위한 방법이 나옴
  - https://tech-monster.tistory.com/228 

### 프로세스 중단
- 스플릿 브레인 문제를 해결하는 방법 중 하나는 리더가 다른 노드들로부터 임차권(lease)을 얻는 것임(두개의 리더가 서로가 리더인줄 아는 현상)

  ![CleanShot 2025-05-25 at 03 35 36](https://github.com/user-attachments/assets/052ae554-05f7-4b51-825e-a01befc9d7e9)

- 해당 코드의 문제는 동기화된 시계에 의존한다는 것임. 따라서, 동기화가 깨지면 이상한 일을 할 수 있음
- 만약, 프로그램 실행 중에 중단이 발생할 경우에는 로컬 단조 시계를 사용하더라도 문제가 있을 수 있음
  - 임차를 얻고나서 멈추면, 본인은 멈춘지 모르기 때문에 수행을 시작할테고 실행이 멈추는 동안 다른곳에서 임차를 얻었을 수 있음 

#### 쓰레드가 오래 멈추는 다양한 이유
- GC 발생
- 가상 환경에서 가상 장비는 서스펜드됐다가 재개될 수 있음
- 운영체제가 다른 스레드로 컨텍스트 스위치하거나, 하이퍼바이저가 다른 가상 장비로 스위치되면 스레드는 멈출 수 있음(steal time)
- 장비 부하가 높으면 다시 실행되는 데 시간이 좀 걸릴 수도 있음
- 애플리케이션이 동기식으로 디스크에 접근할때 대기하면서 멈출 수 있음
- 운영체제가 디스크 스왑(페이징)하면서 멈출 수 있음(스레싱:thrashing)

- 이러한 경우가 발생하면 실행 중인 스레드를 어떤 시점에 선점(preempt)하고 얼마간의 시간이 흐른 후 재개하게 됨
  - 선점된 스레드는 이를 알아차리지 못함 

- 이러한 문제는 **`단일 장비에서 다중 스레드 코드를 스레드 안전하게 만드는 것과 유사함`**
  - 단일 장비에서 다중 스레드 코드를 작성할 때 그 코드를 스레드 안전하게 만들 수 있는 좋은 도구가 많음(뮤텍스, 세마포어, 등)
  - 다만, 분산 시스템의 노드는 어느 시점에 실행이 상당 시간 멈출 수 있다고 가정해야 함

#### 응답 시간 보장
- 항공기, 로켓, 자동차, 물리적 물체를 제어하는 시스템과 같은 환경은 정해진 시간 안에 응답해야 하는 데드라인이 명시됨
  - 엄격한 실시간 시스템(hard real-time)
- 시스템에서 실시간 보장을 제공하려면 소프트웨어 스택의 모든 수준의 지원이 필요함
- 따라서, 프로세스가 명시된 간격의 CPU 시간을 할당 받도록 보장하는 스케줄링을 지원하는 실시간 운영체제(RTOS)가 필요함
  - 대부분 서버측 데이터 처리 시스템에게 실시간 보장은 적절하지 않음(비경제적)

- 비 실시간 환경에서 운영될 때는 발생하는 중단 시간 불안정의 영향을 많이 받을 수 있음

#### 가비지 컬렉션의 영향을 제한하기
- 런타임이 애플리케이션에게 노드가 곧 GC 중단이 필요하다는 경고를 할 수 있다면 해당 노드로 요청을 멈추게 할 수 있음
  - 이런 방법은 클라이언트로부터 GC 중단을 감추고 응답 시간의 상위 백분위를 줄여줌
- 수명이 짧은 객체만 가비지 컬렉터를 사용하고 수명이 긴 객체의 전체 gc가 필요할만큼 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있음

## 지식, 진실, 그리고 거짓말
- 분산 시스템에서는 공유 메모리가 없고 지연 변동이 큰 신뢰할 수 없는 네트워크를 통해 메세지를 보낼 수 있을 뿐이며, 부분 장애, 신뢰성 없는 시계, 프로세스 중단에 시달리 수 있음
  - 네트워크 기반으로 데이터를 보내야 하기 때문에 어떤 것도 확실히 알지 못함. 메세지를 기반으로 추측할 뿐

- 분산 시스템에서 우리는 동작(시스템 모델)에 관해 정한 가정을 명시하고, 가정을 만족시키는 방식으로 설계할 수 있음

### 진실은 다수결로 결정된다
- 비대칭적인 결함이 있는 네트워크 환경에서는 아래와 같은 시나리오가 발생 가능함
  - 노드는 자신에게 보내지는 메세지는 모두 받을 수 있지만, 보내는 메세지는 유실되거나 지연될 수 있음. 이러한 상황은 노드가 정상적으로 메세지를 받을 수 있는 상태여도 Timeout이 발생하면 노드를 죽었다고 판단하게 함
  - 한쪽 연결이 끊긴 노드는 보내는 메세지가 다른 노드로부터 응답을 받지 못하는 것을 알아내서 결함이 있는게 확실하다고 깨달을 수 있음. 그럼에도 다른 노드들이 노드가 죽었다고 잘못 선언하고, 한쪽 연결이 끊긴 노드는 그에 대해 아무 일도 할 수 없음
  - 긴 stop-the-world 가비지 컬렉션 중단 모든 스레드는 GC에 선점되고 1분동안 멈춤. 결과적으론 아무 요청도 처리되지 못하고 아무 응답도 전송되지 않음. 기다리면서 재시도 하다가 결국엔 노드가 죽었다고 판단. GC가 끝나고 스레드들은 실행은 재개

- 즉, 노드가 상황에 대한 자신의 판단을 반드시 믿을 수 있는 것은 아니라는 뜻
  - 분산 시스템에서는 한 노드에만 의존할 수 없음(개별 노드는 언제든 장애가 날 수 있음)
 
- 많은 분산 알고리즘은 `정족수(quorum)`를 사용하여 노드들 사이의 투표에 의존함
  - 의사 결정(노드가 죽었는지, 등)을 여러 노드로 부터 어떤 최소 개수의 투표를 통해 결정함(보통은 과반)

#### 리더와 잠금
- 시스템을 구현하다보면 유일성(유니크)을 만족해야하는 경우가 있음
  - 스플릿 브레인을 피하기 위해 오직 한 노드만 데이터베이스 파티션의 리더가 되어야함
  - 특정한 자원이나 객체에 동시에 쓰거나 오염시키는 것을 방지하기 위해 오직 하나의 트랜잭션이나 클라이언트만 어떤 자원이나 객체의 잠금을 획득할 수 있어야함
  - 식별자로 사용자를 유일하게 식별할 수 있어야 하므로 오직 한 명의 사용자만 특정한 사용자 명을 사용할 수 있어야함

- 분산 시스템에서는 이를 구현할때 많은 주의가 필요함
  - 노드가 스스로를 "선택된 자"라고 믿더라도 노드의 정족수도 반드시 동의한다는 뜻은 아님
  - 이전에 리더였어도 죽었다고 판단하면 노드는 강등되고 다른 리더가 이미 선출되어 있을 수 있음

    ![CleanShot 2025-06-01 at 21 59 22](https://github.com/user-attachments/assets/b93ca068-8f07-4254-9ca5-a3a30fbc3dad)

    - 쓰기 충돌 사례

#### 펜싱 토큰
- 따라서, 앞선 사례와 같이 잘못된 시스템이 방해할 수 없도록 보장하기 위한 가장 단순한 기법으로 **`펜싱(fencing)`** 이 있음
  - 잠금 서버가 잠금이나 임차권을 승인할때마다 펜싱 토큰(잠금이 승인될 때마다 증가하는 숫자)을 반환하고, 클라이언트가 쓰기 요청을 저장소 서비스로 보낼 때마다 자신의 펭신 토큰을 포함하도록 요구하는 방식

    ![CleanShot 2025-06-01 at 22 01 35](https://github.com/user-attachments/assets/e6a2399c-95b6-4fe9-8273-ca16c7168824)

- 잠금 서비스로 주키퍼를 사용하면 트랜잭션 id zxid나 노드 버전 cversion을 펜싱 토큰으로 사용할 수 있음
  - 이들은 단조 증가가 보장되므로 필요한 속성을 지님

- 이 메커니즘은 자원 자체가 이미 처리된 것보다 오래된 토큰을 사용해서 쓰는 것을 거부함으로써 토큰을 확인하는 활동적인 역할까지 맡아야함
  - 하지만 이러한 것을 사용할 때 잠금으로 보호받지 않는 요청을 처리하지 않도록 일종의 확인이 필요힘
  - 서버 측에서 토큰을 확인하는 것은 좋음

### 비잔틴 결함
- 펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있음
- 그러나 노드가 고의로 시스템의 보장을 무너뜨리려 한다면, 가짜 펜싱 토큰을 포함한 메세지를 보내기만 하면 됨

- 분산 시스템 문제는 노드가 거짓말(임의의 결함이 있거나 오염된 응답을 보냄)을 할지도 모른다고 가정하면 어렵고 복잡해짐.
  - 예를 들어, 어떤 노드가 실제로는 받지 않은 특정 메시지를 받았다고 주장
  - 이러한 동작을 `비잔틴 결함(Byzantine Fault)`이라고 함

- 비잔틴 결합(노드가 받지 않은 메세지를 받았다고 주장)과 같은 경우에서 합의에 도달하는 문제를 `비잔틴 장군 문제(Byzantine Generals Problem)` 이라고 함
  - 비잔틴 장군 문제란?
    - 두 군대의 장군이 소통할 때 전령을 통해서하는 경우에, 전령(네트워크 패킷)은 때때로 늦거나 실종되는 경우가 있었음
    - 또한, 배신자가 있어서 사실에 방해를 줄 수도 있고, 가짜나 허위 메세지를 보내 다른 장군들을 속이거나 혼란스럽게 하려고 시도할 수 있는 위험이 존재하는 상황임
    - 일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 올바르게 동작하면 `비잔틴 내결함성(Byzantine fault tolerant)`을 지닌다고 함

- 이러한 문제는 일반적인 상황보다는 특수한 상황에서 문제를 해결하는데 도움이됨 
  - 항공 우주 산업 환경에서 CPU나 메모리가 오염되면 사람이 모두 죽거나 로켓이 우주 정거장에 충돌하는 일이 발생할 수 있음
  - 여러 조직이 참여하는 시스템에서는 어떤 참여자들은 다른 사람을 속이거나 사취하려고 할 수 있음(비트코인)
    - 서로 신뢰할 수 없는 단체들이 중앙 권한에 기대지 않고 트랜잭션이 발생했는지 아닌지를 판단하기 위해 블록체인 같은 P2P 네트워크를 고려할 수 있음
  - 대부분의 시스템은 고려하지 않아도 되고, 실제로 이를 해결하는 시스템을 구축하는 것은 매우 어려움. 보통은 하드웨어 수준의 지원에 의존함

- 웹 애플리케이션에선 클라이언트의 행동이 임의적이고 악의적이라고 예상하여 동작하는 것과 유사
- 다만, 비자틴 결함과 차이점은 허용된 것인지 아닌지를 결정하는 권한을 서버에게 줄 뿐임
- 비잔틴 내결함성은 이런 중앙 권한이 없는 P2P 네트워크에 더 적절함
- 소프트웨어 버그가 비잔틴 결함으로 간주할 수 있지만, 도움이 되진 않음
- 버그를 막으려면 독립적으로 구현한 것이 N개가 있어야하고 그 중에 버그가 하나만 있길 바래야 함

#### 약한 형태의 거짓말
- 노드 들이 일반적으로 정직하다고 가정하지만 약한 형태의 `거짓말`(ex. 하드웨어 문제, 소프트웨어 버그, 잘못된 설정, 등)로 부터 보호해주는 메커니즘을 소프트웨어에 추가하는게 가치가 있을 수 있음
- 이런 보호 메커니즘은 완전한 비잔티 내결함성을 지니지는 않지만 그럼에도 더욱 나은 신뢰성을 보장하고자 할때 유의미함
  - 네트워크 패킷은 오류는 프토토콜 체크섬을 통해 오염을 방지
  - 사용자 입력(Input validation)을 확인하고 살균(sanitization)을 적용
    - 합당한 범위에 속하는지 확인
    - 문자열 크기 제한
    - SQL Injection 방지
  
  - NTP 클라이언트는 여러 서버 주소를 설정하기
    - 서버 중 다수가 어떤 시간 범위에 동의하는지 확인할 수 있음
    - 잘못된 서버를 검출해서 동기화 대상에서 제거할 수 있음

### 시스템 모델과 현실
- 시스템 모델(system model)은 알고리즘이 가정하는 것을 기술한 추상화임

- 타이밍 가정에 대한 세가지 시스템 모델
  - `동기식 모델`
    - 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정
    - 어떤 고정된 상한치를 초과하지 않는다고 생각함
    - 현실적인 모델은 아님 → 기약없는 지연과 중단이 발생할 수 있기 때문
  
  - `비동기식 모델`
    - 어떠한 가정도 할 수 없음
    - 시계가 없을 수도 있음을 가정(Timeout이 사용 불가한 경우)

  - `부분 동기식 모델`
    - 대부분의 시간에는 동기식 시스템처럼 동작함
    - 하지만, 가끔 네트워크 지연, 프로세스 중단, 시계 드리프트의 한계치를 초과할 수 있다고 가정
    - 가끔 어떤 타이밍 가정이 산산조각 날수 있음(고려 필요)

- 노드 장애에 대한 모델
  - `죽으면 중단하는(crash-stop) 결함`
    - 노드에 장애가 나는 방식은 하나 뿐 → 오직 죽는 것 뿐이라고 가정
    - 응답하기를 멈추면 이후로 노드는 영원히 사용할 수 없게 됨

  - `죽으면 복구하는(crash-recovery) 결함`
    - 알려지지 않은 시간이 흐른 후에는 아마도 다시 응답하기 시작할 것이라고 가정
    - 노드는 메모리에 있는 상태는 손실될 수 있으나, 안정된 저장소가 있다고 가정함(비휘발성)

  - `비잔틴(임의적인) 결함`
    - 다른 노드를 속이거나 기만하는 것을 포함해 전적으로 무슨 일이든 할 수 있다고 가정

- 현실 시스템을 모델링하는 데는 **`죽으면 복구하는 결함을 지닌 부분 동기식 모델`** 이 가장 유용한 모델임

#### 알고리즘 정확성
- 알고리즘이 정확하다(correcct)는게 어떤 의미인지 정의하기 위해 알고리즘의 속성(property)을 기술할 수 있음
  - 해당 알고리즘이 어떤 가정을 만족하는지 정의하는 방법 
- 예를 들어)
  - 잠금에 사용할 펜싱 토큰을 생성

    - 유일성
      - 펜싱 토큰 요청이 같은 값을 반환하지 않음
    
    - 단조 일련번호
      - 요청 x가 토큰 tx를 요청 y가 토큰 ty를 반환했고, y가 시작하기 전에 x가 완료되었다면 tx < ty를 만족
    
    - 가용성
      - 펜신 토큰을 요청하고 죽지 않은 노드는 결국에는 응답을 받음
 
- 모든 상황에서 그 속성들을 항상 만족시키면 해당 시스템 모델에서 정확함
- 하지만 모든 노드가 죽거나 모든 네트워크 지연이 갑자기 무한히 길어진다면 어떤 알고리즘이라도 아무것도 할 수 없음

#### 안전성과 활동성
- 상황을 분명히 하기 위해 두 가지 다른 종류의 속성, 안정성(safety)과 활동성(liveness)을 구별할 필요가 있음
  - 유일성과 단조 일련번호는 안정성 속성인 반면에, 가용성은 활동적 속성 
  
- 안전성 : 나쁜일은 일어나지 않는다.
- 활동성 : 좋은 일은 결국 일어난다.

- 안전성은 위반되면 그 속성이 깨진 특정 시점을 가리킬 수 있음
  - 위반된 후에는 그 위반을 취소할 수 없게됨(이미 손상된 상태)
  - 분산 알고리즘에선 안전성 속성이 항상 만족되기를 요구하는게 일반적임(잘못된 결과를 반환하지 않는다고 보장)

- 활동성 속성은 결국에는(eventually) 이라는 단어를 포함함 (ex. 최종적 일관성)
  - 어떤 시점을 정하지 못할 수 있지만, 항상 미래에 그 속성을 만족시킬 수 있다는 희망이 있음
  - 활동성 속성은 경고를 하는 게 허용됨
    - 노드의 다수가 죽지 않고 네트워크 중단으로부터 복구됐을 때만 요청이 응답을 받아야 함
    - 부분 동기식에선 결국 동기식 상태로 돌아오기를 기대함

#### 시스템 모델을 현실 세계에 대응 시키기
- 안정성 및 활동성 속성과 시스템 모델은 분산 시스템의 정확성을 따져보는데 매우 유용함
  - 그러나, 현업에서 알고리즘을 구현할때 현실의 지저분한 사실들이 우리를 곤란하게함(시스템 모델은 단순화된 추상화일 뿐..) 

- 예를 들어)
  - 정족수 알고리즘은 노드가 저장했다고 선언한 데이터를 기억하고 있다는 것에 의존함
  - 실제 구현에서는 저장소 오염, 하드웨어 오류 등과 같은 현실적인 문제도 같이 고려해야 함
  
- 즉, 추상 시스템 모델은 문제를 이해하고 해결하는 데 도움이 되지만, 현실 구현에서는 항상 적용되지 않을 수 있음
- 따라서, 이론적 분석과 경험적 실험이 함께 필요함
