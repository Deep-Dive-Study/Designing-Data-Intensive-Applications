# 08. 분산 시스템의 골칫거리
- 분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다름
  - 엔지니어로서 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축하는 것이 중요함

## 결함과 부분 장애
- 단일 컴퓨터에서는 하드웨어가 올바르게 동작하다면 같은 연산은 항상 같은 결과를 냄(결정적)
  - 결함(문제)이 있더라도, 시스템은 잘못된 결과를 반환하기 보다 완전히 실패하는 결과를 낳음
  - 즉, 중간 상태가 되지 않음 

- 하지만, 분산 시스템에서는 시스템의 어떤 부분을 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나기도 함( **`비결정적`** , **`부분 장애`** )
  - 뭐가 성공했는지, 아닌지를 알지 못할수도 있음 

### 클라우드 컴퓨팅과 슈퍼 컴퓨팅
- 대규모 컴퓨터 시스템을 구축하는 방법은 `고성능 컴퓨팅(스케일 업)`과 `클라우드 컴퓨팅(스케일 아웃)`이 있음
  - 구축 방법에 따라 결함 처리 방법도 매우 다름

- 고성능 컴퓨터는 단일 노드 컴퓨터(슈퍼 컴퓨터) 환경에 가깝기 때문에, 장애 시점부터 재시작하면 됨(비교적 장애 처리가 쉬움)
- 반면, 클라우드 컴퓨팅은 일반적인 웹(인터넷) 환경에서 동작하는 애플리케이션을 구현하는 시스템이기 때문에, 사용자에게 지연시간이 낮은 서비스를 제공해야하기 때문에 서비스를 중단할 수 없음
  - 시스템이 커질수록(노드가 많아질 수록) 구성 요소 중 하나가 고장날 가능성도 높아짐(항상 어딘가 고장이 나있는 상태라고 보는 편이 좋음)
  - 특화된 하드웨어를 이용할수 없음(실패율이 높음)

- 분산 시스템이 동작하게 만들려면 **`부분 장애 가능성을 받아들이고 내결함성 메커니즘을 넣어야 함`**
  - 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야함(이미 많은 시스템이 해당 방식으로 동작중)

- 즉, 최선의 상황을 바라기보다는 발생 가능성이 상당히 낮은 결함이더라도 광범위하게 고려해야함
  - SPoF(단일 장애 지점)이 없도록 해야함
  - 결함이 발생했을때 시스템이 어떻게 동작하는지 테스트하는 것도 중요함

## 신뢰성 없는 네트워크
- 보통의 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비로 구성된 시스템
  - 각 장비들은 네트워크를 통해야만 통신할 수 있음

- 일반적인 인터넷(웹) 기반 서비스들에서는 `비공유 분산 시스템`이 대규모 컴퓨팅 시스템을 구축하는 주된 방법임
  - 하드웨어가 상대적으로 저렴하기 때문(스케일 아웃 > 스케일 업)
  - 클라우드 서비스를 사용할 수 있기 때문
  - 지리적으로 분산시켜 높은 신뢰성과 지연 시간을 낮출수 있기 때문 

- 인터넷과 데이터센터 내부 네트워크는 대부분 **비동기 패킷 네트워크** 임(이더넷)
  - 즉, 메시지가 언제 도착할지, 도착하기는 할것인지 보장하지 않음

- 요청을 보내고 응답을 기다릴 때 잘못될 수 있는 상황이 많음
  - 요청 손실
  - 요청이 큐에서 대기하다 나중에 전송
  - 원격 노드에 장애가 발생
  - 원격 노드가 응답을 뭠췄지만 나중에 다시 응답가능
  - 원격 노드가 응답을 처리했지만 응답이 네트워크에서 손실
  - 원격 노드가 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있음

- 전송 측에서는 패킷이 정상적으로 전송됐는지 아닌지 구별할 수 없음. 유일하게 아는 정보는 응답을 받지 못했다는 사실 뿐
  - 응답을 받지 못했다면 그 이유를 아는 것은 불가능함 

  ![CleanShot 2025-05-18 at 04 52 07](https://github.com/user-attachments/assets/5b439b95-6aac-488d-b7a5-64df9a3e4d7a)

- 이런 문제를 다루는 흔한 방법 중 하나는 **`타임아웃`** 임

### 현실의 네트워크 결함
- 현실에서는 다양한 이유로 네트워크 결함이 발생함
  - 데이터센터 처럼 제어된 환경에서도 매우 흔하게 발샘함 
  - 네트워크 장비를 중복 추가한다고 기대한만큼 결함이 줄어들지 않음. 즉, 인적 오류가 주요 원인

- 반드시 네트워크 결함을 견뎌내도록(tolerating) 처리할 필요는 없음
  - 단순하게 오류메시지를 보여주어도 됨
- 다만, 소프트웨어가 네트워크 문제에 어떻게 반응하는지 알고, 시스템이 그로부터 복구할 수 있도록 보장해야함(카오스 몽키)

### 결함 감지
- 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야함
  - 로드 밸런서는 죽은 노드로 요청이 전송되지 않도록 해야함
  - 단일 리더 복제기반의 데이터베이스는 리더에서 장애가 발생하면 팔로워중 하나가 리더로 승격되어야함

- 안타깝게도, 네트워크에 관한 불확실성은 노드의 장애 여부를 판단하기 어렵게함
  - 특정한 환경에서는 노드가 동작하지 않는다고 명시적으로 피드백을 받을 수도 있음
    - 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면 RST, FIN 패킷을 응답으로 보내 tcp연결을 닫음. 그러나 노드가 요청을 처리하다 죽으면 원격 노드에서 데이터가 어느정도 처리됐는지 알 수 없음
    - 노드 프로세스가 죽었지만 노드 운영체제는 실행중이라면 다른 노드에게 프로세스가 죽은 사실을 알려 타임아웃이 만료되기를 기다릴 필요 없게 할 수 있음
    - 데이터센터 내 네트워크 스위치의 관리 인터페이스에 접근 가능하다면 하드웨어 수준을 감지할 수 있음

- 어플리케이션 자체로부터 긍정적 응답을 받아야 성공적으로 요청이 처리되었다고 할 수 있음
  - 일반적인 환경에서는 아무 응답도 받지 못할 것이라고 가정하는게 합리적임
  - 어플리케이션 수준에서 재시도 후, 응답을 받지 못하면 노드가 죽었다고 선언할 수 있음

### 타임아웃과 기약 없는 지연
- 타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어짐
- 반대로, 타임아웃이 짧으면 결함을 빨리 발견하지만, 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언할 위험이 높아짐 
  - 적절한 타임 아웃 값을 설정하기 위한 정답은 없음

- 비동기 네트워크는 기약 없는 지연(unbounded delay)이 있음
  - 즉, 패킷이 도착하는 데 걸리는 시간에 상한치가 없음

### 네트워크 혼잡과 큐 대기
- 여러 장비가 같은 목적지로 트래픽을 보내면 네트워크 스위치 큐가 가득찰 수 있음

  ![CleanShot 2025-05-18 at 05 09 18](https://github.com/user-attachments/assets/63dfb569-b1a1-424f-b19a-ea00e083f861)

- 패킷 지연의 변동성은 큐 대기 때문인 경우가 많음
  - 네트워크는 잘 동작해도 스위치 큐가 꽉 채워지면 패킷이 유실되어 재전송해야함
  - 패킷이 목적지 장비에 도착했는데 cpu가 바쁜 상태라면 운영체제가 큐에 넣어둠
  - 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 cpu 코어를 사용할 때 멈추는 경우가 흔함
    - 가상 장비 모니터가 들어오는 데이터를 큐에 넣음
  - tcp는 흐름제어를 하는데 네트워크에 들어가기 전에도 큐 대기를 할 수 있음

- 고정된 타임아웃 보단 지속적으로 응답시간을 관찰해 자동 조절하게 하는 것이 좋음(파이 증가 장애 감지기)
    
### 동기 네트워크 대 비동기 네트워크
- 전화 네트워크같은 경우에는 극단적인 신뢰성을 지님
  - 통화를 할 때 회선이 만들어지고 통화에 대한 고정되고 보장된 양의 대역폭이 할당되는 방식

- 즉, 전화 네트워크는 `동기식 네트워크`라고 할 수 있음(제한 있는 지연)

#### 그냥 네트워크 지연을 예측 가능하게 만들 수는 없을까?
- 전화나 영상 통화는 전송되는 비트 개수가 고정되어 있어 회선을 사용할 수 있음
- 다만, 순간적으로 몰리는 트래픽(bursty traffic)을 회선을 처리하기에는 비효율적임
  - TCP는 네트워크 용량에 맞춰 전송률을 동적으로 조절함

- 서비스 품질(QOS)와 진입 제어를 사용해 패킷 네트워크에서 회선 교환을 흉내낼 수 있음
  - 비용 문제가 있음. 네트워크에서 변동이 큰 지연은 자연 법칙이 아닌 비용/이득의 트레이드 오프의 결과임

- 현재 기술로는 네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생한다 가정해야함
    
  
