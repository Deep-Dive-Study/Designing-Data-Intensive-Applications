# 1. 데이터 부호화 형식

- 데이터 구조
    - 객체, 구조체, 목록, 배열, 해시 테이블, 트리 등의 데이터 구조는 CPU에서 효율적으로 접근, 조작할 수 있도록 보통 포인터를 이용해 최적화된다.

이러한 포인터는 다른 프로세스가 이해할 수 없으므로 데이터 파일 작성, 네트워크 전송하기 위해서는 바이트열 형태로 부호화해야 한다. 데이터 전환은 공통적인 문제이기에 많은 선택지가 있다.

- 부호화 (직렬화, 마샬링)
    - 바이트열로 전환한다.
- 복호화 (파싱, 역직렬화, 언마샬링)
    - 바이트열을 원래 데이터로 복원한다.

## 1) 언어별 형식

- 프로그래밍 언어에 내장된 부호화 라이브러리
    - java: java.io.Serializable
    - ruby: Marshal
    - python: pickle
- 내장된 부호화 라이브러리 문제점
    - 부호화는 특정 프로그래밍 언어에 묶여 있어 다른 언어에서 데이터를 읽기 어렵다.
    - 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다.
    - 데이터 버전 관리가 필요하지만 데이터를 빠르고 쉽게 부호화하기 위해 상위, 하위 호환성의 불편한 문제가 나오기도 한다.
    - 부호화, 복호화에 소요되는 CPU 시간과 부호화된 구조체의 크기를 생각해야 한다.

## 2) JSON과 XML, 이진 변형

JSON, XML은 널리 쓰이지만 단점들이 있다.

- JSON 단점
    - 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
- XML 단점
    - 수와 숫자로 구성된 문자열을 구분할 수 없다.
- 공통 단점
    - 이진 문자열(문자 부호화가 없는 바이트열)을 지원하지 않는다. → 이진 문자열의 유용성 때문에 이진 데이터를 Base64를 사용해 텍스트로 부호화하여 제한을 피하기도 한다.
    - XML, JSON 모두 스키마를 지원하지만 XML/JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩 해야할 수 도 있다.

### 2-1) 이진 부호화

JSON, XML은 이진 형식에 비교하면 많은 공간을 사용한다. 다양한 시장에서 JSON, XML용으로 사용 가능한 이진 부호화 개발이 이어졌지만 텍스트 버전처럼 널리 채택되진 않았다. 여러 버전 중에서는 데이터 타입 셋을 확장하여 정수, 부동소수점 수의 구분 등의 이진 문자열 지원하기도 했다.

**텍스트 JSON 부호화**

스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.

```json
{
	"userName": "Martin",
	"favoriteNumber": 1337,
	"interests": ["daydreaming", "hacking"]
}
```

**JSON 이진 부호화 (메시지팩)**

- 첫 번째 바이트 (0x83)
    - 세 개의 필드(하위 4비트 = 0x03)
    - 객체(상위 4비트 = 0x80)
- 두 번째 바이트 (0xa8)
    - 8바이트 길이(하위 4비트 = 0x08)
    - 문자열(상위 4비트 = 0xa0)
- 다음 8바이트(3 ~ 10)
    - 필드 이름 `userName` 의 아스키 코드

![image](https://github.com/user-attachments/assets/8d83f7d6-44e1-4e4b-acb6-f37950019d56)


## 3) 스리프트와 프로토콜 버퍼

- 이진 부호화 라이브러리
    - 아파치 스리프트(Apache Thrift): 페이스북 개발
    - 프로토콜 버퍼(Protocol Buffers): 구글 개발

아파치 스트리프와 프로토콜 버퍼  모두 부호화할 데이터를 위한 스키마가 필요하다. 스프리트 데이터를 부호화하려면 아래와 같은 스리프트 인터페이스 정의 언어(interface definition language, IDL)로 스키마를 기술해야 한다.

**스리프트 인터페이스 정의 언어**

```json
struct Person {
	1: required string       userName,
	2: optional i64          favoriteNumber,
	3: optional list<string> interests
}
```

프로토콜 버퍼로 정의한 스키마도 비슷하다.

**프로토콜 버퍼 인터페이스 정의 언어**

```json
message Person {
 required string user_name       = 1;
 optional int64  favorite_number = 2;
 repeated string interests       = 3;
}
```

스리프트와 프로토콜 버퍼의 스키마 정의를 사용해 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성할 수있다. 애플리케이션 코드는 생성된 코드를 호출해 스키마의 레코드를 부호화하고 복호화 할 수 있다. 아래에서 이러한 스키마로 부호화된 데이터 모습을 봐보자. 스리프트에는 두 가지 다른 이진 부호화가 있다.

**스리프트 바이너리 프로토콜**

메시지팩 부호화와 비교했을 떄 차이점으로는 필드 이름이 없는다는 점이 있다. 대신에 부호화된 데이터는 숫자(1, 2, 3)과 같은 `필드 태그`를 포함한다.

![image](https://github.com/user-attachments/assets/9f2a37b0-78e7-4d0f-a0bb-6809783f0d00)


**스리프트 컴팩트 프로토콜**

의미상 바이너리 프로토콜과 같지만 동일한 정보를 더 줄여 부호화한다. 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화한다.

![image](https://github.com/user-attachments/assets/70f03dbd-d99a-435e-bb16-5327192d17b7)


**프로토콜 버퍼**

스리프트와 동일하게 데이터를 부호화하지만 비트를 저장하는 처리 방식이 약간 다르다.

![image](https://github.com/user-attachments/assets/9abe2721-9c7e-4d9b-89d9-43011fed8fb5)


**required, optional 표시**

스카마에서 각 필드에는 required나 optional 표시가 있다. 하지만 부호화하는 방법에 차이가 있는게 아니다. required를 사용하면 필드가 설정되지 않은 경우를 실행 시에 확인할 수 있고 버그 잡을 때 유용하다.

### 3-1) 필드 태그와 스키마 발전

- **스키마 발전 (scheme evolution)**
    - 스키마는 시간이 지남에 따라 변한다.

**스리프트, 프로토콜 버퍼는 하위 호환성과 상위 호환성을 유지하면서 스키마를 어떻게 변경할까?**

부호화된 레코드는 부호화된 필드의 연결일 뿐이다. 부호화된 데이터는 필드 이름을 참조하지 않기 때문에 스키마에서 필드 이름을 변경할 수 있다. 그러나 필드 태그는 기존의 모든 부호화된 데이터를 인식 불가능하게 만들 수 있어 변경할 수 없다.

필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드를 추가할 수 있다. 

- 각 필드 식별
    - 태그 숫자로 식별한다.
    - 데이터 타입을 주석으로 단다.
    - 필드 값을 설정하지 않은 경우는 단순히 부호화 레코드에서 생략한다.

### 3-2) 데이터타입과 스키마 발전

필드의 데이터 타입 변경은 불가능하지는 않다. 다만 값이 정확하지 않거나 잘릴 수도 있다.

예를 들어 8비트 정수를 16비트 정수로 바꿀 경우가 있다.

이 경우에는 새로운 코드로 예전 코드가 기록한 데이터를 쉽게 읽을 수 있다. 하지만 **새로운 코드가 기록한 데이터를 예전 코드로 읽는 경우에는 16비트 정수를 8비트 변수로 읽으려고하여 값이 잘리게된다.**

```json
10100000 -> 00000000 10100000
```

### 3-3) 아브로

아파치 아브로는 프로토콜 버퍼와 스리프트와는 다르지만 또 하나의 이진 부호화 형식이다.

아브로도 부호화할 데이터 구조를 지정하기 위해 스키마를 사용한다.

- 아브로 IDL
    - 사람이 편집할 수 있다.

```json
record Person {
	string               userName;
	union { null, long } favoriteNumber = null;
	array<string>        interests;
}
```

- JSON 기반 언어
    - 기계가 더 쉽게 읽을 수 있다.

```json
{
  "type": "record",
  "name": "Person",
  "fields": [
    {"name": "userName", "type": "string"},
    {"name": "favoriteNumber", "type": ["null", "long"], "default": null},
    {"name": "interests", "type": {"type": "array", "items": "string"}}
  ]
}
```

스키마에 태그 번호가 없어 레코드를 부호화한다면 아브로 이진 부호화 길이는 32바이트로 지금까지 봤던 부호화 길이 중에서 가장 짧다. 바이트열을 살펴보면 필드나 데이터타입을 식별하기 위한 정보도 없다. 부호화는 단순히 연결과 값으로만 구성된다. 

![image](https://github.com/user-attachments/assets/0a17bc11-ea43-434e-8aeb-0e9227ccac72)


이러한 아브로를 이용해 이진 데이터를 파싱하기 위해서는 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야 한다. 즉, **읽는 코드와 기록한 코드가 정확히 같은 스키마를 사용해야만 이진 데이터를 올바르게 복호화할 수 있는 것을 의미**한다.

### 3-4) 쓰기 스키마와 읽기 스키마

- 쓰기 스키마 (writer’s schema)
    - 데이터를 부호화하려면 알고 있는 스키마 버전을 사용해 데이터를 부호화하는 것을 의미한다.
- 읽기 스키마 (reader’s schema)
    - 데이터를 복호화하려면 특정 스키마 버전으로 복호화하는 것을 의미한다.

**아브로의 핵심 아이디어**

- 쓰기 스키마와 읽기 스키마가 동일하지 않아도 된다.
- 호환만 가능하면 된다.
- 데이터를 복호화할 때 아브로 라이브러리는 쓰기 스키마에서 읽기 스키마로 데이터를 변환하여 그 차이를 해소한다.

![image](https://github.com/user-attachments/assets/ef518e11-83ad-4729-87c5-d0c4571068ec)


### 3-5) 스키마 발전 규칙

- 아브로 상위 호환성
    - 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있다.
- 아브로 하위 호환성
    - 새로운 버전의 읽기 스키마와 예전 버전의 쓰기 스키마를 가질 수 있다.

**호환성 유지를 위한 규칙**

- 기본값이 있는 필드만 추가, 삭제할 수 있다.
- 필드의 데이터타입 변경 가능하다.
- 필드 이름 변경도 가능하다. (읽기 스키마는 필드 이름의 별칭을 포함할 수 있어 하위 호환만 가능하다.)

### 3-6) 쓰기 스키마란?

읽기 위해서 특정 데이터를 부호화한 쓰기 스키마를 어떻게 알 수 있을까?

- 많은 레코드가 있는 대용량 파일
    - 동일한 스키마로 수백만 개 레코드를 포함한 큰 파일 저장하는 용도
    - 파일의 쓰기는 파일의 시작 부분에 한 번만 쓰기 스키마를 포함시키면 된다.
- 개별적으로 기록된 레코드를 가진 데이터베이스
    - 모든 레코드가 동일한 스키마를 가진다고 가정할 수 없다. → 간단한 해결책으로 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에는 스키마 버전 목록을 유지한다.
- 네트워크 연결을 통해 레코드 보내기
    - 두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전을 합의할 수 있다.

### 3-7) 동적 생성 스키마

아브로가 프로토콜 버퍼와 스리프트에 비해 동적 생성 스키마에 더 친숙하다. 아브로의 스키마에는 태그 번호가 포함되어 있지 않기 때문이다.

예를 들어 텍스트 형식(JSON, CSV, XML)의 문제점을 피하기 위해 이진 형식을 사용한다고 해보자. 레코드의 필드를 데이터베이스의 칼럼 이름으로 두고 칼럼 이름을 아브로의 필드 이름으로 매핑하면 된다. 하지만 프로토콜 버퍼나 스리프트를 이용하게 될 경우에 필드 태그를 수동으로 할당해야한다.

### 3-8) 스키마의 장점

프로토콜 버퍼, 스리프트, 아브로는 스키마를 사용해서 이진 부호화 형식을 기술한다. 스키마 언어는 XML, JSON보다 훨씬 간단하고 자세한 유효성 검사를 지원한다.

많은 데이터 시스템에서 이진 부호화를 독자적으로 구현하기도 한다. 대부분의 RDB에는 질의를 DB로 보내고 응답 받을 수 있는 네트워크 프로토콜이 있다. 프로토콜은 일반적으로 특정 DB에 특화되고 DB 벤더는 DB 네트워크 프로토콜로부터 응답을 인메모리 데이터 구조로 복호화하는 드라이버(ODBC, JDBC API, …)를 제공한다.

# 2. 데이터 플로 모드

데이터 플로는 추상적인 개념으로 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 많다. 프로세스 간 데이터를 전달하는 보편적인 방법을 알아보자.

## 1) 데이터베이스를 통한 데이터플로

데이터베이스에 기록하는 프로세스는 데이터를 부호화한다. 그리고 데이터베이스에서 읽는 프로세스는 데이터를 복호화한다. 애플리케이션에서 데이터베이스 값을 모델 객체로 복호화하고 다시 부호화하는 변환 과정에서 알지 못하는 필드가 유실될 수 있다. 하지만 이 사실을 알고 있으면 해결할 수 있다.


![image](https://github.com/user-attachments/assets/35405947-36e3-45a6-b5ca-e1ae003e3499)


### 1-1) 다양한 시점에 기록된 다양한 값

애플리케이션의 새로운 버전 배포 시에 예전 버전을 새로운 버전으로 완전히 대체할 수 있지만 데이터베이스 내용은 그렇지 않다. 5년된 데이터는 이후에 명시적으로 다시 기록하지 않는 한 원래의 부호화 상태로 그대로 있다. 즉, 데이터가 코드보다 더 오래 산다.

데이터를 새로운 스키마로 다시 기록하는 작업은 가능하지만 대용량 데이터셋 대상으로는 비용이 커서 추천하지 않는다. RDB는 기존 데이터를 다시 기록하기보다 null을 기본값으로 갖는 새로운 칼럼을 추가하는 간단한 스키마 변경을 허용한다.

### 1-2) 보관 저장소

백업 목적이나 데이터 웨어하우스 적재를 위해 데이터베이스 스냅샷을 수시로 만드는 경우 보통 최신 스키마를 사용해 부호화한다. 어차피 데이터를 복사하기 때문에 일관되게 부호화하는 편이 낫다. 데이터 덤프는 한 번에 기록하고 이후에는 변하지 않으므로 아브로 객체 컨테이너 파일과 같은 형식이 적합하다.

## 2) 서비스를 통한 데이터플로: REST와 RPC

네트워크 통신시에 통신을 배치하는 몇 가지 방법이 있다. 일반적으로 클라이언트, 서버로 두 역할을 배치한다. 서버는 네트워크를 통해 API를 공개하고 클라이언트는 이 API로 요청을 만들어 서버에 연결할 수 있다. 서버가 공개한 API를 서비스라고 한다.

서버 자체가 다른 서비스의 클라이언트일 수 있다. 이런 접근 방식은 대용량 애플리케이션의 기능 영역을 소규모 서비스로 나누는데 사용한다. 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비스에 요청을 보낸다. 이런 개발 방식을 서비스 지향 설계(service-oriented architecture, SOA)라고 부르며 이를 더욱 개선해 마이크로서비스 설계(microservices architecture)란 이름으로 재탄생했다.

서비스 지향 및 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것이다. 각 서비스는 한 팀이 소유해야 하고 다른 팀과의 조정 없이 서로 서비스의 새로운 버전을 출시할 수 있다. 즉, **서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야 한다.**

### 2-1) 웹 서비스

웹 서비스에는 대중적인 두 가지 방법인 REST와 SOAP가 있다.

- REST
    - HTTP의 원칙을 토대로 한 설계 철학이다.
    - REST는 간단한 데이터 타입을 강조하며 URL을 사용해 리소를 식별한다.
- SOAP
    - 네트워크 API 요청을 위한 XML 기반 프로토콜이다.
    - SOAP는 HTTP에서 가장 일반적으로 사용되지만 HTTP와 독립적이며 HTTP 기능을 사용하지 않는다.

### 2-2) 원격 프로시저 호출(RPC) 문제

웹 서비스는 네트워크 상에서 API 요청을 하기 위한 여러 기술 중 가장 최신 형상일 뿐이다.

웹 서비스는 원격 프로시저 호출(remote procedure call, RPC)의 아이디어를 기반으로 한다.

- RPC
    - 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용하게 해준다.
- RPC 단점
    - 실제 로컬 함수 호출은 예측이 가능하지만 네트워크 문제는 예측이 어렵다. RPC는 프로그래밍 언어 내 로컬 객체처럼 보이게끔하는게 단점이자 장점이다.

### 2-3) RPC의 현재 방향

단점이 있어도 RPC는 사라지지 않았다. 차세대 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 더욱 분명히 한다. 실패할지도 모를 비동기 작업을 캡슐화하기 위해 퓨처를 사용한다. gPRC는 하나의 요청과 하나의 응답뿐만 아니라 시간에 따른 일련의 요청과 응답으로 구성된 스트림을 지원한다.

### 2-4) 데이터 부호화와 RPC의 발전

발전성이 있으려면 RPC 클라이언트와 서버를 독립적으로 변경하고 배포할 수 있어야 한다. RPC는 종종 조직 경계를 넘나드는 통신에 사용되어 서비스 호환성 유지를 어렵게한다. 서비스 제공자는 보통 클라이언트를 제어할 수 없기 때문에 호환성은 오랜 시간 동안 유지해야 한다.

## 3) 메시지 전달 데이터플로

메시지 브로커를 사용하는 방식은 직접 RPC를 사용하는 방식과 비교했을 때 장점이 있다.

- 수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 때문에 시스템 안정성이 향상된다.
- 죽었던 프로세스에 메세지를 다시 전달할 수 있기 때문에 메시지 유실 방지가 가능하다.
- 송신자가 수신자의 IP 주소나 포트 번호를 알 필요가 없다.
- 하나의 메시지를 여러 수신자로 전송할 수 있다.
- 논리적으로는 송신자는 수신자와 분리 된다.

### 3-1) 메시지 브로커

메시지 브로커는 보통 특정 데이터 모델을 강요하지 않는다. 메시지는 일부 메타데이터를 가진 바이트열이므로 모든 부호화 형식을 사용할 수 있다. 부호화가 상하위 호환성을 모두 가진다면 메시지 브로커에서 게시자와 소비자를 독립적으로 변경해 임의 순서로 배포할 수 있는 유연성을 얻게 된다.

### 3-2) 분산 액터 프레임워크

액터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다. 스레드, 교착 상태를 직접 처리하는 대신 로직이 액터에 캡슐홛괸다. 액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른 액터와 통신한다. 각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없다.
