# 04. 부호화와 발전
- 어플리케이션은 필연적으로 시간이 지남에 따라 변화함
- 이러한 변화로 인해 데이터 타입이나 스키마가 변경될 때는 애플리케이션 코드 수정이 필요함
- 하지만, 대규모 환경에서는 즉시 반영하기 어려움
    - 순차적인 업그레이드(롤링 배포)를 사용하면 각 노드간 버전 불일치가 일시적으로 발생할 수 있음
    - 클라이언트 측은 사용자의 환경에 따라 버전이 다를 수 있음
- 따라서, 원활한 시스템 운영을 위해서는 데이터 타입이나 스키마에 대한 양방향 호환성을 유지해야 함
    - **`하위 호환성`**: 새 버전 코드가 예전 버전의 데이터를 읽을 수 있음
    - **`상위 호환성`**: 예전 버전 코드가 새 버전이 기록한 데이터를 읽을 수 있음. 추가된 정보를 무시할 수 있어야 해서 다루기 더 어려움

## 데이터 부호화 형식
- 데이터 전송하거나 쓰기 위해 바이트 형태로 변환하는 과정을 **`부호화(Encoding)`** 라고 함
    - 부호화: 메모리 객체 → 바이트
    - 복호화: 바이트 → 메모리 객체
- 언어별 내장 부호화는 문제점이 많음
    - 특정 언어에 종속적이라 다른 언어 간 호환이 어려움
    - 임의 코드 실행과 같은 보안 취약점이 발생할 수 있음
    - 호환성 유지에 취약하고 성능도 떨어짐

### JSON과 XML, 이진 변형
- 다양한 언어 간 상호 호환성을 지원하지만, 문제점이 존재함
    - 데이터 타입이 명확하지 않아 숫자 처리의 모호성이 존재함
    - 이진 데이터를 지원하지 않아 데이터 크기가 증가함
- 이진 부호화 방식은 JSON보다 효율적인 공간 사용을 제공하지만, 사람이 읽기에는 어려움(가독성 저하, 디버깅 불편함)
    - **메시지 팩(MessagePack)**: JSON을 이진으로 압축한 방식으로, 데이터 크기를 줄임
        - 이러한, 공간 절약, 파싱 속도 향상 같은 이점이 가독성을 해칠만큼 가치가 있는지는 확실하지 않음
        
        ![CleanShot 2025-04-20 at 22 00 08@2x](https://github.com/user-attachments/assets/0ad4e5cd-3ab1-4eb6-b637-60258423a6c7)
        
### 스리프트(Thrift)와 프로토콜 버퍼(Protobuf)
- 스리프트(페이스북)와 프로토콜 버퍼(구글)는 이진 부호화를 위한 라이브러리로, 명확한 스키마 정의가 필요함
    - 스키마를 통해 다양한 언어에서 클래스를 생성할 수 있음
    - 필드 이름 대신 필드 태그 번호를 사용하여 데이터 크기를 줄임
    - 스키마 변화에도 유연하게 대처 가능함
   
       ![CleanShot 2025-04-20 at 22 00 34@2x](https://github.com/user-attachments/assets/e79ca2df-7413-4e82-8a66-1c41aa3bc39e)
      
- 스키마는 시간이 지나며 필연적으로 변화함. 이를 **`스키마 진화/발전(Schema Evolution)`** 이라고 함

### 스리프트와 프로토콜 버퍼의 스키마 발전
- 필드 태그
    - 새 필드 추가 시 새 태그 번호를 부여해 기존 버전에서 무시할 수 있게 함
    - 필드 추가 시 기본값이나 optional로 지정해야 호환성 유지가 가능함
    - 필드 삭제 시 optional 필드만 가능함
- 데이터 타입 변화
    - 타입 변경은 가능하지만 데이터 정확성을 잃을 수 있음(예: 32비트 → 64비트)
    - 프로토콜 버퍼는 배열 타입 대신 반복되는 필드를(repeated)를 사용하여 유연성을 제공함
    - 스리프트는 중첩된 목록을 지원하나, 단일 값에서 다중 값으로의 변환이 제한됨

### 아파치 아브로(Avro)
- 하둡에서 사용하기 위해 개발된 부호화 형식으로, 스키마가 필수적임
- 필드 이름이나 타입을 데이터에 기록하지 않고, 스키마를 참조해 데이터를 파싱함
- 쓰기 스키마와 읽기 스키마
    - **`쓰기 스키마`** : 데이터를 부호화할 때 사용하는 스키마
    - **`읽기 스키마`** : 복호화 시 사용하는 스키마 (애플리케이션 코드가 의존함)
    - 두 스키마가 정확히 같지 않아도, 호환 가능한 수준이면 사용 가능함
- 아브로의 스키마 발전 규칙
    - 호환성 유지 위해 기본값이 있는 필드만 추가/삭제 가능
    - 널(null)을 허용할 때 유니온(union) 타입 사용 필요

### 쓰기 스키마 식별 방법
- 대용량 파일: 파일 시작 부분에 쓰기 스키마 포함
- 개별 레코드(DB): 버전 번호를 기록하고, 데이터베이스에서 스키마 버전을 관리함
- 네트워크 연결: 스키마 버전을 합의 후 통신

### 동적 스키마 생성과 코드 생성
- 아브로는 동적 스키마 생성과 선택적 코드 생성을 지원해 변화에 유연함

### 스키마의 장점
- 필드 이름을 생략해 데이터 크기 감소
- 자동화된 문서화와 호환성 검증 가능
- 정적 언어의 타입 체크에 유리

## 데이터플로 모드
- 데이터 전달 방법은 다양하며 각 방식별 특징과 주의점을 이해해야 함

### 데이터베이스를 통한 데이터 플로
- 버전이 다른 애플리케이션 간 데이터 유실을 방지하기 위해 주의 필요
- 장기간 데이터 보관 시 일관된 부호화 방식이 중요함
    
    ![CleanShot 2025-04-20 at 22 01 24@2x](https://github.com/user-attachments/assets/b2e77997-d43b-4c20-8cb1-19a84b99a256)
    
### 서비스를 통한 데이터플로
- **REST와 SOAP**
    - REST: HTTP 기능 활용
    - SOAP: XML 기반으로 HTTP 기능은 제한적
- 원격 프로시저 호출(RPC)의 문제
    - 원격 호출과 로컬 호출의 차이로 실패 관리가 필요함
    - 타임아웃, 지연시간의 변화 등 네트워크 문제 대책 필요함

### 메시지 기반 데이터플로
- 메시지 브로커는 RPC보다 여러 장점이 있음
    - 시스템 안정성 및 메시지 재전송으로 데이터 유실 방지
    - 메시지를 다수의 수신자에게 전달 가능함
    - 송신자와 수신자를 논리적으로 분리할 수 있음
- 메시지 브로커 예시
    - 래빗MQ, 카프카 등 오픈소스 브로커의 사용 증가
    - 브로커가 큐(Queue)나 토픽(Topic)을 통해 메시지를 관리하고 전달함
- 분산 액터 프레임워크
    - 액터 모델은 비동기 메시지로 상호작용하며 동시성을 제공함
        - 독립적인 로컬 상태 유지
        - 액터 간 메시지 기반 비동기 통신

### 정리
- 데이터 구조를 네트워크나 디스크 상의 바이트열로 변환하는 다양한 방법 소개 및 설명함
- 이런 부호화의 세부 사항은 효율성뿐만 아니라 애플리케이션의 아키텍처와 배포의 선택 사항에 영향을 줌
- 어플리케이션 변화에 따른 스키마 발전으로 인해 어플리케이션은 상위/하위 호환성을 제공하는 방식으로 부호화해야함
- 다양한 데이터 부호화 형식과 호환성 속성
    - 프로그래밍 언어별 내장 부호화
    - JSON, XML, CSV 와 같은 널리 사용되는 형식. 가독성은 좋으나 데이터 낭비가 있으며, 데이터 타입에 대한 모호성이 존재하기 때문에 주의가 필요. 선택적 스키마
    - 스리프트, 프로토콜 버퍼, 아브로와 같은 이진 스키마 기반 형석은 데이터 효율적이며 상위/하위 호환성을 지원함. 사람이 읽기 위해서는 반드시 복호화해야함
- 데이터 부호화의 중요성에 대한 시나리오
    - 데이터 베이스 읽기/쓰기
    - 클라이언트/서버 간의 데이터 통신
    - 메시지 기반의 비동기 통신
