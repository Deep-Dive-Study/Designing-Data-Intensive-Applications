# 09. 일관성과 합의
- 분산 시스템에서는 많은 것들이 잘못될 수 있고, 이를 해결하기 가장 간단한 방법은 사용자에게 오류를 표시를 하는 것임
- 이러한 방식을 허용하기 어렵다면, `결함을 견뎌낼(tolerating)` 방법을 찾아야함(내결함성)
  - **`내부 구성 요소에 결함이 있더라도 서비스는 올바르게 동작하게 할 방법`**

- 내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 트랜잭션과 같이 `애플리케이션이 분산 시스템에 있는 문제를 무시할 수 있게 만들어주는 범용 추상화`를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것임
  - 이러한 범용 추상화 중에 분산 시스템에서 가장 중요한 추상화 중 하나는 **`합의(모든 노드가 어떤 것에 동의하게 만드는 것)`** 임
 
## 일관성 보장
- 복제 데이터베이스(분산 데이터베이스)에서는 노드들간의 동기화가 지연되기 때문에 불일치가 발생할 수 있음(복제 지연)
- 그래서, 복제 데이터베이스는 대부분 최소한 **`최종적 일관성`** 을 제공함(보장)
  - 데이터베이스에 쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환하게 됨.
  - 즉, 불일치는 일시적이며 결국 일관성을 갖추게 될 것임을 보장(수렴)

- 그러나 이것은 언제 복제본이 일관적인 상태로 수렴될지에 대해서는 알 수 없는, 매우 약한 형태의 보장임 
- 다만, 강한 보장을 제공하는 시스템은 성능이 나쁘거나 약한 보장을 제공하는 시스템보다 내결함성이 약할 수 있음

- 분산 일관성 모델과 트랜잭션 격리 수준 계층에는 비슷한 점이 있음
- 하지만, 겹치는 부분이 있어 보이더라도, 이들은 대개 독립적인 관심사임
  - 트랜잭션 격리는 주로 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하기 위한 것
  - 분산 일관성은 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관한 것

- 그러나 사실 이 영역들은 깊게 연결돼 있음
  - 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 `선형성(linearizability)`
  - 분산 시스템에서의 `이벤트 순서화` 문제, 특히 인과성과 전체 순서화와 관련된 문제
  - 분산 트랜잭션을 `원자적으로 커밋`하는 방법

## 선형성
- **`선형성(강한 일관성, strong consistency)`** 은, 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것
  - 이런 보장이 있다면 현실에는 여러 복제본이 있더라도 애플리케이션이 거기에 신경 쓸 필요가 없게됨
- 선형성 시스템은 클라이언트가 쓰기를 성공적으로 완료하자마자 그 데이터베이스를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있음
  - 즉, 선형선은 **최신성 보장(recency guarantee)** 함(읽힌 값이 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장)

- 선형성 위반 예(이전 결과를 반환)

  ![CleanShot 2025-06-08 at 01 51 31](https://github.com/user-attachments/assets/866bca03-f4ef-4e50-9fc8-6efc6d396544)

### 시스템에 선형성을 부여하는 것은 무엇인가?
- 선형성 데이터베이스에서 동시에 같은 키(x)를 읽고 쓰는 세 클라이언트 관점의 예시
  - 분산 시스템에서 키는 레지스터(로우, 문서, 키, 등) 

  ![CleanShot 2025-06-08 at 01 53 31](https://github.com/user-attachments/assets/2dd325f5-47ff-451e-a382-387783475c82)

- 선형성 시스템에서 우리는 x의 값이 원자적으로 0에서 1로 바뀌는(쓰기 연산의 시작과 끝 사이의) 어떤 시점이 있어야한다고 생각함
  - 즉, 한 클라이언트의 읽기가 새로운 값 1을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야함 (쓰기 연산이 아직 완료되지 않았더라도)

  ![CleanShot 2025-06-08 at 01 56 35](https://github.com/user-attachments/assets/23ef74b9-3afd-446a-ba6f-6efa82d054bd)

- 선형성의 요구사항은 `연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 결코 뒤로 가서는 안된다`는 것임

  ![CleanShot 2025-06-08 at 01 59 24](https://github.com/user-attachments/assets/cd7bc3f6-7c8b-44ac-95a6-d6d60146ea9c)

- 모든 요청과 응답 시점을 기록하고 그것들이 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트 할 수 있음

#### 선형성 대 직렬성
- 선형성은 직렬성은 모두 `순차적인 순서로 배열될 수 있는` 뭔가를 의미하기 때문에 혼동하기 쉬우나 이들은 다른 보장임을 구별해야함

- `직렬성`
  - 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션의 격리 속성
  - 트랜잭션들이 `어떤 순서에 따라` 실행되는 것처럼 동작하도록 보장해줌
  - 그 순서가 트랜잭션들이 실제 실행되는 순서와 달라도 상관 없음

- `선형성`
  - 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장
  - 연산을 트랜잭션으로 묶지 않아서 **충돌 구체화** 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐같은 문제를 막지 못함

- 데이터베이스는 직렬성과 선형성을 모두 제공할 수 있으며, 이런 조합을 `엄격한 직렬성(strict serializability)` 또는 `강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)` 이라고 함
  - 2단계 잠금(2PL)이나 실제적인 직렬 실행을 기반으로 한 직렬성 구현은 보통 선형적임
  - 그러나 직렬성 스냅숏 격리(SSI)는 선형적이지 않음
    - 직렬성 스냅숏 격리는 설계상 읽는 쪽과 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽기 때문에
    - 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고, 따라서 스냅숏에서 읽으면 선형적이지 않게 됨

### 선형성에 기대기
- 선형성이 중요하게 요구되는 상황 예시

- **`잠금과 리더 선출`**
  - 단일 리더 복제 시스템은 리더가 진짜로 하나만 존재하도록 보장해야 함
  - 리더를 선출하는 방법은 잠금을 사용하는 것이고, 이 `잠금은 어떻게 구현하든지 선형적이어야 함`
  - 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼나 etcd 같은 코디네이션 서비스가 사용됨
    - 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현하고 있음
    - 아파치 큐레이터 같은 라이브러리가 주키퍼 위에 고수준 레시피를 제공해서 도움을 줌
    - 이런 코디네이션 작업에는 선형성 저장소 서비스가 기초적인 기반이 됨
  - 분산 잠금은 오라클 리얼 애플리케이션 클러스터(RAC) 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용되기도 함
    - RAC는 여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근 → 디스크 페이지마다 잠금을 사용

- **`제약 조건과 유일성 보장`**
  - 사용자명이나 이메일 주소와 같이 사용자 한 명을 `유일하게 식별할 수 있어야하는 경우`
    - 잠금과 비슷한 상황(사용자가 선택한 사용자명에 잠금을 획득하는 상황)
    - 연산은 원자적 compare-and-set과도 매우 비슷
  - 은행 계좌 잔고가 결코 음수가 되지 않게 하기, 등 모든 이런 제약 조건들은 모드 노드가 동의하는 하나의 최신 값이 있기를 요구함

- **`채널 간 타이밍 의존성`**

  ![CleanShot 2025-06-08 at 15 09 42](https://github.com/user-attachments/assets/8ef5cbdc-c91f-4b5c-b700-ee6ab62ae2c2)

  - 사용자가 사진을 올리고 백그라운드 프로세스가 사진을 빨리 내려받을 수 있도록 저해상도로 바꾸는(썸네일) 웹사이트
    - 파일 저장 서비스가 선형적이지 않다면 경쟁 조건의 위험이 있음
    - 메시지 큐가 저장 서비스 내부의 복제보다 빠를 수도 있음
    - 이런 경우 크기 변경 모듈이 이미지를 읽으면 그 이미지의 과거 버전을 보거나 아무것도 보지 못할 수도 있게 됨
  - 웹 서버와 크기 변경 모듈 사이에 두 가지 다른 통신 채널, 파일 저장소와 메시지 큐가 있기 때문에 발생함
    - `선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있음`

### 선형성 시스템 구현하기
- 선형성은 근본적으로 데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적이라는 것을 의미함
- 이를 구현하기 가장 쉬운 방법은 정말로 복제본을 하나로 두는 것
- 하지만, 그렇게 되면 시스템이 내결함성을 지닐 수 없게 됨
- 그러면, 복제를 통해 시스템이 내결함성을 지니도록 하면서도 이를 선형적으로 만들 수 있는가?

- **`복제 모델별 가능성 비교`**
  - `단일 리더 복제(선형적이 될 가능성 있음)`
    - 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있음
    - 리더가 아닌 노드가 자신이 리더라고 생각해서 계속해서 요청을 처리하면 선형성을 위반하기 쉬움
    - 비동기 복제를 사용하면 장애 복구를 할 때 커밋된 쓰기가 손실될 수 있는데, 이는 지속성과 선형성을 모두 위반하는 것

  - `합의 알고리즘(선형적)`
    - 단일 리더 복제를 닮았지만, 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단이 포함됨
    - 주키퍼와 etcd가 이렇게 동작함

  - `다중 리더 복제(비선형적)`
    - 여러 노드에서 동시에 쓰기를 처리하고 그 내용을 비동기로 다른 노드에 복제하므로 일반적으로 비선형적임
    - 다중 리더 복제 시스템은 충돌 해소가 필요한 충돌 쓰기를 만들 수 있음

  - `리더 없는 복제(아마도 비선형적)`
    - 정족수 읽기와 쓰기를 요구함으로써 “엄격한 일관성”을 달성할 수 있다고 주장하지만 완전한 진실은 아님
    - 일 기준 시계를 기반으로 한 “최종 쓰기 승리” 충돌 해소 방법은 거의 확실히 비선형적임
    - 시계 타임스탬프는 시계 스큐 때문에 이벤트의 실제 순서와의 일치를 보장할 수 없음
    - 느슨한 정족수도 선형성의 가능성을 망침

### 선형성과 정족수
- 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보일 수 있으나, 아래 예시 처럼 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있음

  ![CleanShot 2025-06-08 at 15 19 02](https://github.com/user-attachments/assets/8d4353c0-6f5d-477d-9d4e-55240e298da7)

- 정족수 조건이 만족(w + r > n)됨에도 이 실행은 선형적이지 않음
  - 클라이언트 B는 두 노드로 구성된 다른 정족수로부터 읽어서 두 노드 모두에서 예전 값 0을 봄
  
- 성능이 떨어지는 비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는 게 가능은 함
  - 읽기를 실행하는 클라이언트는 결과를 반환하기 전에 읽기 복구를 동기식으로 수행
  - 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태 읽기를 수행
  - 그러나 리악은 성능상 불이익 때문에 동기식 읽기 복구를 수행 X
    - 카산드라는 정족수 읽기를 할 때 읽기 복구가 완료되기를 기다리지만 최종 쓰기 승리 충돌 해소 방법을 쓰기 때문에 같은 키에 여러 쓰기를 동시에 실행하면 선형성을 잃게 됨

- 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 가장 안전함

### 선형성의 비용
- 각 데이터센터의 내부 네트워크는 동작하고 클라이언트는 데이터센터에 접근할 수 있지만 데이터센터끼리는 서로 연결할 수 없는 사례
  
  ![CleanShot 2025-06-08 at 15 21 29](https://github.com/user-attachments/assets/b803a826-3347-406c-b0fe-b0ffb384eb8f)

    - 다중 리더 데이터베이스에서 각 데이터센터는 계속 정상 동작할 수 있음
      - 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되므로 쓰기는 그냥 큐에 쌓였다가 네트워크 연결이 복구되면 전달됨
    
    - 단일 리더 설정에서 데이터센터 사이의 네트워크가 끊기면 팔로워 데이터센터로 접속한 클라이언트들은 리더로 연결할 수 없으므로 아무것도 쓸 수 없고 선형적 읽기도 할 수 없음
      - 팔로워로부터 읽을 수는 있지만 비선형적임
      - 애플리케이션에서 선형성 읽기와 쓰기를 요구한다면 네트워크가 끊길 때 리더와 연결할 수 없는 데이터센터에서는 애플리케이션을 사용할 수 없음
      - 클라이언트가 리더 데이터센터로 직접 접속할 수 없다면 해당 클라이언트는 네트워크 링크가 복구될 때까지 중단을 경험하게됨

### CAP 정리
<img width="309" alt="다운로드 (6)" src="https://github.com/user-attachments/assets/a71ef3f6-9d00-4412-9963-4309640b52d6" /> (참고 : https://blog.voidmainvoid.net/230#google_vignette)

- CAP는 각각 **`일관성(Consistency)`**, **`가용성(Availability)`**, **`분단 내성(Partition tolerance)`** 이 세가지를 모두 동시에 만족할 수 없음을 증명하는 이론
  - 분단 내성같은 경우는 결함이기 때문에 별도로 선택하기 어려움, 즉, 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 이해하는 게 좋음
  - 애플리케이션에서 `선형성을 요구하고` 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 요청을 처리할 수 없음(가용성 X)
  - 애플리케이션에서 선형성을 요구하지 않는다면 이 애플리케이션은 네트워크 문제에 직면해도 가용한 상태를 유지하지만 그 동작은 선형적이지 않음
  - 즉, 선형성과 가용성을 동시에 만족하는 분산 데이터베이스는 있을 수 없음

- 공식적으로 정의된 CAP 정리는 매우 범위가 좁고 네트워크 지연, 죽은 노드나 다른 트레이드오프에 대한 어떤 것도 고려하지 않기 때문에 역사적인 영향력은 있지만 시스템을 설계할 때는 실용적인 가치가 많지 않음

### 선형성과 네트워크 지연
- 선형성은 유용한 보장이지만 현실에서 실제로 선형적인 시스템은 많지 않음
  - **`선형성은 느림`**
  - 여러 분산 데이터베이스는 성능을 향상시키기 위해서 선형성 보장을 제공하기 않기를 택함
  - 심지어 최신 다중코어 CPU의 램(RAM)조차 선형적이지 않음
    - 모든 CPU 코어가 저마다 메모리 캐시와 저장 버퍼를 갖기 때문에
    - 메모리 접근은 기본적으로 캐시로 먼저 가고 변경은 메인 메모리에 비동기로 기록함
    - 이런 특성은 성능에 필수적, 그러나 데이터 복사본이 여러 개 생기고 비동기로 갱신되므로 선형성은 손실

- 즉, 성능과 선형성은 트레이드오프가 있는 상황, 많은 어플리케이션에서는 선형성을 지키는 것보다 성능을 택하는게 나은 상황이 많기 때문에
  - 네트워크 지연과 연관이 있지만, 내결함성 때문은 아님

## 순서화 보장
- **`선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보이게 함`**
- 이러한 정의는 연산들이 어떤 잘 정의된 `순서대로 실행` 된다는 것을 암시함
- 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있음이 보여짐
  - 단일 리더 복제에서 리더의 주 목적은 복제 로그에서 쓰기의 순서, 즉 팔로워가 쓰기를 적용하는 순서를 결정함
  - 직렬성은 트랜잭션들이 마치 어떤 일련의 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것과 관련되어 있음
  - 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서(순서)를 부여하려는 시도임

### 순서화와 인과성
- **`순서화는 인과성을 보존하는 데 도움을 줌`**
  - 인과성에 문제가 생기면 원인과 결과에 관한 직관을 위반하기 때문에 혼란스럽게 됨
    - 예를 들어, 질문과 답변의 관계가 뒤바뀌는 경우(이러한 관계의 경우, 질문과 답변 사이에 인과적 의존성이 있다고 함)
  - 리더 사이의 복제에서 네트워크 지연 때문에 어떤 쓰기가 다른 쓰기를 “추월”할 수 있음
    - 인과성은 로우가 갱신되기 전에 먼저 생성돼야 함을 의미
  - 이전 발생(happened before) 관계는 인과성을 표현하는 또 다른 방법
    - A가 B보다 먼저 실행됐다면 B가 A에 대해 알거나 A를 기반으로 하거나 A에 의존할지도 모름
    - A와 B가 동시적이라면 그들 사이에는 인과적 연결이 없는 것
  - 트랜잭션용 스냅숏 격리의 맥락에서 트랜잭션은 일관된 스냅숏으로부터 읽음
    - 여기에서 “일관적”이란 `인과성에 일관적(consistent with causality)`이라는 의미
    - 한 시점에서 데이터베이스를 보면 인과성 측면에서 그 시점 전에 실행된 모든 연산의 효과는 볼 수 있지만 나중에 실행된 연산의 효과는 볼 수 없음
  - 트랜잭션들 사이의 쓰기 스큐 예제는 인과적 의존성을 보여줌
    - 호출 대기에서 빠지는 동작은 현재 누가 호출 대기 중인지 관찰하는 것에 인과적으로 의존함
    - 직렬성 스냅숏 격리는 트랜잭션 사이의 인과적 의존성을 추적함으로써 쓰기 스큐를 검출함

- `인과성은 이벤트에 순서를 부과함`(결과가 나타나기 전에 원인이 먼저 발생)
- 인과적으로 의존하는 연산의 연쇄는 시스템에서 인과적 순서, 즉 `무엇이 무엇보다 먼저 일어났는가를 정의`함
- 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 `인과적으로 일관적(causally consistent)`이라고 함
  - 스냅숏 격리는 인과적 일관성을 제공
  - 어떤 데이터를 보았다면 그보다 앞선 데이터는 어떤 것이라도 볼 수 있어야함

### 인과적 순서가 전체 순서는 아니다
- `전체 순서(total order)`는 어떤 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 어떤 것이 더 크고 어떤 것이 더 작은지 말할 수 있음
- 수학적 집합은 항상 전체 순서를 정할 수 있는 것이 아님
  - 어느 것도 다른 것의 부분 집합이 아니므로 이것들은 비교 불가(incomparable)임
  - 수학적 집합은 부분적으로 순서가 정해짐(partially ordered)
    - 어떤 경우에는 한 집합이 다른 집합보다 크지만 다른 경우에는 비교 불가능

- `선형성`
  - 연산의 전체 순서를 정할 수 있음
  - 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있음

- `인과성`
  - 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만 이들이 동시에 실행됐다면 비교할 수 없음
  - 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻

- 정의에 따르면 선형적 데이터스토어에는 동시적 연산이 없음
  - 하나의 타임라인이 있고, 모든 연산은 그 타임라인을 따라서 전체 순서가 정해져야 함

- 동시성은 타임라인이 갈라졌다 다시 합쳐지는 것을 의미
  - 깃의 버전 히스토리는 인과적 의존성 그래프와 매우 유사힘

### 선형성은 인과적 일관성보다 강하다
- **`선형성은 인과성을 내포함`** . 즉, 어떤 시스템이든지 선형적이라면 인과성도 올바르게 유지 가능 함
- 그러나 시스템을 선형적으로 만들면, 특히 네트워크 지연이 크면 성능과 가용성에 해가 될 수 있음
- 시스템은 선형적으로 만드는 성능 손해를 유발하지 않고도 인과적 일관성을 만족시킬 수 있기는 함
  - 인과적 일관성은 네트워크 지연 때문에 느려지지 않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강한 것

- 많은 경우에 선형성이 필요한 것처럼 보이는 시스템에 사실 진짜로 필요한 것은 인과적 일관성이며 이는 더 효율적으로 구현될 수 있음

### 인과적 의존성 담기
- **인과성을 유지하기 위해 어떤 연산이 다른 연산보다 먼저 실행됐는지 알아야 함**
  - 부분 순서 → 동시에 실행되는 연산은 어떤 순서로든 처리될 수 있지만 한 연산이 다른 연산보다 먼저 실행됐다면 모든 복제 서버에서 그 순서로 처리돼야 함

- 어떤 연산이 다른 연산보다 먼저 실행됐는지 결정하는 기법
  - 단일 키뿐만 아니라 전체 데이터베이스에 걸친 인과적 의존성을 추적해야 함
  - 이를 위해 버전 벡터(version vector)를 일반화할 수 있음
  - 인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 함
    - 커밋 시점에 데이터베이스는 읽은 데이터의 버전이 여전히 최신인지 확인(데이터베이스는 어떤 데이터를 어떤 트랜잭션이 읽었는지 추적) 

### 일련번호 순서화
- **`인과성을 추적하기 위해 일련번호나 타임스탬프를 통해 이벤트의 순서를 정할 수 있음`**
- 이 때 타임스탬프는 물리적 시계(신뢰성 없는 시계 문제가 있음)가 아니라 논리적 시계(일련번호 생성 알고리즘, 보통 카운터)에서 얻어도 됨
- 이렇게 생성된 일련번호는 전체 순서를 보장하기 때문에 인과성에 일관적인 전체 순서대로 일련번호 생성이 가능함
  - 단일 리더 복제에서는 연산마다 카운터를 증가시켜 복제 로그 각 연산에 단조 증가하는 일련번호를 할당하기만 하면 됨

### 비인과적 일련번호 생성기
- 다중 리더, 리더 없는 데이터베이스, 혹은 파티셔닝인 경우에는 다양한 방법이 사용됨
  - 각 노드마다 자신만의 일련번호 집합을 생성(ex. 한 노드는 짝수, 다른 노드는 홀수만 생성)
  - 각 연산에 일 기준 시계(물리적 시계)에서 얻은 타임스탬프를 붙임(해상도가 충분히 높다면 연산의 전체 순서를 정하는데 충분할 수 있음)
  - 일련번호 블럭을 미리 할당(ex. A 노드는 1~1000 까지, B 노드는 1001~2000 까지의 블럭)

- 이 방법들은 단일 리더에서 모든 연산을 처리하는 것보다 확장성이 좋으나, 이러한 일련번호는 인과성에 일관적이지 못한 문제가 있음
  - 각 노드는 초당 연산 수가 다를 수 있음
  - 물리적 시계에서 얻은 타임스탬프는 시계 스큐에 종속적이어서 인과성에 일관적이지 않게 될 수 있음
  - 블럭 할당자의 경우 한 연산이 1001~2000 사이 구간의 일련번호를 받고, 인과적으로 나중에 실행되는 연산이 1~1000 사이 구간의 일련번호를 받게 될 가능성이 있음(일련번호가 일관성을 잃어버림)

- 즉, **위에 3가지 방법은 인과적이지는 못함**

### 램포트 타임스탬프
- `인과성에 일관적인 일련번호를 생성하는 방법`

  ![CleanShot 2025-06-08 at 15 44 12](https://github.com/user-attachments/assets/0bb1f114-9dfd-49df-b96d-b773fbf01bde)

    - 각 노드는 고유 식별자를 갖고 각 노드는 처리한 연산 개수를 카운터로 유지
    - 램포트 타임스탬프는 그냥(카운터, 노드ID)의 쌍임
    - 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최대값을 추적하고 모든 요청에 그 최대값을 포함시켜 전달. 노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운터를 그 최대값으로 증가시킴
    - 두 노드는 때때로 카운터 값이 같을 수 있지만 타임스탬프에 노드 ID포함하여 각 스탬프는 유일하게됨
      - 타임스탬프가 같으면 카운터값이 큰 것이 크다고 판단하고, 카운터까지 같으면 노드 ID가 큰 것이 타임스탬프가 크다고 판단

- `램포트 타임스탬프는 물리적 일 기준 시계와 관련이 없으면서도 전체 순서화를 제공함`
- 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산이 다른 연산에 인과적으로 의존하는지 구별할 수 있지만 램포트 타임스탬프는 항상 전체 순서화를 강제함
  - 따라서, 램포트 타임스탬프의 경우에는 두 연산이 동시적인지 또는 인과적으로 의존성이 있는지를 알 수 없음
  - 버전 벡터보다 좋은 점은 크기가 더 작다는 것

### 타임스탬프 순서화로 충분하지 않다
- 램포트 타임스탬프가 인과성에 일관적 연산의 전체 순서를 정의하지만, **분산 시스템의 여러 공통 문제 해결에는 아주 충분하지는 않음**
  - 사후에 성공하는 쪽을 결정하는데에 효과적이지만, 당장 결정해야 하는 경우에는 부족하기 떄문
  - 예시) 
    - 사용자명으로 사용자 계정을 유일하게 식별할 수 있도록 보장해야 하는 시스템인 경우
    - 두 사용자가 동시에 동일한 사용자명으로 계정을 생성하려고 하면 둘 중 한 명은 성공하고 다른 사람은 실패해야 함
    - 하지만, 다른 어떤 노드도 동시에 더 낮은 타임스탬프를 갖고 동일한 사용자명으로 계정 생성을 처리하는 중이 아니라고 확신하기 위해서는 다른 모든 노드가 무슨 작업을 하고 있는지 확인해야 함
    - 이는 노드 중 하나에 장애가 발생할 경우 시스템이 멈추게 되어 내결함성을 지키지 못하게 됨
    - 즉, 연산의 전체 순서는 모든 연산을 모은 후에 드러난 다는 것(연산이 수행되는 도중에는 순서를 알기 어려움)

### 전체 순서 브로드 캐스트
- 프로그램이 단일 CPU 코어에서만 실행되면 CPU에서 실행된 순서가 전체 순서이기 때문에 연산의 전체 순서를 정하기가 매우 쉬움
- 하지만 내결함성을 위해서는 분산 시스템을 이용해야 하기 떄문에 전체 순서가 동일하도록 합의하기 까다로움
- 단일 리더 복제에서는 한 노드를 리더로 선정하고 리더의 단일 CPU 코어에서 모든 연산을 차례대로 배열함으로써 연산의 전체 순서를 정할 수 있음
- 여기서 문제는 처리량이 단일 리더가 처리할 수준을 넘어설 때 시스템을 어떻게 확장할 것인가임
  - 혹은 리더에 장애가 발생했을 때 어떻게 장애 복구를 할 것인가

- 분산 시스템 분야에서 이 문제는 **`전체 순서 브로드캐스트(원자적 브로드캐스트)`**, 로 알려져 있음

- 전체 순서 브로드캐스트는 보통 노드 사이에 메시지 교환하는 프로토콜로 기술되며 비공식적으로 2가지 안전성 속성을 항상 만족해야 함
  - **`신뢰성 있는 전달`**
    - 어떤 메시지도 손실되지 않고, 한 노드에 전달이 됐다면 모든 노드에 동일하게 전달되어야 함

  - **`전체 순서가 정해진 전달`**
    - 메시지는 모든 노드에 같은 순서로 전달되어야 함 

### 전체 순서 브로드캐스트 사용하기
- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드 캐스트를 실제로 구현함
  
- 모든 메시지가 데이터베이스에 쓰기를 나타내고, 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지하게 됨(일시적 복제 지연 제외)
  - 이 원리를 **`상태 기계 복제`** 라고 함

- 전체 순서 브로드 캐스트의 중요한 측면은 **`메시지가 전달되는 시점에 그 순서가 고정된다는 것`** 임
  - 이미 메시지가 전달됐다면, 그 앞 순서에 새로운 메시지를 끼워넣을 수 없음

- 전체 순서 브로드 캐스트의 또다른 관점은 복제 로그, 트랜잭션 로그, 쓰기 전 로그와 같은 로그를 만드는 방법 중 하나라는 것임
  - 메시지 전달은 로그에 추가하는 것과 비슷함 

- 직렬성 트랜잭션이나 펜싱 토큰을 제공하는 잠금 서비스를 구현하는데도 사용 가능함

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
- 선형성 시스템(연산에 전체 순서 있음)과 전체 순서 브로드캐스트는 동일하지 않지만 밀접한 관계가 있음
- **`전체 순서 브로드캐스트는 비동기식이기 때문에 언제 메시지가 전달될지 보장되지 않지만, 선형성은 최신성 보장이기 떄문에 읽기가 최근에 쓰여진 값을 보는 것이 보장됨`**

- 전체 순서 브로드캐스트 구현을 기반으로 선형성 저장소를 만들 수도 있음
  - 예를 들어 사용자 계정을 유일하게 식별하도록 보장할 수 있는데, 이를 전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 구현할 수 있음
    - 1. 메시지를 로그에 추가해 점유하기 원하는 사용자명을 가리킴
    - 2. 로그를 읽고, 추가한 메시지가 되돌아오길 기다림
    - 3. 원하는 사용자명을 점유하려는 메시지가 있는지 확인
      - 3-1. 이 때 첫번째 메시지가 자신의 메시지라면 성공, 아니라면 어보트 시킴

- 로그는 모든 노드에게 같은 순서로 전달되므로 쓰기 충돌이 일어날 경우 첫번째 쓰기를 승자로 택하고 나머지를 어보트 시킴
  - 다중 객체 트랜잭션에도 비슷한 방법을 쓸 수 있음

- 다만, 이 절차는 선형성 쓰기는 보장하지만, 선형성 읽기는 보장되지 않음
  - 로그는 비동기적으로 갱신되기 떄문에 오래된 값이 읽힐 가능성이 있음(타임라인 일관성, 순차적 일관성)

- 읽기를 선형적으로 만들기 위해선 몇 가지 선택지가 존재함
  - 로그를 통해 순차 읽기를 할 수 있음
    - 로그에 메시지를 추가하고, 이 메시지가 돌아왓을 때 읽기를 수행함
    - 읽기를 위한 쓰기 메시지를 모든 노드에 전파하고, 여기까지 모든 노드가 동기화가 됐을 때 읽는다고 보면 됨(전체 순서가 보장되기 떄문에 가능한 방법)
    - etcd의 정족수 읽기와 유사한 방식

  - 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고, 그 위치까지 모든 항목이 전달되기를 기다린 후 읽기를 수행할 수 있음
    - 주키퍼의 sync() 연산 기반

  - 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽을 수 있음    

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기
- 반대로, 선형성 저장소를 기반으로 전체 순서 브로드캐스트 구현도 가능함
  - 정수를 저장하고 원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 가정(혹은 원자적 compare-and-set 연산)

    - 1. 전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지를 준비
    - 2. 선형성 정수로 increment-and-get 연산을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙임
    - 3. 메시지를 모든 노드에 보냄(손실되면 재전송)
    - 4. 수신하는 노드들은 일련번호 순서대로 메시지를 전달(동기화, 쓰기)

- 램포트 타임스탬프와 달리 선형성 레지스터를 증가시켜 얻은 숫자들은 틈이 없는 순열을 형성함
  - 어떤 노드가 메시지 4를 전달하고, 일련번호가 6인 메시지를 받았다면 메시지 6을 전달하기 전에 메시지 5를 기다려야 함
  - 램포트는 그렇지 않음(즉, 이것이 전체 순서 브로드캐스트와 타임스탬프 순서화의 핵심적인 차이점)

- 원자적 increment-and-get 연산이 지원되는 선형성 정수를 만드는 것은 단일 노드에 변수 하나로 처리하면 쉬우나 내결함성을 위해서는 이 방식을 사용할 수 없음

- 결국, **`이를 고민하다보면 합의 알고리즘에 도달하게됨`**

- 이는 우연적인 것이 아니고, **선형성 compare-and-set(increment-and-get) 레지스터와 전체 순서 브로드캐스트는 둘 다 합의와 동등하다고(equivalent to consensus) 증명됨**
  - 즉, **`이 문제들 중 하나를 해결할 수 있으면 다른 문제의 해결책으로 변환할 수 있음`**


## 분산 트랜잭션과 합의
	-	분산 환경에서는 여러 노드가 동일한 결정을 내려야 하는 상황이 자주 발생하며, 이때 모든 노드가 동일하게 동의하도록 만드는 것이 ’합의(consensus)’의 핵심임
	-	대표적인 예시: 리더 선출, 분산 트랜잭션의 커밋 처리

### 리더 선출과 합의
	-	리더 선출은 여러 노드 중 하나를 대표자로 뽑는 과정
	-	모든 노드는 동일한 리더를 인식해야 하며, 리더가 둘 이상이면 스플릿 브레인(split brain) 문제가 발생할 수 있음
	-	선출 시점과 선출된 리더가 전체 시스템에 일관되게 반영되어야 하며, 이 일관성을 위해 합의 알고리즘이 필요함

### 원자적 커밋 문제(Atomic Commit)
	-	여러 노드나 파티션에 걸친 트랜잭션이 모두 성공하거나 모두 실패해야 함
	-	일부만 성공하는 경우 데이터의 일관성 보장이 깨짐
	-	이 문제를 해결하기 위한 대표적인 기법이 2단계 커밋 프로토콜(2PC)

### 2단계 커밋(2PC)
	-	분산 트랜잭션에서 가장 널리 알려진 원자적 커밋 프로토콜
	-	두 단계로 모든 노드에 동기적으로 확인을 받아 트랜잭션을 커밋 또는 어보트 처리

### 기본 흐름
	1.	준비 단계 (Prepare phase)
	-	코디네이터가 각 참여자(노드)에게 “커밋 준비됐는가?” 요청
	-	참여자는 준비 완료시 “네(Yes)” 응답, 그렇지 않으면 “아니오(No)”
	2.	커밋 단계 (Commit phase)
	-	모든 노드가 “네”라고 응답한 경우 → 커밋
	-	하나라도 “아니오”인 경우 → 전체 어보트
	-	결정은 트랜잭션 로그에 기록되어 복구 가능하도록 함

### 약속(Promise)과 불가역성
	-	“준비됨(Yes)”이라고 응답한 노드는 커밋 가능하다는 약속을 한 것으로 간주
	-	코디네이터가 커밋 결정을 내린 이후에는 그 결정을 바꿀 수 없음

### 장애 상황
	-	코디네이터가 커밋 결정을 내린 후 죽는 경우, 일부 노드는 커밋 여부를 알 수 없는 상태(in doubt) 에 빠짐
	-	이 상태에서는 잠금이 해제되지 않고 교착 상태가 발생할 수 있음
	-	즉, 2PC는 블로킹 프로토콜임

### 3단계 커밋(3PC)
	-	2PC의 블로킹 문제를 해결하기 위해 제안된 논블로킹 커밋 프로토콜
	-	현실에서는 장애 감지를 완벽하게 수행할 수 없기 때문에 거의 사용되지 않음
	-	대신, 대부분의 시스템은 2PC를 사용하거나 2PC 자체를 회피

### 분산 트랜잭션의 현실
	-	분산 트랜잭션은 성능 저하와 운영 복잡성 때문에 현대 클라우드 서비스에서는 기피됨
	-	특히 이종 시스템 간 트랜잭션에서는 실패 시 전체 시스템에 영향을 줄 수 있는 위험이 큼

### 정확히 한 번 처리(Exactly-once semantics)
	-	메시지 큐와 데이터베이스가 동시에 원자적으로 처리되어야 보장 가능
	-	예: 메시지 처리 중 이메일을 보내는 경우, 실패/재시도 시 이메일 중복 전송 가능

### XA 트랜잭션
	-	다양한 DB, 메시지 브로커가 지원하는 이종 분산 트랜잭션 표준
	-	그러나 잠금 지속, 교착 상태, 장애 시 수동 복구 필요성 등으로 인해 운영 비용이 매우 큼

### 내결함성을 지닌 합의
	-	여러 노드가 하나의 결정에 동의해야 하는 것이 합의의 본질
	-	합의 알고리즘은 다음의 속성을 만족해야 함:
  	-	`균일한 동의(Agreement)`: 어떤 두 노드도 상반된 결정을 하지 않음
  	-	`무결성(Integrity)`: 하나의 노드가 두 번 결정하지 않음
  	-	`유효성(Validity)`: 결정된 값은 실제로 제안된 값이어야 함
  	-	`종료(Termination)`: 장애 없는 노드는 반드시 결정을 내릴 수 있어야 함

- 종료 보장을 위해서는 단순히 한 노드에 의존하는 구조(독재자 방식)로는 불충분하며, 다수의 합의가 필요

### 합의 알고리즘과 전체 순서 브로드캐스트
	-	Paxos, Raft, Zab, Viewstamped Replication 등은 내결함성을 갖춘 합의 알고리즘
	-	이들은 메시지의 전체 순서 브로드캐스트(total order broadcast) 를 구현할 수 있음
	-	즉, 모든 노드가 같은 메시지를 같은 순서로 수신

### 리더 선출과 에포크(Epoch)
	-	리더의 유일성을 보장하기 위해 사용되는 개념
	  -	Paxos: 뷰 번호(view number)
	  -	Raft: 텀(term)
	-	새 리더는 자신보다 더 높은 에포크 번호를 가진 리더가 없음을 확인하고 투표를 얻어야 함
	-	정족수(majority) 를 통해 리더가 유효한 결정을 내렸음을 보장

### 합의의 제약
	-	합의 알고리즘은 비동기 네트워크에서 안전성을 보장하지만, 성능, 유연성, 운영 측면에서는 비용이 큼
	-	주요 제약사항:
	  -	투표에 참여하는 노드 집합이 고정된다는 가정(동적 멤버십 어려움)
	  -	장애 감지는 보통 타임아웃 기반이므로 네트워크 지연에 민감
	  -	리더 장애를 잘못 판단하면 성능 저하 발생 가능

### 합의를 위한 코디네이션 서비스
	-	etcd, ZooKeeper 등은 합의 알고리즘을 구현해주는 코디네이션 서비스
	-	특징:
	  -	적은 수의 노드에 의해 운영됨
	  -	선형성 연산, 변경 감시(watch), 원자적 연산 제공
	  -	리더 선출, 작업 할당, 분산 잠금 등 다양한 기능 지원
	  -	다만, 대규모 상태 저장에는 부적합하며 작고 자주 바뀌지 않는 메타데이터용으로 적합

### 정리
  -	분산 트랜잭션과 합의는 모두 여러 노드 간의 일관된 결정을 위한 중요한 도전 과제
	-	성능과 내결함성 사이에는 항상 트레이드오프가 존재
	-	많은 시스템이 완벽한 선형성이나 원자성을 포기하고 대신 성능과 가용성을 택함
	-	그러나, 리더 선출, 분산 락, 유일성 보장, 메타데이터 저장 등에서는 합의가 필수적인 도구로 사용됨
