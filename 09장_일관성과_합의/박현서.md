내결함성을 지닌 분산 시스템을 구축하는데 쓰이는 알고리즘과 프로토콜을 알아보자.

내결함성을 지닌 시스템 구축 방법은 범용 추상화를 구현하여 애플리케이션에서 의존하도록 하는 것이다.

가장 중요한 추상화는 “합의”다. 네트워크 결함, 프로세스 장애 등이 발생해도 합의에 도달하는 것은 까다로운 문제다.

# 1. 일관성 보장

데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 알아보자.

- 강한 보장을 제공하는 시스템 : 성능이 나쁠 수도 있음, 약한 보장을 제공하는 시스템보다 내결함성이 약할 수도 있음

(강한 보장을 제공하는 시스템에 단점을 있을 수 있지만 매력적이다.)

트랜잭션 격리 수준 계층은 분산 일관성 모델과 비슷한 점이 있지만 독립적인 괌심사가 있다. 트랜잭션 격리는 주로 경쟁 조건을 회피하는 것이지만 분산 일관성은 대개 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관해있다.

# 2. 선형성

- 선형성
    - 정의 : 최신성 보장 (정확한 정의는 미묘하다.)
    - 기본 아이디어 : 시스템에 데이터 복제본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것이다.
    - 장점 : 현실에 여러 복제본이 있더라도 애플리케이션은 거기에 신경 쓸 필요가 없다.

![image](https://github.com/user-attachments/assets/3e7a851d-788b-483c-b810-54af9f30376b)


## 1) 시스템에 선형성을 부여하는 것은 무엇인가?

시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만들면 된다.

![image](https://github.com/user-attachments/assets/29dbfe9f-7382-4454-bcb4-55ea894df098)


- 레지스터(register)
    - 선형성 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는데, 이때 분산 시스템 분야에서는 x를 레지스터라고 한다.
- read(x) ⇒ v
    - 클라이언트가 레지스터 x 값 읽기 요청 → 데이터베이스가 값 v를 반환함을 의미한다.
- write(x, v) ⇒ r
    - 클라이언트가 레지스터 x 값을 v로 설정 요청 → 데이터베이스가 응답 r(ok 또는 error)을 반환함을 의미

클라이언트 A, B는 최신 값을 읽기 위해 반복적으로 데이터베이스를 폴링한다.

- 명백하게 클라이언트C write 연산 전에 클라이언트 A가 read를 요청한 경우
    - 0을 반환한다.
- 명백하게 클라이언트C write 연산 후에 클라이언트 A가 read를 요청한 경우
    - 1을 반환한다.
- 클라이언트C write 연산 시간과 클라이언트A read 연산 시간이 겹치는 경우
    - 0을 반환했을 수도 1을 반환했을 수도 있다.

시스템을 선형적으로 만들기 위해서는 다른 제약 조건을 추가해야 한다.

![image](https://github.com/user-attachments/assets/77c6ad78-be62-4149-8ef5-d73c00a6a82b)


- x 값이 원자적으로 0에서 1로 바뀌는 시점이 있다고 상상한다.
    - 한 클라이언트의 read가 새로운 값 1을 반환하는 경우 → 이후의 모든 read는 새로운 값을 반환해야 한다.

![image](https://github.com/user-attachments/assets/579db0fd-c1b0-4269-bc0a-66368c085d9f)


연산 실행이 된 시점을 수직선으로 표시하고 있다.

표시들은 모여서 순차열을 이루며 레지스터에 실행된 읽기, 쓰기의 유효한 순차열이 돼야 한다.

- 클라이언트 B, C의 cas 요청은 성공하지만 클라이언트 D의 cas 요청은 실패한다. → 클라이언트 D의 요청을 처리하는 시점에 x의 값은 0이 아니기 때문이다.
- 클라이언트 B의 마지막 읽기는 선형적이지 않다. → 마지막으로 클라이언트 A에서는 x의 값을 4라고 응답받았는데 클라이언트 B는 과거의 x 값인 2를 반환할 수 없다.

## 2) 선형성에 기대기

### 2-1) 잠금과 리더 선출

- 단일 리더 복제 시스템
    - 리더가 여러 개가 아니라 하나만 존재하도록 보장해야 한다.
    - 보장 : 리더를 선출하는 한 가지 방법으로는 잠금을 사용하면 된다.
- Apache ZooKeeper, etcd
    - 분산 잠금, 리더 선출을 구현하기 위한 코디네이션 서비스
    - 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현
- Apache Curator
    - 잠금, 리더 선출을 올바르게 구현하는데 세부사항을 zookeeper 위에 고수준 레시피를 제공해서 도움을 줌
- RAC; Oracle Real Application Cluster
    - 이러한 선형성 잠금은 트랜잭션 실행의 중요 경로에 있다. → 데이터베이스 노드들 사이의 통신용으로 전용 클러스터 연결 네트워크를 사용한다.
    - 분산 데이터베이스에서 세분화된 수준으로 사용되기도 함여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근한다. → 디스크 페이지마다 잠금을 사용한다.

### 2-2) 제약 조건과 유일성 보장

관계형 데이터베이스에서 유일성 제약 조건은 선형성이 필요하다.

→ 모든 노드가 동의하는 하나의 최신 값이 있기를 요구하기 때문이다.

### 2-3) 채널 간 타이밍 의존성

선형적이지 않으면 파일 저장소에 이미지가 기록 완료되는 시점보다 메시지 큐에서 메시지를 전달하는 시점이 더 빠를 수도 있어 최신의 이미지를 가져오지 않을 수도 있다.

하지만 선형적임을 보장한다면 최종적으로 이미지 크기 변경 모듈에서 파일 저장소로부터 최신의 이미지를 가져올 것이기에 문제가 없다.

![image](https://github.com/user-attachments/assets/43eb0eba-153d-413f-9cf2-77fc7b2f764f)


## 3) 선형성 시스템 구현하기

- 선형성
    - 데이터 복사본이 하나만 있는 것처럼 동작한다.
    - 데이터에 실행되는 모든 연산은 원자적이다.

간단하게 해결하려면 데이터 복사본 하나만 사용하는 것인데 이 방법으로는 결함을 견뎌낼 수 없다.

시스템이 내결함성을 지니도록 만드는 방법으로는 “복제”를 사용하는 것이 있는데 여러 케이스들을 봐보자.

- 단일 리더 복제 : 선형적이 될 가능성 있음
    - 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다.
        - → 하지만 스냅숏 격리와 같은 기능으로 인해 모든 단일 리더 데이터베이스가 실제로 선형적이라고 하기는 어렵다.
    - 리더를 읽기로 사용하면 될 수도 있다.
        - → 하지만 리더가 아닌 노드가 자신이 리더라고 생각하게 될 가능성을 배제할 수 없다.
- 합의 알고리즘 : 선형적
    - 스플릿 브레인, 복제본이 뒤처지는 문제를 막을 수단이 포함된다. 세부 사항 덕에 선형성 저장소를 안전하게 구현할 수 있다. (ex. zookeeper, etcd)
- 다중 리더 복제 : 비선형적
    - 여러 노드에서 동시에 쓰기를 처리하고 내용을 비동기로 다른 노드에 복제하기에 선형적이지 않다.
- 리더 없는 복제 : 아마도 선형적
    - 다이나모 스타일처럼 정족수 읽기, 쓰기를 요구함으로써 “엄격한 일관성”을 달성할 수 있다.
        - → 하지만 정족수의 설정에 따라, 엄격한 일관성을 어떻게 정의하냐에 따라 진실이 아닐 수 있다.
    - 일 기준 시계 기반으로 한 “최종 쓰기 승리” 충돌 해소 방법은 거의 확실히 비선형적이다.

### 3-1) 선형성과 정족수

정족수 (w + r > n) 가 만족돼도 선형적이지 않을 수 있다.

클라이언트A : (r = 2) 읽기를 했을 때 복제본3으로부터 레지스터 x의 값을 1로 최신으로 응답받는다.

클라이언트B : (r = 2) 읽기를 클라이언트A보다 늦게 요청했으나 레지스터 x의 값을 0으로 응답받는다.

![image](https://github.com/user-attachments/assets/f2a076d5-e5be-4d01-abe8-dcc4f3ca6114)


성능이 떨어지는 비용을 지불하면 다이나모 스타일 정족수를 선형적으로 만들 수 있다.

읽기를 실행하는 클라이언트는 결과를 애플리케이션에 반환하기 전에 읽기 복구를 동기식으로 수행한다.

쓰기를 실행하는 클라이언트는 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다.

하지만 카산드라의 경우 LWW(최종 쓰기 승리 충돌 해소 방법)을 사용하는데 일 기준 시계 기반이기에 선형적이라고 할 수 없다.

즉, 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전하다.

## 4) 선형성의 비용

네트워크가 끊기면 선형성과 가용성 사이에서 선택해야 한다.

![image](https://github.com/user-attachments/assets/475da494-040c-4f0f-a945-66827df8bac7)


각 데이터센터 내부 네트워크는 동작한다. 클라이언트들은 데이터센터에 접근할 수 있지만 데이터센터끼리는 서로 연결할 수 없는 상황을 가정해보자.

- 선형성을 선택하는 경우
    - 단일 리더 복제를 사용하는 경우 리더가 데이터센터 중 하나에만 있어야 한다. 모든 쓰기와 선형성 읽기는 리더로 보내져야 한다. → 팔로워 데이터센터로 접속한 클라이언트에서 보낸 읽기, 쓰기 요청은 네트워크를 통해 동기식으로 리더 데이터센터로 전송돼야 한다.
    - 단일 리더 설정에서 데이터센터 사이의 네트워크가 끊기면
        - 데이터베이스에 아무것도 쓸 수 없고 선형성 읽기도 할 수 없다. → 리더와 연결할 수 없는 데이터센터에서는 해당 애플리케이션을 사용할 수 없다.
- 가용성을 선택하는 경우
    - 다중 리더 데이터베이스를 사용하는 경우 계속 동작할 수 있다. 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되므로 큐에 쌓았다가 네트워크 연결이 복구되면 전달만하면 된다.

### 4-1) CAP 정리

네트워크 분단이 생기면 일관성과 가용성 중 하나를 선택해야 한다.

- 애플리케이션에서 선형성을 요구하는 경우
    - 네트워크 문제 발생 : 복구될 때까지 오류를 반환해야 한다. → 가용성이 없다.
- 애플리케이션에서 선형성을 요구하지 않는 경우
    - 네트워크 문제 발생 : 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다. → 선형적이지 않다.

### 4-2) 선형성과 네트워크 지연

선형적인 시스템은 드물다.

최신 다중코어 CPU의 RAM조차 선형적이지 않은데, 모든 CPU 코어가 각각 메모리 캐시와 저장 버퍼를 갖기 때문이다.

선형성을 포기한 이유는 성능 때문이다.

여러 분산 데이터베이스에서도 마찬가지로 성능을 향상시키기 위해서 선형성을 포기하는 경우가 많다.

# 3. 순서화 보장

- 선형성 레지스터
    - 데이터 복사본이 하나만 있는 것처럼 동작한다.
    - 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보인다.
    - 즉, 정의된 순서대로 실행된다는 것을 의미한다.

순서화는 중요한 근본적 아이디어일 수도 있고 순서화는 선형성, 합의 사이에 연결 관계가 있다

- 단일 리더 복제
    - 리더의 주 목적은 복제 로그에서 쓰기의 순서이다.
    - 즉, 팔로워가 쓰기를 적용하는 순서를 결정하는 것 → 단일 리더 없을 시 동시 연산에 의해 충돌 가능
- 직렬성
    - 트랜잭션 일련 순서에 따라 실행되는 것처럼 동작하도록 보장
    - 트랜잭션을 직렬적인 순서대로 실행해서 직렬성을 얻을 수도 있고, 동시 실행을 허용하지만 잠금을 통해 직렬성 충돌을 막는 방법도 있음

## 1) 순서화와 인과성

순서화는 인과성을 보존하는 데 도움을 준다.

### 1-1) 인과적 순서는 전체 순서가 아니다

전체 순서는 어떤 두 요소를 비교할 수 있게한다.

하지만 수학적 집합은 항상 전체 순서를 정할 수 있지는 않다.

즉, 수학적 집합은 부분적으로 순서가 정해진다.

- 선형성 : 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.
- 인과성 : 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻이다. 어떤 연산들은 서로 순서를 정할 수 있지만 어떤 연산들은 비교할 수 없다.

### 1-2) 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 내포한다.

어떤 시스템이든 선형적이라면 인과성도 올바르게 유지한다.

선형성을 지키면 성능에 해가될 수 있고, 절충안이 있다.

시스템은 성능 손해를 유발하지하지 않고 인과적 일관성을 만족시킬 수 있다.

### 1-3) 인과적 의존성 담기

- 인과성 유지하는 법
    - 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다.

리더 없는 데이터 저장소는 갱신 손실 방지를 위해 키에 대한 동시 쓰기를 검출해야 한다.

인과성 의존성은 단일 키뿐만 아니라 전체 데이터베이스에 걸친 인과적 의존성을 추적해야하고 이를 위해 버전 벡터를 일반화할 수 있다.

## 2) 일련번호화 순서화

인과성은 중요한 이론적 개념이지만 실제로 추적하기에는 실용성이 떨어진다.

그래서 일련번호나 타임스탬프를 써서 이벤트 순서를 정할 수 있다.

일 기준 시계가 아닌 논리적 시계로 얻어서 전체 순서를 제공할 수 있다.

### 2-1) 비인과적 일련번호 생성기

- 각 노드가 자신만의 독립적인 일련번호 집합을 생성하도록 설정
- 일 기준 시계에서 얻은 타임스탬프 사용 (해상도 높을 경우)
- 일련번호 블록을 미리 할당

이러한 선택지는 잘 동작하지만, 생성한 일련번호가 인과성에 일관적이지 않다. → 여러 노드에 걸친 연산들의 순서를 올바르게 담지 못하기 때문이다.

### 2-2) 램포트 타임스탬프

인과성에 일관적인 일련번호를 생성하는 방법으로 “램포트 타임스탬프”가 있다.

- 각 노드는 고유 식별자를 갖는다.
- 각 노드는 처리한 연산 개수를 카운터로 유지한다.
- 램포트 타임스탬프는 (카운터, 노드ID)의 쌍이다.

두 노드는 카운터 값이 같을 수도 있지만 타임스탬프에 노드ID를 포함시켜 각 타임스탬프는 유일하게 된다.

램포트 타임스탬프는 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 큰거로 판단한다. 카운터 값이 같으면 노드ID가 큰 것이 타임스탬프가 크다.

### 2-3) 타임스탬프 순서화로는 충분하지 않다.

램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만 분산 시스템의 여러 공통 문제를 해결하는데 충분하지는 않다.

연산의 전체 순서가 있는 것으로는 충분하지 않고, 언제 순서가 확정되는지도 알아야 한다.

## 3) 전체 순서 브로드캐스트

시스템 확장할 때 또는 리더에 장애가 발생했을 때 어떻게 장애 복구를 처리할 것인가는 어려운 문제다.

분산 시스템에서는 이 문제가 “전체 순서 브로드캐스트”나 “원자적 브로드캐스트”로 알려져 있다.

- 전체 순서 브로드캐스트
    - 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.
    - 두 가지 안전성 속성을 항상 만족해야 한다.
        - 신뢰성 있는 전달 : 어떤 메시지도 손실되지 않는다.
        - 전체 순서가 정해진 전달 : 메시지는 모든 노드에 같은 순서로 전달된다.

전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야 한다.

### 3-1) 전체 순서 브로드캐스트 사용하기

zookeeper, etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 구현한다.

- 상태 기계 복제
    - 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리한다. → 복제 서버들은 서로 일관성 있는 상태를 유지한다.

전체 순서 브로드캐스트에서 중요한 측면은 메시지가 전달되는 시점에 순서가 고정된다는 것이다. 이 사실 덕분에 전체 순서 브로드캐스트가 타임스탬프 순서화보다 강하다.

### 3-2) 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

전체 순서 브로드캐스트는 비동기식으로 메시지는 고정된 순서로 신뢰성 있게 전달되도록 보장되지만 언제 메시지가 전달될지는 보장되지 않는다. 반면 선형성은 최신성을 보장한다.

하지만 전체 순서 브로드캐스트로 선형성 저장소를 만들 수 있는데, cas 연산이 구현되도록 하여 여러 사용자가 특정한 사용자명을 가지려고 하면 연산 중 하나만 성공하도록 한다. 다만 선형적인 읽기는 보장하지 않는다.

선형적인 읽기를 보장하려면 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻거나, 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽도록 할 수 있다.

### 3-3) 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

선형성 저장소가 있을 때 이를 기반으로 전체 순서 브로드캐스트를 구현할 수도 있다.

원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 하자.

전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다. 그리고 메시지를 모든 노드에 보내어 수신자들은 일련번호 순서대로 메시지를 전달한다.

# 4. 분산 트랜잭션과 합의

합의는 분산 컴퓨팅에서 중요한 문제이다.

비공적으로 합의의 목적은 “여러 노드들이 뭔가에 동의하게 만드는 것”이다.

- 노드 동의가 중요한 상황
    - 리더 선출 : 단일 리더 복제를 사용하는 데이터베이스에서 모든 노드는 어떤 노드가 리더인지 동의해야 한다. 네트워크 결함으로 인해 노드끼리 통신 부가하는 경우, 리더 자리를 경쟁할 수 있다.
    - 원자적 커밋 : 여러 노드나 파티션에 걸친 트랜잭션을 지원하는 데이터베이스의 경우, 트랜잭션이 어떤 노드에서는 성공하고 어떤 노드에서는 실패할 수도 있다.
- 합의 불가능성 (FLP)
    - 의미 : 어떤 노드가 죽을 위험이 있다면 항상 합의에 이를 수 있는 알고리즘은 없다는 것을 의미한다.
    - FLP 결과 : 시계, 타임아웃도 사용할 수 없는 결정적인 알고리즘을 제한된 모델인 비동기 시스템 모델에서 증명된다.
    - 보통 현실 : 분산 시스템은 합의를 달성할 수 있다.

## 1) 원자적 커밋과 2단계 커밋(2PC)

- 트랜잭션 원자성의 목적
    - 여러 쓰기를 실행하는 도중 뭔가 잘못되는 경우에 간단한 시맨틱을 제공하기 위함

### 1-1) 단일 노드에서 분산 원자적 커밋으로

단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현된다.

- 단일 노드 트랜잭션 커밋
    - 데이터가 디스크에 지속성 있게 쓰여지는 순서에 결정적으로 의존한다.
    - 따라서 커밋을 원자적으로 만들어주는 것은 단일 장치다. (특정한 하나의 노드에 부착된 하나의 특정 디스크 드라이브의 컨트롤러)
- 여러 노드 트랜잭션 커밋
    - 모든 노드에 커밋 요청을 보내고 각 노드에서 독립적으로 트랜잭션을 커밋하는 것으로 충분치 않다.
    - 어떤 노드는 커밋 성공하고 다른 노드에서는 실패해서 원자성 보장을 위반하기 쉽다.

여러 노드 트랜잭션 커밋에서 어떤 노드에 문제가 생겼을 때, 트랜잭션 커밋이 성공한 노드에서 커밋을 다시 되돌릴 수 없다.

애플리케이션 로직으로 새로운 트랜잭션(“보상 트랜잭션”)을 통해서 취소하는 효과를 만들 수는 있다.

### 1-2) 2단계 커밋 소개

- 2단계 커밋
    - 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성을 보장하는 알고리즘이다.

데이터베이스에서 내부적으로 2PC를 사용하고 XA 트랜잭션, SOAP 형태로 사용된다.

![image](https://github.com/user-attachments/assets/06a92a8e-9d2d-410a-93e8-ccaed5a9cd3d)


2PC는 단일 노드 트랜잭션에서 존재하지 않는 새로운 컴포넌트인 코디네이터를 사용한다. 2PC 트랜잭션은 평상시처럼 여러 데이터베이스 노드에서 데이터를 읽고 쓴다. 애플리케이션이 커밋할 준비가 되면 코디네이터가 1단계를 시작한다. 각 노드에 준비 요청을 보내서 커밋할 수 있는지 물어보고 코디네티어는 참여자들의 응답을 추적한다.

### 1-3) 약속에 관한 시스템

2PC가 다른 이유, 과정

1. 애플리케이션은 분산 트랜잭션 시작 시 코디네이터에게 트랜잭션ID를 요청 (트랜잭션ID는 전역적으로 유일)
2. 애플리케이션은 각 참여자에서 단일 노드 트랜잭션을 시작한다. 이때 단일 노드 트랜잭션에 유일한 트랜잭션ID를 붙인다.
3. 애플리케이션이 커밋할 준비가 되면 코디네이터는 모든 참여자에게 전역 트랜잭션ID로 태깅된 준비 요청을 보낸다.
4. 참여자가 준비 요청을 받으면 모든 상황에서 분명히 트랜잭션을 커밋할 수 있는지 확인한다. 코디네이터에게 “네”라고 응답함으로써 노드는 요청이 있으면 트랜잭션을 오류 없이 커밋할 것이라고 약속한다.
5. 코디네이터가 모든 준비 요청에 대해 응답을 받았을 때 트랜잭션 커밋, 어보트를 최종적 결정을 한다. (코디네이터가 죽을 경우를 대비해 디스크에 있는 트랜잭션 로그에 결정을 기록한다. → 이를 **“커밋 포인트”**라고 한다.)
6. 코디네이터의 결정이 디스크에 쓰여지면 모든 참여자에게 커밋이나 어보트 요청이 전송된다. (**요청이 실패하거나 타임아웃되더라도 코디네이터는 성공할 때까지 영원히 재시도해야 한다.**)

### 1-4) 코디네이터 장애

참여자의 트랜잭션이 불확실한 경우가 있다.

참여자가 준비 요청을 받고 “네”에 투표했다면, 더 이상 일방적으로 어보트할 수 없다.

코디네이터로부터 트랜잭션이 커밋됐는지 어보트됐는지 회신을 받을 때까지 기다려야 한다.

![image](https://github.com/user-attachments/assets/424329b5-dafa-4e81-8c63-831e02405d1a)


### 1-5) 3단계 커밋

- 블로킹 원자적 커밋 프로토콜
    - 2단계 커밋은 코디네이터가 복구하기를 기다리느라 멈출 수 있어 블로킹이라 표현하다.
- 논블로킹 원자적 커밋 프로토콜
    - 2PC 대안으로 노드에 장애가 나도 멈추지 않도록 3PC라는 알고리즘이 제안됐고 이를 논블로킹이라 표현한다.

3PC는 지연에 제한이 있는 네트워크와 응답 시간에 제한이 있는 노드를 가정한다.

논블로킹 원자적 커밋은 완벽한 장애 감지기(perfect failure detector)가 필요하다. 하지만 기약 없는 네트워크에서 타임아웃은 신뢰성 있는 장애 감지기가 아니기에 2PC가 계속 쓰이고 있다.

## 2) 현실의 분산 트랜잭션

MySQL에서 분산 트랜잭션은 단일 노드 트랜잭션보다 10배 이상 느리다고 보고된다. 2PC에 내장된 성능 비용의 많은 부분은 장애 복구를 위해 필요한 부가적인 디스크 강제 쓰기(fsync)와 부가적인 네트워크 왕복 시간 때문이다.

그러나 분산 트랜잭션을 일축하기보다 무엇을 의미하는지를 정확히 알아야 한다.

- 데이터베이스 내부 분산 트랜잭션
    - 분산 데이터베이스는 데이터베이스 노드 사이에 내부 트랜잭션을 지원한다.
    - 트랜잭션에 참여하는 모든 노드는 동일한 데이터베이스 소프트웨어를 실행한다.
- 이종 분산 트랜잭션
    - 이종 트랜잭션은 참여자들은 둘 혹은 그 이상의 다른 기술이다. → 두 가지 서로 다른 벤더의 데이터베이스일 수도, 메시지 브로커처럼 비데이터베이스 시스템일 수도 있다.
    - 분산 트랜잭션은 시스템의 내부가 완전히 다르더라도 원자적 커밋을 보장해야 한다.

### 2-1) 정확히 한 번 메시지 처리

이종 분산 트랜잭션에서는 다양한 시스템들이 강력한 방법으로 통합될 수 있게한다.

하지만 트랜잭션의 영향을 받는 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있을 때만 가능하다.

메시지 처리 시에 이메일 전송이 되는 경우, 이베일 서버가 2PC를 지원하지 않는다면 메시지가 실패하고 재시도되면 이메일이 두 번 이상 전송될 수 있다. 그러나 트랜잭션이 어보트될 때 메세지를 처리하는 모든 부수 효과가 롤백된다면 처리 단계는 아무 일도 없었던 것처럼 안전하게 재시도될 수 있다.

### 2-2) XA 트랜잭션

XA 트랜잭션(eXtended Architecture)는 이종 기술에 걸친 2PC를 구현하는 표준이다.

XA는 네트워크 프로토콜이 아니다. 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 CAPI일 뿐이다.

XA 트랜잭션은 JTA를 사용해 구현되며 JTA는 JDBC, JMS를 사용하는 곳에서 지원된다.

### 2-3) 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

문제는 “잠금”과 관련있다.

데이터베이스 트랜잭션은 보통 dirty write를 막기 위해 그들이 변경한 로우에 로우 수준의 독립적인 잠금을 획득한다. 추가로 직렬성 격리를 원한다면 2PC를 사용하는 데이터베이스는 트랜잭션에서 읽은 로우에 공유 잠금도 획득해야 한다.

데이터베이스에서는 트랜잭션이 커밋/어보트 되기 전까지 잠금을 해제할 수 없다. 코디네이터가 죽어서 재시작하는데까지 잠금이 계속해서 유지되거나, 어떤 이유로 코디네이터의 로그가 완전히 손실되면 잠금은 영원히 또는 관리자가 수동으로 상황을 해결할 때까지 유지된다.

### 2-4) 코디네이터 장애에서 복구하기

이론상으로는 코디네이터가 죽은 후 재시작하면 로그로부터 그 상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야 한다.

하지만 고아가 된 의심스로운 트랜잭션은 코디네이터가 그 결과를 결정할 수 없을 수 있다.

이를 빠져나갈 수 있는 유일한 방법은 관리자가 수동으로 트랜잭션을 커밋/롤백을 결정하는 것이다.

여러 XA 구현에는 참여자가 코디네이터로부터 확정적 결정을 얻지 않고 의심스러운 트랜잭션을 커밋 또는 어보트할지를 결정할 수 있도록하는 “경험적 결정”이라는 것이 있다. 이러한 경험적 결정은 2PC 체계를 위반하기에 원자성이 깨질 수도 있다는 것을 의미한다. → 경험적 결정은 큰 장애 상황을 벗어나고자 할 때만 쓰도록 의도됐다.

### 2-5) 분산 트랜잭션의 제약

XA는 데이터 시스템이 서로 일관성을 유지하게 하는 중요한 문제를 해결해준다.

하지만 XA 트랜잭션도 중요한 운영상 문제를 가져온다.

- 코디네이터 SPOF
    - 복제되지 않고 단일 장비로만 실행되면 전체 시스템의 단일 장애점이 된다.
- 코디네이터가 애플리케이션의 일부가 되는 경우
    - 코디네이터의 로그가 지속적인 시스템 상태의 중대한 부분이 된다.
    - 애플리케이션 서버는 더 이상 상태 비저장이 아니다.
- XA 최소 공통 분모 필요
    - 여러 시스템에 걸친 교착 상태를 감지할 수 없다. → 시스템이 각 트랜잭션이 대기 중인 잠금에 대한 정보를 교환하기 위한 표준화된 프로토콜이 필요하다.
    - SSI(직렬성 스냅숏 격리)와 함께 동작하지 않는다. → SSI를 지원하려면 여러 시스템에 걸친 충돌을 식별할 프로토콜이 필요하다.
- 장애 증폭
    - 2PC가 성공적으로 트랜잭션을 커밋하려면 모든 참여자가 응답해야 한다는 문제가 있다. → 결과적으로 시스템의 어떤 부분이라도 고장 나면 트랜잭션도 실패한다.

이종 분산 트랜잭션의 고통 없이 같은 것을 달성할 수 있게 허용하는 대안적인 방법이 있다. (11, 12장)

## 3) 내결함성을 지닌 합의

- 합의 문제 형식화 : 하나 또는 이상의 노드들이 값을 제안할 수 있고 합의 알고리즘이 그 값 중 하나를 결정한다.
- 합의 알고리즘 속성
    - 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다.
    - 무결성 : 어떤 노드도 두 번 결정하지 않는다.
    - 유효성 : 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.
    - 종료 : 죽지 않은 모든 노드는 결국 어떤 값을 결정한다.

내결함성이 상관없다면 세 개 속성(동의, 무결성, 유효성)을 만족시키는 것은 쉽다. → 한 노드를 독재자로 두면 된다.

종료 속성은 내결함성의 아이디어를 형식화한다.

모든 노드가 죽으면 어떤 알고리즘을 쓰든 아무것도 결정할 수 없다. 어떤 합의 알고리즘이라도 종료를 보장하려면 최소한 노드의 과반수가 올바르게 동작해야 한다. 따라서 종료 속성은 노드 대수가 연결할 수 없는 노드 대수가 절반 미만이라는 가정에 종속적이다.

대부분의 합의 알고리즘은 “비잔틴 결함”이 없다고 가정한다. (1/3 미만의 노드만 비잔틴 결함이 있다면 비잔틴 결함에도 견고하도록 합의를 만들 수 있다.)

### 3-1) 합의 알고리즘과 전체 순서 브로드캐스트

- 내결함성을 지닌 합의 알고리즘
    - 뷰스탬프 복제(Viewstamped Replication, VSR)
    - 팍소스(Paxos)
    - 라프트(Raft)
    - 잽(Zab)

이 알고리즘 중 대다수는 형싱적 모델(동의, 무결성, 유효성, 종료 속성을 만족하고 하나의 값을 제안하고 결정)을 직접 사용하지 않는다. 대신 순차열에 대해 결정해서 전체 순서 브로드캐스트 알고리즘을 만든다.

- 전체 순서 브로드캐스트
    - 모든 노드에게 메시지가 정확히 한 번, 같은 순서로 전달돼야 한다.
    - 이것은 합의를 몇 회하는 것과 동일하다. → 각 회마다 노드들은 다음에 보내기 원하는 메시지를 제안하고 전체 순서 상에서 전달될 다음 메시지를 결정한다.

뷰스탬프 복제, 라프트, 잽은 전체 순서 브로드캐스트를 직접 구현한다. 그렇게 하는게 한 번에 한 값을 처리하는 합의를 여러 번하는 것보다 효율적이다.

### 3-2) 단일 리더 복제와 합의

- 단일 리더 복제 : 모든 쓰기를 리더에게 전달하고 쓰기를 같은 순서로 팔로워에 적용해서 복제본이 최신 상태를 유지하게 만든다.

단일 리더 복제를 본질적으로 전체 순서 브로드캐스트처럼 보여 “합의”가 필요 없어 보이지만 리더가 어떻게 선택하느냐에 따르다.

“스플릿 브레인” 문제의 경우 모든 노드들이 누가 리더인지 동의해야 한다.

그렇지 않을 경우 두 개의 다른 노드가 각자 자신이 리더라고 생각하고 결과적으로 데이터베이스 일관성이 깨질 수도 있다.

따라서 리더를 선출하려면 “합의”가 필요하다.

여기서 합의 알고리즘들이 실제로는 전체 순서 브로드캐스트 알고리즘이라면 결국 합의를 위한 합의를 해결해야 한다.

### 3-3) 에포크 번호 붙이기와 정족수

지금까지 설명한 합의 프로토콜은 모두 내부적으로 어떤 형태로든 리더를 사용하지만 리더가 유일하다고 보장하지 않는다.

이 프로토콜들은 에포크 번호(epoch number) 등을 정의하고 각 에포크 내에서 리더가 유일하다고 보장한다.

에포크는 전체 순서가 있고 단조 증가한다.

두 가지 다른 에포크에 있는 두 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

리더가 자신이 쫓겨나지 않았다는 사실은 “정족수”를 통해서 알 수 있다.

리더는 내리려고 하는 모든 결정에 대해 제안된 값을 다른 노드에게 보내서 노드의 정족수가 그 제안을 찬성한다고 응답하기를 기다려야 한다. 노드는 에포크 번호가 더 높은 다른 리더를 알지 못할 때만 제안에 찬성하는 투표를 한다.

따라서 투표는 2번 있다.

한 번은 리더 선출, 두 번째는 리더 제안이다.

두 번의 투표를 하는 정족수가 겹쳐야 하며, 제안에 대한 투표가 성공하면 제안에 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.

따라서 제안에 대한 투표를 할 때 에포크 번호가 더 큰 것이 있다고 밝혀지지 않았다면 현재 리더는 에포크 번호가 더 높은 리더 선출이 발생하지 않았다고 결론은 내릴 수 있다. → 자신이 여전히 리더십을 유지한다고 확신할 수 있다.

### 3-4) 합의의 제약

합의 알고리즘은 분산 시스템의 커다란 발전이다. 불확실한 시스템에 구체적인 안전성 속성을 가져오고, 내결함성을 유지한다.

전체 순서 브로드캐스트를 제공하므로 내결함성 있는 방식으로 선형성 원자적 연산을 구현할 수도 있다.

하지만 이득에는 대가가 있기에 합의 알고리즘이 모든 곳에 쓰이지는 않는다.

- 노드 제안 투표 과정은 “동기식”이다.
    - 데이터베이스는 종종 비동기 복제를 사용하도록 설정되는데, 이런 설정에서 커밋된 데이터는 장애 복구 시 잠재적으로 손실될 수 있다. 하지만 성능을 위해 이 위험을 선택하는 경우가 많다.
- 합의 시스템은 항상 엄격한 과반수가 동작하기를 요구한다.
    - 네트워크 장애 떄문에 어떤 노드들이 다른 노드와 연결이 끊기면 네트워크의 과반수 부분만 진행할 수 있고 나머지는 차단된다.
- 정적/동적 멤버십
    - 합의 알고리즘은 투표에 참여하는 노드 집합이 고정돼 있다고 가정한다. → 동적 멤버십 확장은 클러스터에 있는 노드 집합이 시간이 지남에 따라 바뀌는 것을 허용하지만 정적 멤버십 알고리즘보다 훨씬 이해하기 어렵다.
- 합의 시스템의 장애 노드 감지를 위한 타임아웃
    - 네트워크 지연의 변동이 심한 환경에서는, 분산된 시스템에서 일시적인 네트워크 문제 때문에 노드가 리더에 장애가 발생했다고 잘못 생각하는 일이 종종 생긴다. → 안전성 속성을 해치지는 않지만 잦은 리더 선출은 시스템이 리더를 선택하는 시간을 쓰기에 성능이 안좋아진다.

## 4) 멤버십과 코디네이션 서비스

애플리케이션 개발자가 zookeeper를 직접 쓸 일은 거의 없다. 보통 다른 프로젝트를 통해서 간접적으로 의존하게 될 가능성이 높다.

zookeeper, etcd는 완전히 메모리 안에 들어올 수 있는 작은 양의 데이터를 보관하도록 설계됐다. 이 소량의 데이터는 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 사용해 모든 노드에 걸쳐 복제된다. 개별 메시지가 데이터베이스에 쓰기를 나타낸다면 같은 쓰기를 같은 순서로 적용함으로써 복제본들이 서로 일관성을 유지할 수 있다.

- 선형성 원자적 연산
    - 원자적 cas 연산을 사용해 잠금을 구현할 수 있다.
- 연산의 전체 순서화
    - zookeeper는 모든 연산에 전체 순서를 정하고 각 연산에 단조 증가하는 트랜잭션ID, 버전번호를 할당하여 제공한다.
- 장애 감지
    - 클라이언트는 zookeeper 서버에 수명이 긴 세션을 유지하고 클라이언트와 서버는 주기적으로 heartbeat를 교환해서 다른 쪽이 여전히 살아 있는지 확인한다.
    - 연결이 일시적으로 끊기거나 zookeeper 노드에 장애가 나더라도 세션은 살아 있다. 그러나 세션 타임아웃보다 긴 기간 동안  heartbeat가 멈추면 zookeeper는 세션이 죽었다고선언한다.
- 변경 알림
    - 클라이언트는 다른 클라이언트가 생성한 잠금과 값을 읽을 수 있을 뿐만 아니라 변경이 있는지 감시할 수도 있다.
    - 클라이언트는 다른 클라이언트가 클러스터에 언제 합류했는지, 다른 클라이언트에 장애가 났는지 등을 알 수 있다.

### 4-1) 작업을 노드에 할당하기

zookeeper는 여러 개의 프로세스나 서비스가 있고 그중 하나가 리더나 주 구성요소로 선택돼야 할 때 유용하다.

예를 들어, 파티셔닝된 자원이 있고 어떤 파티션을 어느 노드에 할당해야 할지 결정해야 하는 경우다.

이런 종류의 작업은 zookeeper에서 원자적 연산, 단명 노드, 알림을 신중하게 사용하면 해낼 수 있다.

### 4-2) 서비스 찾기

zookeeper, etcd, consul은 서비스 찾기(service discovery)와 같이 특정 서비스에 연결하려면 어떤 ip 주소로 접속해야하는지 알아내는 용도로도 사용된다.

서비스 찾기는 합의가 필요 없지만 리더 선출은 합의가 필요하다. 합의 시스템이 누가 리더인지 이미 안다면 다른 서비스들이 리더가 누군인지 찾는데 그 정보를 사용해도 된다. 이런 목적으로 어떤 합의 시스템은 읽기 전용 캐시 복제 서버를 지원한다. 그러므로 선형적일 필요가 없는 읽기 요청을 서비스할 수 있다.

### 4-3) 멤버십 서비스

zookeeper와 같은 프로젝트는 오랜 멤버십 서비스 연구 역사의 일부로 볼 수 있다.

멤버십 서비스는 클러스터에서 어떤 노드가 현재 활성화된 살아 있는 멤버인지 결정한다.

장애 감지를 합의와 연결하면 노드들은 어떤 노드가 살아있는 것으로 여겨져야 하는지 혹은 죽은 것으로 여겨져야 하는지에 동의할 수 있다.
