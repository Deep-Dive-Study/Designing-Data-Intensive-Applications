내결함성을 지닌 분산 시스템을 구축하는데 쓰이는 알고리즘과 프로토콜을 알아보자.

내결함성을 지닌 시스템 구축 방법은 범용 추상화를 구현하여 애플리케이션에서 의존하도록 하는 것이다.

가장 중요한 추상화는 “합의”다. 네트워크 결함, 프로세스 장애 등이 발생해도 합의에 도달하는 것은 까다로운 문제다.

# 1. 일관성 보장

데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 알아보자.

- 강한 보장을 제공하는 시스템 : 성능이 나쁠 수도 있음, 약한 보장을 제공하는 시스템보다 내결함성이 약할 수도 있음

(강한 보장을 제공하는 시스템에 단점을 있을 수 있지만 매력적이다.)

트랜잭션 격리 수준 계층은 분산 일관성 모델과 비슷한 점이 있지만 독립적인 괌심사가 있다. 트랜잭션 격리는 주로 경쟁 조건을 회피하는 것이지만 분산 일관성은 대개 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관해있다.

# 2. 선형성

- 선형성
    - 정의 : 최신성 보장 (정확한 정의는 미묘하다.)
    - 기본 아이디어 : 시스템에 데이터 복제본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것이다.
    - 장점 : 현실에 여러 복제본이 있더라도 애플리케이션은 거기에 신경 쓸 필요가 없다.

![image](https://github.com/user-attachments/assets/3e7a851d-788b-483c-b810-54af9f30376b)


## 1) 시스템에 선형성을 부여하는 것은 무엇인가?

시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만들면 된다.

![image](https://github.com/user-attachments/assets/29dbfe9f-7382-4454-bcb4-55ea894df098)


- 레지스터(register)
    - 선형성 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는데, 이때 분산 시스템 분야에서는 x를 레지스터라고 한다.
- read(x) ⇒ v
    - 클라이언트가 레지스터 x 값 읽기 요청 → 데이터베이스가 값 v를 반환함을 의미한다.
- write(x, v) ⇒ r
    - 클라이언트가 레지스터 x 값을 v로 설정 요청 → 데이터베이스가 응답 r(ok 또는 error)을 반환함을 의미

클라이언트 A, B는 최신 값을 읽기 위해 반복적으로 데이터베이스를 폴링한다.

- 명백하게 클라이언트C write 연산 전에 클라이언트 A가 read를 요청한 경우
    - 0을 반환한다.
- 명백하게 클라이언트C write 연산 후에 클라이언트 A가 read를 요청한 경우
    - 1을 반환한다.
- 클라이언트C write 연산 시간과 클라이언트A read 연산 시간이 겹치는 경우
    - 0을 반환했을 수도 1을 반환했을 수도 있다.

시스템을 선형적으로 만들기 위해서는 다른 제약 조건을 추가해야 한다.

![image](https://github.com/user-attachments/assets/77c6ad78-be62-4149-8ef5-d73c00a6a82b)


- x 값이 원자적으로 0에서 1로 바뀌는 시점이 있다고 상상한다.
    - 한 클라이언트의 read가 새로운 값 1을 반환하는 경우 → 이후의 모든 read는 새로운 값을 반환해야 한다.

![image](https://github.com/user-attachments/assets/579db0fd-c1b0-4269-bc0a-66368c085d9f)


연산 실행이 된 시점을 수직선으로 표시하고 있다.

표시들은 모여서 순차열을 이루며 레지스터에 실행된 읽기, 쓰기의 유효한 순차열이 돼야 한다.

- 클라이언트 B, C의 cas 요청은 성공하지만 클라이언트 D의 cas 요청은 실패한다. → 클라이언트 D의 요청을 처리하는 시점에 x의 값은 0이 아니기 때문이다.
- 클라이언트 B의 마지막 읽기는 선형적이지 않다. → 마지막으로 클라이언트 A에서는 x의 값을 4라고 응답받았는데 클라이언트 B는 과거의 x 값인 2를 반환할 수 없다.

## 2) 선형성에 기대기

### 2-1) 잠금과 리더 선출

- 단일 리더 복제 시스템
    - 리더가 여러 개가 아니라 하나만 존재하도록 보장해야 한다.
    - 보장 : 리더를 선출하는 한 가지 방법으로는 잠금을 사용하면 된다.
- Apache ZooKeeper, etcd
    - 분산 잠금, 리더 선출을 구현하기 위한 코디네이션 서비스
    - 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현
- Apache Curator
    - 잠금, 리더 선출을 올바르게 구현하는데 세부사항을 zookeeper 위에 고수준 레시피를 제공해서 도움을 줌
- RAC; Oracle Real Application Cluster
    - 이러한 선형성 잠금은 트랜잭션 실행의 중요 경로에 있다. → 데이터베이스 노드들 사이의 통신용으로 전용 클러스터 연결 네트워크를 사용한다.
    - 분산 데이터베이스에서 세분화된 수준으로 사용되기도 함여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근한다. → 디스크 페이지마다 잠금을 사용한다.

### 2-2) 제약 조건과 유일성 보장

관계형 데이터베이스에서 유일성 제약 조건은 선형성이 필요하다.

→ 모든 노드가 동의하는 하나의 최신 값이 있기를 요구하기 때문이다.

### 2-3) 채널 간 타이밍 의존성

선형적이지 않으면 파일 저장소에 이미지가 기록 완료되는 시점보다 메시지 큐에서 메시지를 전달하는 시점이 더 빠를 수도 있어 최신의 이미지를 가져오지 않을 수도 있다.

하지만 선형적임을 보장한다면 최종적으로 이미지 크기 변경 모듈에서 파일 저장소로부터 최신의 이미지를 가져올 것이기에 문제가 없다.

![image](https://github.com/user-attachments/assets/43eb0eba-153d-413f-9cf2-77fc7b2f764f)


## 3) 선형성 시스템 구현하기

- 선형성
    - 데이터 복사본이 하나만 있는 것처럼 동작한다.
    - 데이터에 실행되는 모든 연산은 원자적이다.

간단하게 해결하려면 데이터 복사본 하나만 사용하는 것인데 이 방법으로는 결함을 견뎌낼 수 없다.

시스템이 내결함성을 지니도록 만드는 방법으로는 “복제”를 사용하는 것이 있는데 여러 케이스들을 봐보자.

- 단일 리더 복제 : 선형적이 될 가능성 있음
    - 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다.
        - → 하지만 스냅숏 격리와 같은 기능으로 인해 모든 단일 리더 데이터베이스가 실제로 선형적이라고 하기는 어렵다.
    - 리더를 읽기로 사용하면 될 수도 있다.
        - → 하지만 리더가 아닌 노드가 자신이 리더라고 생각하게 될 가능성을 배제할 수 없다.
- 합의 알고리즘 : 선형적
    - 스플릿 브레인, 복제본이 뒤처지는 문제를 막을 수단이 포함된다. 세부 사항 덕에 선형성 저장소를 안전하게 구현할 수 있다. (ex. zookeeper, etcd)
- 다중 리더 복제 : 비선형적
    - 여러 노드에서 동시에 쓰기를 처리하고 내용을 비동기로 다른 노드에 복제하기에 선형적이지 않다.
- 리더 없는 복제 : 아마도 선형적
    - 다이나모 스타일처럼 정족수 읽기, 쓰기를 요구함으로써 “엄격한 일관성”을 달성할 수 있다.
        - → 하지만 정족수의 설정에 따라, 엄격한 일관성을 어떻게 정의하냐에 따라 진실이 아닐 수 있다.
    - 일 기준 시계 기반으로 한 “최종 쓰기 승리” 충돌 해소 방법은 거의 확실히 비선형적이다.

### 3-1) 선형성과 정족수

정족수 (w + r > n) 가 만족돼도 선형적이지 않을 수 있다.

클라이언트A : (r = 2) 읽기를 했을 때 복제본3으로부터 레지스터 x의 값을 1로 최신으로 응답받는다.

클라이언트B : (r = 2) 읽기를 클라이언트A보다 늦게 요청했으나 레지스터 x의 값을 0으로 응답받는다.

![image](https://github.com/user-attachments/assets/f2a076d5-e5be-4d01-abe8-dcc4f3ca6114)


성능이 떨어지는 비용을 지불하면 다이나모 스타일 정족수를 선형적으로 만들 수 있다.

읽기를 실행하는 클라이언트는 결과를 애플리케이션에 반환하기 전에 읽기 복구를 동기식으로 수행한다.

쓰기를 실행하는 클라이언트는 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다.

하지만 카산드라의 경우 LWW(최종 쓰기 승리 충돌 해소 방법)을 사용하는데 일 기준 시계 기반이기에 선형적이라고 할 수 없다.

즉, 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전하다.

## 4) 선형성의 비용

네트워크가 끊기면 선형성과 가용성 사이에서 선택해야 한다.

![image](https://github.com/user-attachments/assets/475da494-040c-4f0f-a945-66827df8bac7)


각 데이터센터 내부 네트워크는 동작한다. 클라이언트들은 데이터센터에 접근할 수 있지만 데이터센터끼리는 서로 연결할 수 없는 상황을 가정해보자.

- 선형성을 선택하는 경우
    - 단일 리더 복제를 사용하는 경우 리더가 데이터센터 중 하나에만 있어야 한다. 모든 쓰기와 선형성 읽기는 리더로 보내져야 한다. → 팔로워 데이터센터로 접속한 클라이언트에서 보낸 읽기, 쓰기 요청은 네트워크를 통해 동기식으로 리더 데이터센터로 전송돼야 한다.
    - 단일 리더 설정에서 데이터센터 사이의 네트워크가 끊기면
        - 데이터베이스에 아무것도 쓸 수 없고 선형성 읽기도 할 수 없다. → 리더와 연결할 수 없는 데이터센터에서는 해당 애플리케이션을 사용할 수 없다.
- 가용성을 선택하는 경우
    - 다중 리더 데이터베이스를 사용하는 경우 계속 동작할 수 있다. 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되므로 큐에 쌓았다가 네트워크 연결이 복구되면 전달만하면 된다.

### 4-1) CAP 정리

네트워크 분단이 생기면 일관성과 가용성 중 하나를 선택해야 한다.

- 애플리케이션에서 선형성을 요구하는 경우
    - 네트워크 문제 발생 : 복구될 때까지 오류를 반환해야 한다. → 가용성이 없다.
- 애플리케이션에서 선형성을 요구하지 않는 경우
    - 네트워크 문제 발생 : 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다. → 선형적이지 않다.

### 4-2) 선형성과 네트워크 지연

선형적인 시스템은 드물다.

최신 다중코어 CPU의 RAM조차 선형적이지 않은데, 모든 CPU 코어가 각각 메모리 캐시와 저장 버퍼를 갖기 때문이다.

선형성을 포기한 이유는 성능 때문이다.

여러 분산 데이터베이스에서도 마찬가지로 성능을 향상시키기 위해서 선형성을 포기하는 경우가 많다.

# 3. 순서화 보장

- 선형성 레지스터
    - 데이터 복사본이 하나만 있는 것처럼 동작한다.
    - 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보인다.
    - 즉, 정의된 순서대로 실행된다는 것을 의미한다.

순서화는 중요한 근본적 아이디어일 수도 있고 순서화는 선형성, 합의 사이에 연결 관계가 있다

- 단일 리더 복제
    - 리더의 주 목적은 복제 로그에서 쓰기의 순서이다.
    - 즉, 팔로워가 쓰기를 적용하는 순서를 결정하는 것 → 단일 리더 없을 시 동시 연산에 의해 충돌 가능
- 직렬성
    - 트랜잭션 일련 순서에 따라 실행되는 것처럼 동작하도록 보장
    - 트랜잭션을 직렬적인 순서대로 실행해서 직렬성을 얻을 수도 있고, 동시 실행을 허용하지만 잠금을 통해 직렬성 충돌을 막는 방법도 있음

## 1) 순서화와 인과성

순서화는 인과성을 보존하는 데 도움을 준다.

### 1-1) 인과적 순서는 전체 순서가 아니다

전체 순서는 어떤 두 요소를 비교할 수 있게한다.

하지만 수학적 집합은 항상 전체 순서를 정할 수 있지는 않다.

즉, 수학적 집합은 부분적으로 순서가 정해진다.

- 선형성 : 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.
- 인과성 : 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻이다. 어떤 연산들은 서로 순서를 정할 수 있지만 어떤 연산들은 비교할 수 없다.

### 1-2) 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 내포한다.

어떤 시스템이든 선형적이라면 인과성도 올바르게 유지한다.

선형성을 지키면 성능에 해가될 수 있고, 절충안이 있다.

시스템은 성능 손해를 유발하지하지 않고 인과적 일관성을 만족시킬 수 있다.

### 1-3) 인과적 의존성 담기

- 인과성 유지하는 법
    - 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다.

리더 없는 데이터 저장소는 갱신 손실 방지를 위해 키에 대한 동시 쓰기를 검출해야 한다.

인과성 의존성은 단일 키뿐만 아니라 전체 데이터베이스에 걸친 인과적 의존성을 추적해야하고 이를 위해 버전 벡터를 일반화할 수 있다.

## 2) 일련번호화 순서화

인과성은 중요한 이론적 개념이지만 실제로 추적하기에는 실용성이 떨어진다.

그래서 일련번호나 타임스탬프를 써서 이벤트 순서를 정할 수 있다.

일 기준 시계가 아닌 논리적 시계로 얻어서 전체 순서를 제공할 수 있다.

### 2-1) 비인과적 일련번호 생성기

- 각 노드가 자신만의 독립적인 일련번호 집합을 생성하도록 설정
- 일 기준 시계에서 얻은 타임스탬프 사용 (해상도 높을 경우)
- 일련번호 블록을 미리 할당

이러한 선택지는 잘 동작하지만, 생성한 일련번호가 인과성에 일관적이지 않다. → 여러 노드에 걸친 연산들의 순서를 올바르게 담지 못하기 때문이다.

### 2-2) 램포트 타임스탬프

인과성에 일관적인 일련번호를 생성하는 방법으로 “램포트 타임스탬프”가 있다.

- 각 노드는 고유 식별자를 갖는다.
- 각 노드는 처리한 연산 개수를 카운터로 유지한다.
- 램포트 타임스탬프는 (카운터, 노드ID)의 쌍이다.

두 노드는 카운터 값이 같을 수도 있지만 타임스탬프에 노드ID를 포함시켜 각 타임스탬프는 유일하게 된다.

램포트 타임스탬프는 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 큰거로 판단한다. 카운터 값이 같으면 노드ID가 큰 것이 타임스탬프가 크다.

### 2-3) 타임스탬프 순서화로는 충분하지 않다.

램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만 분산 시스템의 여러 공통 문제를 해결하는데 충분하지는 않다.

연산의 전체 순서가 있는 것으로는 충분하지 않고, 언제 순서가 확정되는지도 알아야 한다.

## 3) 전체 순서 브로드캐스트

시스템 확장할 때 또는 리더에 장애가 발생했을 때 어떻게 장애 복구를 처리할 것인가는 어려운 문제다.

분산 시스템에서는 이 문제가 “전체 순서 브로드캐스트”나 “원자적 브로드캐스트”로 알려져 있다.

- 전체 순서 브로드캐스트
    - 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.
    - 두 가지 안전성 속성을 항상 만족해야 한다.
        - 신뢰성 있는 전달 : 어떤 메시지도 손실되지 않는다.
        - 전체 순서가 정해진 전달 : 메시지는 모든 노드에 같은 순서로 전달된다.

전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야 한다.

### 3-1) 전체 순서 브로드캐스트 사용하기

zookeeper, etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 구현한다.

- 상태 기계 복제
    - 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리한다. → 복제 서버들은 서로 일관성 있는 상태를 유지한다.

전체 순서 브로드캐스트에서 중요한 측면은 메시지가 전달되는 시점에 순서가 고정된다는 것이다. 이 사실 덕분에 전체 순서 브로드캐스트가 타임스탬프 순서화보다 강하다.

### 3-2) 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

전체 순서 브로드캐스트는 비동기식으로 메시지는 고정된 순서로 신뢰성 있게 전달되도록 보장되지만 언제 메시지가 전달될지는 보장되지 않는다. 반면 선형성은 최신성을 보장한다.

하지만 전체 순서 브로드캐스트로 선형성 저장소를 만들 수 있는데, cas 연산이 구현되도록 하여 여러 사용자가 특정한 사용자명을 가지려고 하면 연산 중 하나만 성공하도록 한다. 다만 선형적인 읽기는 보장하지 않는다.

선형적인 읽기를 보장하려면 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻거나, 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽도록 할 수 있다.

### 3-3) 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

선형성 저장소가 있을 때 이를 기반으로 전체 순서 브로드캐스트를 구현할 수도 있다.

원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 하자.

전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다. 그리고 메시지를 모든 노드에 보내어 수신자들은 일련번호 순서대로 메시지를 전달한다.
