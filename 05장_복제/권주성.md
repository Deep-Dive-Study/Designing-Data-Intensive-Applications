# 05. 복제
- 복제란? **`여러 장비에 동일한 데이터의 복사본을 유지하는 것`**
  - 복제가 필요한 이유
    - `지리적으로 사용자와 가깝게하여 지연 시간을 줄이기 위해`
    - `장애가 발생해도 지속적으로 동작할 수 있도록하여 가용성을 높이기 위해`
    - `읽기 쿼리를 제공하는 장비의 수를 확장하여 읽기 처리량을 늘리기 위해`

- 이번 장에서는 하나의 장비에 전체 데이터 셋을 저장할 수 있다고 가정한 경우에 대해서만 이야기함 (파티셔닝 X)

- 데이터 복제의 어려움은 **`복제된 데이터의 변경을 어떻게 관리할 것인가`** 에 있음
- 노드 간 변경을 복제하기 위한 세가지 인기 알고리즘
  - `단일 리더(single-leader)`
  - `다중 리더(multi-leader)`
  - `리더 없는(leaderless)`

- 복제 시에는 동기식 복제와 비동기식 복제 중 어떤 것을 사용할지, 잘못된 복제본은 어떻게 처리해야할 지에 대해 고려해야함
  - 이러한 트레이드 오프는 보통 데이터베이스의 설정 옵션으로 제공됨

## 리더와 팔로워
- 데이터 베이스의 복사본을 저장하는 각 노드를 `복제 서버(replica)` 라고 함
  - 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있을까?
  - 모든 쓰기는 모든 복제 서버에서 처리되어야 함
  - 그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없음
  
- 이 문제를 해결하기 위한 가장 일반적인 해결책은 **리더 기반 복제** 임
  - active-passive 혹은 master-slave 복제라고도 함 

- **`리더 기반 복제(leader-based replication)`**
  - 복제 서버 중 하나를 리더(마스터 혹은 프라이머리)로 지정
  - 클라이언트는 데이터베이스에 쓰기를 할 때 리더에게 요청
  - 리더가 먼저 로컬 저장소에 새로운 데이터 기록
  - 새로운 변경 내용을 복제 로그(replication log)나 변경 스트림(change stream) 의 일부로 팔로워에게 전송
  - 쓰기는 리더만 허용, 읽기는 전부 가능

    ![CleanShot 2025-04-20 at 02 23 44@2x](https://github.com/user-attachments/assets/aa42462e-ac3a-4fad-bdc9-021712477196)

### 동기식 대 비동기식 복제
- 복제 시스템의 중요한 세부 사항은 복제가 동기식인지 비동기식인지 여부임
- 예시) 프로필 이미지를 갱신하는 상황
  - 클라이언트는 리더에게 갱신 요청 전송
  - 리더는 요청을 받은 후, 데이터 변경을 팔로워에게 전달
  - 리더는 클라이언트에게 갱신이 성공했음을 알려줌

    ![CleanShot 2025-04-20 at 02 26 53@2x](https://github.com/user-attachments/assets/c1db93e7-128a-4a66-9f93-e92e574a84e1)

  - 보통 복제는 매우 빠르긴 하지만 정확히 얼마나 시간이 걸릴지는 보장할 수 없음
  - 팔로워가 리더와 지리적으로 멀리 떨어져 있는 경우나 네트워크 장애 시에는 시간이 오래 걸릴 수 도 있음
  - 보통 **리더 기반 복제는 비동기식으로 구성됨**

**`동기식`**
  - 장점
    - 팔로워와 리더가 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
    - 리더가 작동하지 않더라도 팔로워에서 계속 사용할 수 있음을 확신할 수 있음
  - 단점
    - 팔로워가 죽으면 쓰기가 처리될 수 없으며, 되살아날때까지 기다려야만함(단일 장애 지점)

**`반 동기식`**
  - 팔로워 1개만 동기식으로 두고 나머지는 비동기
  - 동기 팔로워가 사용할 수 없게 되거나 느려지면 교체

**`비동기식`**
  - 장점
    - 모든 팔로워가 잘못되도 리더가 쓰기 처리를 지속 가능함
  - 단점
    - 리더 장애시, 팔로워에 아직 복제되지 않은 모든 쓰기는 유실됨(지속성 보장 X)

### 새로운 팔로워 설정
- 때때로 복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야함
- 이러한 경우에, 새로운 팔로워가 리더의 복제본을 정확하게 가지고 있는지는 어떻게 보장할 수 있을까? 
  - 데이터는 항상 유동적이기 때문에, 복사의 결과가 유효하지 않을 수 있음

- **`중단시간 없이 새로운 팔로워 노드 설정`**
  - 데이터베이스를 잠그지 않고, 리더의 데이터베이스 스냅숏을 일정 시점에 가져옴
  - 스냅숏을 팔로워 노드에 복사
  - 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청
    - 스냅숏이 리더의 복제 로그의 정확한 위치와 연관되어야 함
      - Postgresql : 로그 일련번호(log sequence number)
      - MySQL : 이진로그 좌표(binlog coordinate)
  - 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을 때 따라잡았다고 이야기함
    - 이후 부터, 리더에 발생하는 데이터 변화를 이어서 처리할 수 있음

### 노드 중단 처리
- 모든 노드는 여러가지 이유로 중단 시간이 발생할 수 있음
  - 예기치 않은 오류
  - 보안 패치를 위한 리부팅

- 전체 시스템의 중단 시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지보수에 큰 장점이 됨
- 리더 기반 복제에서는 고가용성 어떻게 달성할 수 있을까?

### 팔로워 장애: 따라잡기 복구
- 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관
- 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 확인
- 팔로워는 리더에 연결해 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청
- 변경이 다 적용되면 데이터 변경의 스트림을 계속 받을 수 있음

### 리더 장애: 장애 복구
- 리더가 장애인지 판단
  - 대부분 시스템은 타임아웃을 통해 판별함
- 새로운 리더 선택
  - 선출 과정을 통해 이전에 선출된 제어 노드에 의해 새로운 리더가 임명될 수 있음
- 새로운 리더 사용을 위해 시스템을 재설정해야함
  - 쓰기 요청을 새로운 리더에게 보내도록 조치
 
- 이러한 전체 과정을** `장애 복구(failover)`** 라고 함
  - **장애 복구 과정은 잘못될 수 있는 것 투성임**

- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있음
  - 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 것임. 이러한 방식은 내구성에 대한 클라이언트의 기대를 저버리게 됨

- 노드가 모두 자신이 리더라고 믿을 수 있음(`스플릿 브레인(Split Brain)`)
  - 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염됨

- 리더가 죽었다고 판단하기 위한 적절한 타임아웃을 설정해야함

### 복제 로그 구현

#### 구문 기반 복제
- 리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문(statement) 로그를 팔로워에게 전송하는 방식

- 문제는 이 방법은 복제가 깨질 수 있음
  - 시간을 얻기 위한 NOW()나 임의의 숫자를 얻기 위한 RAND()와 같은 비결정적 함수를 호출하는 구문은 각 복제 서버마다 다른값을 생성할 가능성이 있음
  - 자동증가 컬럼을 사용하는 구문이나 데이터베이스에 잇는 데이터에 의존한다면 모두 정확히 같은 순서로 실행되어야 함
  - 부수 효과를 가진 구문(ex. 트리거, 프로시저)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수효과가 발생할 수 있음

- 해결법
  - 모든 비결정적 함수 호출은 고정 값을 반환하게끔 대체하기

- 하지만 여러 에지 케이스도 있기에 지금은 일반적으로 다른 복제 방법을 선호함

#### 쓰기 전 로그 배송
- 일반적으로 모든 쓰기는 로그에 기록함
  - 로그 구조화 저장소 엔진에선 로그 자체가 저장소의 중요한 주요 부분임
  - 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 `쓰기 전 로그(Write-ahead log, WAL)`에 쓰기 때문에 일관성 있는 상태로 색인을 복원할 수 있음

- 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트 열임
- 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있음

- 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 팔로워에 전송함
- 팔로워가 이 로그를 처리하게 되면 정확히 동일한 데이터 구조의 복제본이 만들어짐
- Oracle, Postgresql에서 사용하는 방식

- 단점
  - WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 저수준의 데이터를 기술하기 때문에 복제가 저장소 엔진과 밀접하게 엮이게 됨
  - 즉, 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없음

#### 논리적(로우 기반) 로그 복제
- 다른 로그 형식을 사용하는 방법
  - 복제 로그를 저장소 엔진의 데이터 표현과 구별하기 위해 `논리적 로그(logical log)`라고 부름
  - MySQL의 바이너리 로그는 이 접근 방식을 사용함
 
- 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함
- 삭제된 로우의 로그는 로우를 교유하게 식별하는 정보를 포함
    - 대부분 Primary Key지만, 없다면 모든 컬럼의 예전 값을 로깅해야 함
- 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 컬럼의 새로운 값을 포함함

- 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시함

- 논리적 로그를 내부와 분리했기 때문에 호환성을 더 쉽게 유지할 수 있고, 다른 버전의 데이터베이스 소프트웨어나 다른 저장소 엔진을 실행할 수 있음
  - 또한, 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬움
  - 이런 측면은 외부 시스템에 데이터베이스 내용을 전송하고자 할 때도 유용함(CDC)

#### 트리거 기반 복제
- 조금 더 유연한 상황이 필요할 때는 트리거나 프로시저를 사용하여 복제할 수도 있음
- 트리거는 애플리케이션 코드를 등록할 수 있게 하여 데이터가 변경되면 자동으로 실행됨
- 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가짐
- 그러나, 많은 오버헤드가 존재함. 그럼에도, 유연성 때문에 유용함

## 복제 지연 문제
- 복제는 **`내결함성`** 뿐만 아니라 **`확장성`** 과 **`지연시간`** 을 위해서도 필요함
  - 리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만, 읽기 전용 질의는 어떤 복제 서버에서도 가능함
  - 대부분이 읽기 요청이고 쓰기가 작은 비율로 구성된 작업부하라면 많은 팔로워를 만들어 읽기 요청을 분산시킴

- 이런 **`읽기 확장(read-sacling) 아키텍처`** 에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있음
  - 이러한 것은 비동기식 복제에서만 동작함
  - 동기식에서 한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해짐

- 하지만, 비동기 팔로워에서 데이터를 읽을 때 이전 데이터를 읽어올 수도 있는 문제가 발생함
  - 동일한 질의를 수행했을때 모든 쓰기가 반영되지 않은 다른 결과를 얻을 수 있음
  - 다만, 이러한 상태는 일시적인 상태에 불과함
  - 쓰기를 멈추고 잠시 기다리면 결국 따라잡게 되고 리더와 일치하게 됨
  - 이런 효과를 **`최종적 일관성`** 이라고 함
  - 그러나, 지연 시간이 길어지는 경우에는 문제가 될 수 있음

### 자신이 쓴 내용 읽기
- 데이터가 제출되면 리더에게 전송해야 하지만, 데이터를 볼 때는 팔로워에서 읽을 수 있음
  - 사용자가 쓰기를 수행한 직후에 곧 바로 데이터를 확인하게 된다면 아직 복제 서버에 반영되지 않았을 수 있음
  - 이러한 경우, 유실된 것처럼 보이기 때문에 사용자에게는 불만족스러운 동작임

  ![CleanShot 2025-04-20 at 03 08 52@2x](https://github.com/user-attachments/assets/865e1b06-3f8b-453c-9eb5-5775aa398aca)

- 이런 상황에서는 **`쓰기 후 읽기 일관성`** 이 필요함
  - 페이지를 재로딩 했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장
    - 다른 사용자에 대해서는 보장하지 않음

- **`쓰기 후 읽기 일관성`** 을 보장하는 여러 방법
  - `사용자가 수정한 내용을 읽을 때는 리더에서 읽기`
    - 그 밖에는 팔로워에서 읽음
    - 예를 들어, 사용자 소유의 프로필은 리더에서 읽고, 다른 사용자의 프로필은 팔로워에서 읽는 규칙을 설정
    - 다만, 쓰기가 많을 경우 효율적이지 않음

  - `마지막 갱신 시각을 찾아서 마지막 갱신 후 1분동안은 리더에서 모든 읽기를 수행하기`
    - 복제 지연을 모니터링하여 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지

  - `가장 최근 쓰기의 타임스탬프를 기록하여 갱신하기`
    - 최신 내용이 아닌 경우엔 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 대기시킴


- 다만, 이러한 방법을 사용하기 위해서는 모든 요청은 리더가 포함된 데이터센터로 라우팅될 수 있어야함
- 또한, 동일한 사용자가 여러 디바이스로 접근할 시엔 또 다른 문제가 발생할 수 있음
  - 이러한 경우엔 **디바이스 간 쓰기 후 읽기 일관성** 이 제공되어야 함
  - 마지막 갱신 타임스탬프를 기억해야 하는 방식을 어려움
  - 다른 디바이스가 동일한 데이터센터로 라우팅 된다는 보장이 없음

## 단조 읽기

![CleanShot 2025-04-20 at 03 09 18@2x](https://github.com/user-attachments/assets/8ecba1ea-2ade-435e-b420-7e5d2d7bde5e)

- 위의 예시와 같은 경우에는 시간이 거꾸로 흐르는 현상이 보일 수 있음
  - 앞선 데이터를 읽고, 이후에 그 뒤의 데이터를 읽게 되는 현상 

- **`단조 읽기(monotonic read)`** 는 이상 현상이 발생하지 않음을 보장함
  - 강한 일관성보단 덜 하지만 최종적 일관성보다는 더 강한 보장임
  - 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않도록 함

- 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 방법
  - 예를 들어, 임의 선택보다는 사용자 ID의 해시를 기반으로 복제 서버를 선택하도록 함
    - 복제 서버가 고장 나면 질의를 다른 복제 서버로 재라우팅 할 필요가 있음

## 일관된 순서로 읽기
- 인과성 위반 발생  

  ![CleanShot 2025-04-20 at 03 09 42@2x](https://github.com/user-attachments/assets/0e83d2f3-f7ab-4cbc-bf3d-440b9f2e09e3)

- 이러한 현상은 **`일관된 순서로 읽기(Consistent Prefix Read)`** 와 같은 다른 유형의 보장이 필요함
  - 일련의 쓰기가 특정 순서로 발생한다면 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장

- 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제
- 같은 순서로 쓰기를 적용한다면 읽기 또한 일관된 순서를 보기 때문에 이러한 현상은 일어나지 않음
- 하지만, 많은 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하기 때문에 쓰기의 전역 순서는 없음

- 한가지 해결법은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게 하는 방법이 있음

## 복제 지연을 위한 해결책
- 최종적 일관성 시스템에서 작업할 때는 지연이 몇 분이나 몇 시간으로 증가한다면 어떻게 동작할지 고려해야함
  - 문제가 생길 수 있는지 확인해야하며, 이에 대한 대비를 해야함 
- 즉, 이러한 상황이 중요하다면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 설계해야 함
  - 복제가 비동기식으로 동작하지만, 동기식으로 동작하는 척해야함 

- 앞서 설명한 것처럼 애플리케이션이 기본 데이터베이스보다 더 강력한 보장을 제공하는 방법이 있음
- 하지만, 어플리케이션 코드에서 이러한 문제를 다루는 것은 너무 복잡하기에 잘못되기 쉬움

- 애플리케이션 개발자들은 이러한 문제를 걱정하지 않고 올바른 작업을 수행하기 위해 데이터베이스를 신뢰할 수 있는 방법을 선택하는 것이 더 좋음
- 이러한 이유로 트랜잭션을 사용함
