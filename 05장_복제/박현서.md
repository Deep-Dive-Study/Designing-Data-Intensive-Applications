복제에는 고려해야 할 트레이드 오프가 있다. 동기식 복제, 비동기식 복제 중 어떤 것을 사용할지, 잘못된 복제본을 어떻게 처리할지다.

# 1. 리더와 팔로워

데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다. 이를 위해 리더 기반 복제가 있다. 복제 서버 중 하나를 리더로 지정하고 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그, 변경 스트림의 일부로 팔로워에게 전송한다. 각 팔로워는 리더로부터 받은 로그를 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

클라이언트는 읽기 시에 리더, 팔로워에게 질의할 수 있지만 쓰기는 리더에게만 허용한다. 이러한 리더 기반 복제는 여러 관계형 데이터베이스에 내장된 기능이다. 그리고 카프카, 래빗MQ의 고가용성 큐 같은 분산 메시지 브로커에도 사용된다.

![image](https://github.com/user-attachments/assets/dc7b7745-76ed-4ab4-a28b-c0ba23b83f23)


## 1) 동기식 대 비동기식 복제

- 동기식 복제
    - 장점: 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.
    - 단점: 임의 한 노드의 장애는 전체 시스템을 멈추게 한다.
    - 보완: 반동기식을 이용한다.(팔로워 하나는 동기식 나머지는 비동기식으로 처리)

![image](https://github.com/user-attachments/assets/5f966dea-f2c2-4c1b-81d6-d4f5b546aabb)


## 2) 새로운 팔로워 설정

새로운 팔로워가 리더의 데이터 복제본을 갖는 방법

- 리더의 데이터베이스 스냅숏을 일점 시점에 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했다고하고 그때부터 리더에 발생하는 데이터 변화를 이어 처리한다.

## 3) 노드 중단 처리

리더 기반 복제에서 고가용성 달성법

### 3-1) 팔로워 장애: 따라잡기 복구

- 보관된 로그에서 결함이 발생하기 전에 처리학 마지막 트랜잭션을 알아낸다.
- 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다. 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 3-2) 리더 장애: 장애 복구

팔로워 중 하나를 새로운 리더로 승격한다. 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.

- 리더가 장애인지 판단한다.
    - 잠재적으로 여러 문제가 있을 수 있지만 무엇이 잘못됐는지 확실한 방법이 없기 때문에 대부분의 시스템은 그냥 타임아웃을 사용한다.
- 새로운 리더를 선택한다.
    - 선출과정을 통해 이뤄지거나 이전에 선출된 제어 노드에 의해 새로운 리더가 임명될 수 있다.
- 새로운 리더 사용을 위해 시스템을 재설정한다.
    - 클라이언트는 새로운 쓰기 요청을 새로운 리더에게 보내야한다. 만약 이전 리더가 복구되면 여전히 자신이 리더라고 인식할 수 있기에 복제 서버들이 자신을 리더에서 물러나게 한 것을 알도록 해야한다.

이러한 장애 복구 과정에서는 잘못될 수 있는 것들이 많다.

- 비동기식 복제 시에 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신 못할 수 있다.
- 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 하면 위험하다.
- 두 노드가 모두 자신이 리더라고 믿는 경우가 있다. (스플릿 브레인) 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터 오염 위험이 있다.
- 리더가 죽었다고 판단 가능한 적절한 타임아웃 설정이 어렵다. 너무 짧으면 불필요한 장애복구가 일어날 수 있다.

## 4) 복제 로그 구현

### 4-1) 구문 기반 복제

리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를 실핸한 다음 구문 로그를 팔로워에게 전송한다. 팔로워는 클라이언트에게 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.

- 복제가 깨지는 경우
    - NOW(), RAND()와 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
    - 자동증가 컬럼을 사용하는 구문이 있는 경우 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다.
    - 부수 효과를 가진 구문(트리거, 스토어드 프로시저, …)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.

MySQL 5.1 이전에는 구문 기반 복제(statement-based replication)가 사용됐다. 하지만 MySQL은 이제 구문에 비결정성이 있다면 기본적으로 로우 기반 복제(row-based replication)로 변경한다.

### 4-2) 쓰기 전 로그 배송

- 로그 구조화 엔진의 경우 로그 자체가 저장소의 주요 부분이다.
- 개별 디스크 블록에 덮어쓰는 B트리의 경우 모든 변경은 쓰기 전 로그에 쓰기 떄문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용 바이트 열이다. 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다. 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.

하지만 단점으로는 로그가 제일 저수준의 데이터를 기술한다. 즉, 복제가 저장소 엔진과 밀접하게 엮이고 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

### 4-3) 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진 내부와 분리하기 위한 대안으로 다른 로그 형식을 사용하는 것이다. 이러한 복제 로그를 저장소 엔진의 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다. 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있다. 또한 외부 애플리케이션이 더 파싱하기 쉽기에 오프라인 분석, 사용자 정의 색인, 캐시 구축 등을 위해 데이터 웨어하우스 같은 시스템에 내용을 전송하고자 할 때 유용하다. (CDC)

### 4-4) 트리거 기반 복제

데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소 로직이 필요하면 복제를 애플리케이션 층으로 옮겨야 한다.

오라클 골든게이트 같은 도구는 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 한다. 다른 방법으로는 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 트리거나 스토어드 프로시저를 사용한다.

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행된다. 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 이 테이블로부터 데이터 변경을 회부 프로세스가 읽을 수 있다. 그러면 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

# 2. 복제 지연 문제

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.

## 2-1) 자신이 쓴 내용 읽기

![image](https://github.com/user-attachments/assets/0644411c-3f50-4a48-95b0-88005cf1ba12)


새로운 데이터가 제출되면 리더에게 전송해야 하지만 사용자가 데이터를 볼 때는 팔로워에서 읽을 수 있다. 이런 상황에서는 쓰기 후 읽기 일관성이 필요하다.

**리더 기반 복제 시스템에서 쓰기 후 읽기 일관성 구현**

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽고, 그 밖에는 팔로워에서 읽는다.
    - 실제 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요하다.
- 리더에서 읽을지 말지 결정하기 위해 다른 기준을 사용한다.
    - 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 대부분 리더에서 읽기 때문이다.
    - 예를 들어 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다. 또한 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
- 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억할 수 있다. 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다. 복제 서버가 최신 내용이 아닌 경우 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킬 수 있다.
- 복제 서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야 한다.
- 동일한 사용자가 여러 디바이스로 서비스를 접근하는 경우
    - 메타데이터를 중앙집중식으로 관리해야 한다. (사용자의 마지막 갱신 타임스탬프를 기억해야 하는 접근 방식이 어렵기 때문이다.)
- 복제 서버가 여러 데이터센터 간에 분산돼 있다면 각 디바이스가 동일한 데이터센터로 라우팅된다는 보장이 없다. 때문에 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다.

## 2-2) 단조 읽기

![image](https://github.com/user-attachments/assets/7b0b9143-5677-468d-8dbc-7143cb936eec)

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것이다.

단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장한다. 단조 읽기는 강한 일관성보다는 덜하지만 최종적 일관성보다는 더 강한 보장이다. 즉, 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다. 단조 읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다. 예를 들어 임의 선택이 아닌 사용자 ID의 해시를 기반으로 복제 서버를 선택하는 것이다.

## 2-3) 일관된 순서로 읽기

일관된 순서로 읽기(Consistent Prefix REad)같은 또 다른 유형의 보장이 필요하다. 일관된 순서로 읽기는 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제다. 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이상 현상이 없다. 하지만 많은 분산데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없다. 즉, 사용자가 데이터베이스에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.

## 2-4) 복제 지연을 위한 해결책

복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해보자. 사용자에게 좋지 않은 경험을 준다면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템을 설계해야 한다. 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것이 문제 해결 방안이다.

# 3. 다중 리더 복제

- **리더(leader) 기반 복제 단점**
    - 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 한다.
    - 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다.

단점을 해결하려면?

- **다중 리더**
    - **리더 기반 복제 모델은 쓰기를 허용하는 노드를 하나 이상 두는 것으로 확장**된다.
    - 복제는 여전히 같은 방식을 사용한다.
    - 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달해야 한다.
    - **각 리더는 동시에 다른 리더의 팔로워 역할도 한다.**

## 1) 다중 리더 복제의 사용 사례

**단일 데이터센터 내에 다중 리더 설정을 사용하는 설정은 추가된 복잡도에 비해 이점이 크지 않기 때문에 적절하지 않다.** 몇 가지 상황에서만 합리적이다.

### 1-1) 다중 데이터센터 운영

![image](https://github.com/user-attachments/assets/7ac481f6-95aa-479f-a2c0-ffb1c7b214a3)

- 성능
    - 단일 리더 설정
        - 모든 쓰기는 인터넷을 통해 리더가 있는 데이터센터로 이동해야 한다.
        - 단점
            - → 쓰기에 지연 시간을 늘리는 원인이 된다.
            - → 처음에는 여러 데이터센터를 갖는 목적에 위배될 수 있다.
    - 다중 리더 설정
        - 다중 리더 설정에서 모든 쓰기는 로컬 데이터센터에서 처리한 다음 비동기 방식으로 다른 데이터센터에 복제한다.
        - 장점
            - → 데이터센터 간 네트워크 지연은 사용자에게 숨겨진다.
- 데이터센터 중단 내성
    - 단일 리더 설정
        - 리더가 있는 데이터센터가 고장 나면 장애 복구를 위해 다른 데이터센터에서 한 팔로워를 리더로 승진시킨다.
    - 다중 리더 설정
        - 데이터센터는 다른 데이터센터와 독립적으로 동작하고 고장 난 데이터센터가 온라인으로 돌아왔을 때 복제를 따라잡는다.
- 네트워크 문제 내성
    - 데이터센터 간 트래픽은 보통 공개 인터넷을 통해 처리한다. 그래서 데이터센터 내의 로컬 네트워크보다 안정성이 떨어진다.
    - 단일 리더 설정
        - 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감하다.
    - 다중 리더 설정
        - 비동기 복제를 사용 경우 네트워크 문제에 보다 잘 견긴다. 일시적인 네트워크 중단에도 쓰기 처리는 진행되기 때문이다. → 어려움

**다중 리더 복제 단점**

- 동일한 데이터를 다른 두 개의 데이터센터에서 동시에 변경할 수 있다. 이때 발생하는 쓰기 충돌은 반드시 해소해야 한다.
- 자동 증가 키, 트리거, 무결성 제약은 문제가 될 소지가 많다.

### 1-2) 오프라인 작업을 하는 클라이언트

다중 리더 복제가 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우

이런 종류의 다중 리더 설정을 쉽게한 도구가 있다. (ex. Couch DB)

### 1-3) 협업 편집

동시에 여러 사람이 문서를 편집할 수 있는 애플리케이션을 실시간 협업 편집 애플리케이션이라 한다. 협업 편집은 오프라인 편집 사용 사례와 공통점이 많다.

문서를 편집할 때 변경 내용을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다. **편집 충돌이 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 한다.** 다른 사용자가 같은 문서를 편집하려면 첫 번째 사용자의 변경이 커밋되고 잠금이 해제될 때까지 기다려야 한다. **→ 리더에서 트랜잭션을 사용하는 단일 리더 복제와 비슷하다.**

**더 빠른 협업을 위해서는 변경 단위를 매우 작게해서 잠금을 피할수 있다.** 여러 사용자가 동시에 편집할 수 있지만 충돌 해소가 필요한 경우를 포함해 **다중 리더 복제에서 발생하는 모든 문제를 야기한다.**

## 2) 쓰기 충돌 다루기

**다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다.**

아래 상황은 단일 리더 데이터베이스에서는 일어나지 않지만 다중 리더 복제에서는 발생할 수 있다.

![image](https://github.com/user-attachments/assets/995a3a10-6622-42a6-81cc-b87858117ead)

### 2-1) 동기 대 비동기 충돌 감지

- 단일 리더 설정
    - 첫 번째 쓰기가 완료될 때까지 두 번쨰 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해 사용자가 쓰기를 재시도하게 한다.
- 다중 리더 설정
    - 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지한다.
    - 사용자에게 충돌을 해소하게끔 요청하면 너무 늦을 수 있다.
    - → 이론적으로 충돌 감지는 동기식으로 만들 수 있다. 쓰기 성공 사실을 사용자에게 말하기 전에 모든 복제 서버가 쓰기를 복제하기를 기다린다. 하지만 이렇게 하면 다중 리더 복제의 주요 장점을 잃는다. **동기식으로 충돌 감지를 하려면 단일 리더 복제만 사용해야 할 수도 있다.**

### 2-2) 충돌 회피

**충돌을 처리하는 제일 간단한 전략은 충돌을 피하는 것이다.** 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다. (많은 다중 복제 구현 사례에서 충돌을 잘 처리하지 못하기 때문에 충돌을 피하는 것이 자주 권장되는 방법이다.)

하지만 한 데이터센터가 고장 나서 트래픽을 다른 데이터센터로 다시 라우팅해야 하거나 사용자가 다른 지역으로 이동해 현재는 다른 데이터 센터가 가깝다면 레코드를 위해 지정된 리더를 변경하고 싶을 수도 있다. 이런 상황에서는 충돌 회피가 실패한다. **다른 리더에서 동시 기록 가능성을 대처해야 한다.**

### 2-3) 일관된 상태 수렴

- 단일 리더 설정
    - 순차적인 순서로 쓰기를 적용한다.
- 다중 리더 설정
    - **쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.**
    - 모든 복제 계획은 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야 한다. 따라서 데이터베이스는 수렴 방식으로 충돌을 해소해야 한다. 이는 모든 변경이 복제돼 모든 복제 서버에 동일한 최종 값이 전달되게 해야 한다는 의미다.
- 해소 방법
    - **최종 쓰기 승리 (LWW, last write wins** → timestamp 사용하는 경우)
        - 각 쓰기에 고유 ID(timestamp, uuid, 긴 임의 숫자, 키와 값의 해시값)를 부여하고 가장 높은 ID(승자)를 가진 쓰기를 고른다. 다른 쓰기는 버린다.
    - 각 복제 서버에서 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생신 쓰기가 낮은 복제 서버에서 생신 쓰기보다 항상 우선적으로 적용되게 한다. **→ 데이터 유실 가능성이 있다.**
    - 어떻게든 값을 병합한다.
    - 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존한다. **→ 나중에 충돌을 해소하는 애플리케이션 코드를 작성한다.**

### 2-4) 사용자 정의 충돌 해소 로직

충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르다. 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.

- 쓰기 수행 중
    - 복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출한다. 핸들러는 일반적으로 사용자에게 충돌 내용을 표시하지 않는다. 그리고 백그라운드 프로세스에서 빠르게 실행돼야 한다.
- 읽기 수행 중
    - 충돌을 감지하면 모든 충돌 쓰기를 저장한다. 다음 번 데이터를 읽을 때 이런 여러 버전의 데이터가 애플리케이션에서 반환된다. 애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소할 수 있다. 충돌을 해소한 결과는 다시 데이터베이스에 기록한다. (ex. Couch DB)

충돌 해소는 보통 전체 트랙잭션이 아니라 개별 로우나 문서 수준에서 적용된다. 원자적으로 여러 다른 쓰기를 수행하는 트랜잭션이라면 각 쓰기는 충돌 해소를 위해 여전히 별도로 간주된다.

**자동 충돌 해소**

- **충돌 없는 복제 데이터타입(conflict-free replicated datatype)**
    - set, map, 정렬 목록, 카운터 등을 위한 데이터 구조의 집합
    - 동시에 여러 사용자가 편집할 수 있다.
    - 충돌을 자동으로 해소할 수 있다.
- **병합 가능한 영속 데이터 구조(mergeable persistent data structure)**
    - git 버전 제어 시스템과 유사하게 명시적으로 히스토리를 추적한다.
    - 삼중 병합 함수(three-way merge function)를 사용한다.
- **운영 변환(operational transformation)**
    - 이더 패드, 구글 독스 같은 협업 편집 애플리케이션의 충돌 해소 알고리즘
    - 텍스트 문서를 구성하는 문자 목록과 같은 정렬된 항목 목록의 동시 편집을 위해 설계됐다.

### 2-5) 충돌은 무엇인가?

- 명백한 충돌
    - 동일한 레코드의 동일한 필드를 동시에 수정해 두 개의 다른 값으로 설정
- 감지하기 어려운 충돌
    - 회의실 예약 시 동시에 두 개의 다른 예약이 생기면 충돌이 발생한다. 이 두 예약이 각기 다른 리더에서 이뤄지면 충돌이 발생할 수 있다.

## 3) 다중 리더 복제 토폴로지

- 복제 토폴로지
    - 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로

다중 리더 복제 설정하는 세 가지 토폴로지

- 원형 토폴로지
    - 각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기를 다른 한 노드에 전달한다.
    - MySQL은 기본적으로 원형 토폴로지를 제공한다.
- 별 모양 토폴로지
    - 모든 복제 서버에 도달하기 전에 여러 노드를 거쳐야 한다. 노드들은 다른 노드로부터 받은 데이터 변경 사항을 전달해야 한다.
    - 무한 복제 루프를 방지하기 위해 각 노드에는 고유 식별자가 있다.
    - 복제 로그에서 각 쓰기는 거치는 모든 노드의 식별자가 태깅된다.
    - 노드가 데이터 변경 사항을 받았을 때 자신의 식별자가 태깅된 경우에는 노드가 이미 처리한 사실을 알기 때문에 데이터 변경 사항을 무시한다.
- 전체 모양 토폴로지
    - 모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송한다.

단일 장애점

- 원형 토폴로지, 별 모양 토폴로지
    - 문제: 하나의 노드에 장애가 발생하면 장애가 다른 노드 간 복제 메시지 흐름에 방해를 준다. 해당 노드가 복구될 떄까지 통신을 할 수 없다.
    - 해결: 토폴로지는 장애 노드를 회피하게끔 설정할 수 있다. 하지만 배포에서 이런 재설정을 수동으로 해야 한다. 메시지가 여러 경로를 따라 이동할 수 있으면 단일 장애점을 피할 수 있기 때문에 조금 더 빽빽하게 연결한 토폴로지의 내결함성이 더 좋다.

메시지 추월 문제

![image](https://github.com/user-attachments/assets/689dab07-001e-4dba-b0c1-11bbff086568)

- 전체 연결 토폴로지
    - 일부 네트워크 연결이 다른 연결보다 빠르다면 일부 복제메시지가 다른 메시지를 추월할 수 있다.
    - 이러한 이벤트들을 올바르게 정렬하기에 충분할 정도로 노드의 시간이 동기화됐다고 신뢰할 수 없기 때문에 발생한다. 이벤트를 올바르기 정렬하기 위해 버전 벡터라고 하는 기법을 사용할 수 있다.

많은 다중 리더 복제 시스템에서 충돌 감지 기법은 제대로 구현되지 않았다. 다중 리더 복제 시스템을 사용하려면 이런 문제를 인지하고 문서를 주의 깊게 읽고 철저하게 테스트해보자.

# 4. 리더 없는 복제

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용한다. 리더 없는 복제는 **다이나모 스타일**이라고 한다. (ex. 리악, 카산드라, 볼드모트)

일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 **코디네이터 노드(coordinator node)**가 클라이언트를 대신해 이를 수행하기도 한다. **리더 데이터베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않고 이러한 설계에서의 차이는 데이터베이스 사용 방식에 중대한 영향을 미친다.**

## 1) 노드가 다운됐을 때 데이터베이스에 쓰기

![image](https://github.com/user-attachments/assets/19ea1b14-119b-49b1-a042-23b71e7d1b88)

세 개의 복제 서버에서 한 개의 복제 서버가 장애가 있어 쓰기를 놓친다. 하지만 클라이언트가 데이터베이스에서 읽을 때 하나의 복제 서버가 아닌 읽기 요청을 병렬로 여러 노드에 전송한다. 그러면 클라이언트는 여러 노드에서 다른 응답을 받을 수 있고 버전 숫자를 사용해 어떤 값이 최신 내용인지 결정한다.

### 1-1) 읽기 복구와 안티 엔트로피

복제 계획은 최정적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다. 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 따라 잡는 두 가지 메커니즘이 있다.

- 읽기 복구
    - 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다. 클라이언트는 이 사실을 알고 해당 복제 서버에 새로운 값을 다시 기록한다. → 접근 방식이 값을 자주 읽는 상황에 적합하다.
- 안티 엔트로피 처리
    - 일부 데이터스토어는 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.
    - 리더 기반 복제에서의 복제 로그와 달리 이 안티 엔트로피 처리는 특성 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

### 1-2) 읽기와 쓰기를 위한 정족수

- w + r > n 일 때 최신 값을 얻을 것으로 기대한다.
    - n개의 복제 서버
    - w개의 노드에서 성공해야 쓰기 확정
    - 모든 읽기는 최소한 r개의 노드에 질의해야한다.

다이나모 스타일 데이터베이스에서 n, w, r 파라미터는 대게 설정 가능하다. 상황에 따라 숫자를 바꾸도록 하자.

- w < n : 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
- r < n : 노드 하나를 사용할 수 없어도 여전히 읽기가 가능하다.
- n = 3, w = 2, r = 2이면 사용 불가능한 노드 1개 용인한다.
- n = 5, w = 3, r = 3이면 사용 불가능한 노드 2개를 용인한다.

일반적으로 읽기와 쓰기는 항상 모든 n개의 복제 서버에 병렬 전송한다. 파라미터 w, r은 얼마나 많은 노드를 기다릴지 결정한다.

## 2) 정족수 일관성의 한계

n개의 복제 서버가 있고 w + r > n이 되게끔 w와 r을 선택하면 일반적으로 모든 읽기는 키의 최신값을 반환할 것을 기대 한다. 보통 r, w 값은 노드의 과반수(n/2초과)를 선택한다.

하지만 w + r > n인 경우에도 오래된 값을 반환하는 에지 케이스가 있다. (구현에 따라 다르다.)

- 느슨한 정족수를 사용한다면 w개의 쓰기는 r개의 읽기와 다른 노드에서 수행될 수 있으므로 r개의 노드와 w개의 노드가 겹치는 것을 보장하지 않는다.
- 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다. 안전한 해결책은 동시 쓰기를 합치는 방법밖에 없다. 승자가 timestamp를 기반으로 결정되면 clock skew로 인해 쓰기가 유실될 수 있다.
- 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다. 이 경우 읽기가 예전 값과 최신 값을 반환하는지 여부가 문명하지 않다.
- 쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해 전체에서 성공한 서버가 w 복제 서버보다 적다면 성공한 복제 서버에서는 롤백하지 않는다. 이는 쓰기가 실패한 것으로 보고되면 이어지는 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다.
- 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨진다.
- 모든 과정이 올바르게 동작해도 시점 문제로 에지 케이스가 있을 수 있다.

정족수가 읽기 시 최근에 쓴 값을 반환하게끔 보장하지만 실제로는 간단하지 않다. 다이나모 스타일 데이터베이스는 일반적으로 최종적 일관성을 허용하는 사용 사례에 맞게 최적화됐다. 하지만 매개변수 w, r로 **오래된 값을 읽는 확률을 조정할 수 있지만 이를 절대적으로 보장할 수는 없다.**

특히 보장을 복제 지연 문제로 인해 보장을 대게 받을 수 없기 때문에 앞서 언급한 이상 현상이 애플리케이션에서 발생할 수 있다. **견고한 보장은 일반적으로 트랜잭션이나 합의가 필요하다.**

### 2-1) 최신성 모니터링

운영 관점에서 볼 때 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링하는 일은 중요하다. 애플리케이션이 오래된 값 읽기를 허용하더라도 복제 상태에 대해 알아야 한다. 복제가 명확히 뒤처진다면 원인을 조사할 수 있게 알려줘야 한다.

## 3) 느슨한 정족수와 암시된 핸드오프

적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.

하지만 정족수는 내결함성이 없다. 이러한 경우 데이터베이스 설계자는 트레이드 오프에 직면한다.

- 느슨한 정족수
    - 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지 않지만 연결할 수 있는 노드에 기록하기
    - 장점: 쓰기 가용성을 높이는데 유용하다.
    - 단점: w + r > n인 경우에도 키의 최신 값을 읽는다고 보장하지 않는다. → 암시된 핸드오프가 완료될 때까지는 r 노드의 읽기가 저장된 데이터를 본다는 보장은 없다.
- 암시된 핸드오프
    - 네트워크 장애 상황 해제 시 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 “홈”노드로 전송한다.

### 3-1) 다중 데이터센터 운영

리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터센터 운영에 적합하다.

- 카산드라, 볼드모트
    - 각 데이터센터마다 n개의 복제 서버 중 몇 개를 보유할지 지정할 수 있다.
    - 클라이언트의 각 쓰기는 데이터센터와 상관없이 모든 복제 서버에 전송된다.
    - 클라이언트는 로컬 데이터센터 안에서 정족수 노드의 확인 응답을 기다리기 때문에 데이터센터 간 연결의 지연과 중단에 영향을 받지 않는다.
    - 다른 데이터센터에 대한 높은 지연 시간의 쓰기는 설정에 어느 정도 유연성이 있지만 대개 비동기로 발생하게끔 설정한다.
- 리악
    - 클라이언트와 데이터베이스 간 모든 연결이 하나의 데이터센터의 로컬에서 이뤄지게 한다.
    - n은 하나의 데이터센터 안에 있는 복제 서버 수를 나타낸다.
    - 데이터베이스 클러스터들의 데이터센터 간 복제는 백그라운드에서 비동기로 일어나며 방식은 다중 리더 복제와 유사하다.

## 4) 동시 쓰기 감지

다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 **엄격한 정족수를 사용하더라도 충돌이 발생**한다.

문제는 다양한 네트워크 지연과 부분적인 장애 때문에 **이벤트가 다른 노드에 다른 순서로 도착할 수 있다는 것**이다.

![image](https://github.com/user-attachments/assets/9966dfb3-f2a4-4389-b457-4f73f83b4fb7)

최종적인 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 한다. 복제된 데이터베이스가 자동으로 처리하지는 못하고 **데이터 손실을 피하기 위해 애플리케이션 개발자는 데이터베이스 내부에서 충돌을 어떻게 다루는지 알아야 한다.**

### 4-1) 최종 쓰기 승리(동시 쓰기 버리기)

- 최종 쓰기 승리
    - 각 복제본이 가진 예전 값을 버리고 가장 최신 값으로 덮어쓰는 방법
    - 어떤 쓰기가 최신인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복제본은 최종적으로 동일한 값으로 수렴한다.

하지만 어떤 이벤트가 먼저 발생했는지 확실하게 알 수 없다.

임의로 순서를 정할 수는 있는데 예를 들어 timestamp를 붙여서 처리한다. 하지만 이러한 방식은 지속성을 희생한다. 동일한 키에 여러 번의 동시 쓰기가 있다면 클라이언트에게 모두 성공으로 응답하더라도 실제로 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시된다.

손실 데이터를 허용하지 않는다면 유일한 방법은 키를 한 번만 쓰고 이후에는 불변 값으로 다루는 방식이다.

### 4-2) “이전 발생” 관계와 동시성

두 가지 작업이 동시에 수행됐는지 여부 결정

- **인과성이 있는 케이스 (causally dependent)**
    - B 작업은 A 작업의 기반이므로 B 작업은 나중에 발생해야 한다.
    - A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 **이전 발생(happens-before)**이라고 한다.

![image](https://github.com/user-attachments/assets/73af6883-fefa-433f-b050-42e0806654f8)

- **인과성이 없는 케이스**
    - 각 클라이언트가 작업을 시작할 때 다른 클라이언트가 동일한 키에 대한 작업을 수행했는지 알지 못한다.
    - 사실 작업이 다른 작업보다 먼저 발생하지 않으면 **동시 작업**이라고 한다.

![image](https://github.com/user-attachments/assets/c5b1f82b-0b10-4e36-8df7-b4dca389e5da)

- **동시성, 시각, 상대성**
    - 두 작업이 같은 시각에 발생하면 두 작업이 동시에 호출된 것으로 볼 수 있다.
        - 하지만 두 작업이 정말로 시간적으로 겹쳐졌는지 여부는 중요하지 않다.
    - **동시성을 정의하기 위해 정확한 시간은 중요하지 않다.**
        - 두 작업이 발생한 물리적인 시각보다 각 작업이 서로 알지 못하면 단순히 두 작업은 동시에 수행됐다 말한다.

### 4-3) 이전 발생 관계 파악하기

- 두 작업이 동시에 발생했는지 또는 하나가 이전에 발생했는지 여부를 결정하는 알고리즘

클라이언트는 서버 데이터와 동일한 최신 상태로 유지하지 못한다. 항상 다른 작업이 동시에 수행됐기 때문이다. 하지만 최종적으로는 예전 버전의 값을 덮어쓰기 때문에 손실된 쓰기는 없다.

쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다. 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다.

(단일 복제 예시)

![image](https://github.com/user-attachments/assets/d459debb-3751-4b2e-b629-0878262d227f)

![image](https://github.com/user-attachments/assets/af46f937-4d12-4414-b210-d42a368c9d57)

### 4-4) 동시에 쓴 값 병합

- **동시에 쓴 값 병합**
    - 어떤 데이터도 자동으로 삭제되지 않음을 보장하지만 클라이언트가 추가적으로 작업을 수행해야 한다.

**다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같다.** 간단한 접근 방식으로 버전 번호, timestamp 기반으로 하나의 값을 선택하는 방법(최종 쓰기 승리)가 있지만 데이터 손실이 생길 수 있다. 그래서 **애플리케이션 코드 내에서 잘 대처해야 한다.**

위에 장바구니 예시를 들면

장바구니에 상품 추가뿐만 아니라 제거할 수도 있게하려면 합집합으로는 올바른 결과를 얻을 수 없다. 이 문제를 방지하기 위해서는 상품 제거 시에 해당 버전 번호에 상품을 제거했음을 표시해야 한다. 이러한 삭제 표시를 **툼스톤**이라 한다.

- **CRDT**
    - 리악의 데이터타입 지원으로 합리적인 방법으로 형제를 자동 병합시키는 데이터 구조군

### 4-5) 버전 벡터

4-3)에서는 단일 복제였는데 **다중 복제본에 리더가 없는 경우는 키당 버전 번호뿐만 아니라 복제본당 버전 번호도 사용해야 한다.**

각 복제본은 쓰기를 처리할 떄 자체 버전 번호를 증가시키고 각기 다른 복제본의 버전 번호도 계속 추적해야 한다. 이 정보로 덮어쓸 값과 형제로 유지할 값을 나타낸다.

- **도디트 버전 벡터 (dotted version vector) - 리악**
    - **도티드 버전 벡터(DVV)** 는 **버전 벡터(Version Vector)** 를 확장한 구조다.
    - 기존 버전 벡터가 "노드별 수정 횟수"만 추적했다면, DVV는 **각 수정 자체를 고유한 점(dot)으로 추적**한다.
- **dot란?**
    - **(노드 ID, 카운터)** 쌍으로 표현한다.
    - 예: (NodeA, 5) → "NodeA가 5번째로 수정한 것"이라는 의미다.
    - 각 업데이트는 고유한 dot을 가지기 때문에,
    - **여러 노드가 동시에 수정하더라도 각 수정 이력을 독립적으로 추적**할 수 있다.
