복제에는 고려해야 할 트레이드 오프가 있다. 동기식 복제, 비동기식 복제 중 어떤 것을 사용할지, 잘못된 복제본을 어떻게 처리할지다.

# 1. 리더와 팔로워

데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다. 이를 위해 리더 기반 복제가 있다. 복제 서버 중 하나를 리더로 지정하고 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그, 변경 스트림의 일부로 팔로워에게 전송한다. 각 팔로워는 리더로부터 받은 로그를 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

클라이언트는 읽기 시에 리더, 팔로워에게 질의할 수 있지만 쓰기는 리더에게만 허용한다. 이러한 리더 기반 복제는 여러 관계형 데이터베이스에 내장된 기능이다. 그리고 카프카, 래빗MQ의 고가용성 큐 같은 분산 메시지 브로커에도 사용된다.

![image](https://github.com/user-attachments/assets/dc7b7745-76ed-4ab4-a28b-c0ba23b83f23)


## 1) 동기식 대 비동기식 복제

- 동기식 복제
    - 장점: 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.
    - 단점: 임의 한 노드의 장애는 전체 시스템을 멈추게 한다.
    - 보완: 반동기식을 이용한다.(팔로워 하나는 동기식 나머지는 비동기식으로 처리)

![image](https://github.com/user-attachments/assets/5f966dea-f2c2-4c1b-81d6-d4f5b546aabb)


## 2) 새로운 팔로워 설정

새로운 팔로워가 리더의 데이터 복제본을 갖는 방법

- 리더의 데이터베이스 스냅숏을 일점 시점에 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했다고하고 그때부터 리더에 발생하는 데이터 변화를 이어 처리한다.

## 3) 노드 중단 처리

리더 기반 복제에서 고가용성 달성법

### 3-1) 팔로워 장애: 따라잡기 복구

- 보관된 로그에서 결함이 발생하기 전에 처리학 마지막 트랜잭션을 알아낸다.
- 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다. 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 3-2) 리더 장애: 장애 복구

팔로워 중 하나를 새로운 리더로 승격한다. 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.

- 리더가 장애인지 판단한다.
    - 잠재적으로 여러 문제가 있을 수 있지만 무엇이 잘못됐는지 확실한 방법이 없기 때문에 대부분의 시스템은 그냥 타임아웃을 사용한다.
- 새로운 리더를 선택한다.
    - 선출과정을 통해 이뤄지거나 이전에 선출된 제어 노드에 의해 새로운 리더가 임명될 수 있다.
- 새로운 리더 사용을 위해 시스템을 재설정한다.
    - 클라이언트는 새로운 쓰기 요청을 새로운 리더에게 보내야한다. 만약 이전 리더가 복구되면 여전히 자신이 리더라고 인식할 수 있기에 복제 서버들이 자신을 리더에서 물러나게 한 것을 알도록 해야한다.

이러한 장애 복구 과정에서는 잘못될 수 있는 것들이 많다.

- 비동기식 복제 시에 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신 못할 수 있다.
- 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 하면 위험하다.
- 두 노드가 모두 자신이 리더라고 믿는 경우가 있다. (스플릿 브레인) 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터 오염 위험이 있다.
- 리더가 죽었다고 판단 가능한 적절한 타임아웃 설정이 어렵다. 너무 짧으면 불필요한 장애복구가 일어날 수 있다.

## 4) 복제 로그 구현

### 4-1) 구문 기반 복제

리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를 실핸한 다음 구문 로그를 팔로워에게 전송한다. 팔로워는 클라이언트에게 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.

- 복제가 깨지는 경우
    - NOW(), RAND()와 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
    - 자동증가 컬럼을 사용하는 구문이 있는 경우 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다.
    - 부수 효과를 가진 구문(트리거, 스토어드 프로시저, …)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.

MySQL 5.1 이전에는 구문 기반 복제(statement-based replication)가 사용됐다. 하지만 MySQL은 이제 구문에 비결정성이 있다면 기본적으로 로우 기반 복제(row-based replication)로 변경한다.

### 4-2) 쓰기 전 로그 배송

- 로그 구조화 엔진의 경우 로그 자체가 저장소의 주요 부분이다.
- 개별 디스크 블록에 덮어쓰는 B트리의 경우 모든 변경은 쓰기 전 로그에 쓰기 떄문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용 바이트 열이다. 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다. 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.

하지만 단점으로는 로그가 제일 저수준의 데이터를 기술한다. 즉, 복제가 저장소 엔진과 밀접하게 엮이고 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

### 4-3) 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진 내부와 분리하기 위한 대안으로 다른 로그 형식을 사용하는 것이다. 이러한 복제 로그를 저장소 엔진의 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다. 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있다. 또한 외부 애플리케이션이 더 파싱하기 쉽기에 오프라인 분석, 사용자 정의 색인, 캐시 구축 등을 위해 데이터 웨어하우스 같은 시스템에 내용을 전송하고자 할 때 유용하다. (CDC)

### 4-4) 트리거 기반 복제

데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소 로직이 필요하면 복제를 애플리케이션 층으로 옮겨야 한다.

오라클 골든게이트 같은 도구는 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 한다. 다른 방법으로는 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 트리거나 스토어드 프로시저를 사용한다.

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행된다. 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 이 테이블로부터 데이터 변경을 회부 프로세스가 읽을 수 있다. 그러면 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

# 2. 복제 지연 문제

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.

## 2-1) 자신이 쓴 내용 읽기

![image](https://github.com/user-attachments/assets/0644411c-3f50-4a48-95b0-88005cf1ba12)


새로운 데이터가 제출되면 리더에게 전송해야 하지만 사용자가 데이터를 볼 때는 팔로워에서 읽을 수 있다. 이런 상황에서는 쓰기 후 읽기 일관성이 필요하다.

**리더 기반 복제 시스템에서 쓰기 후 읽기 일관성 구현**

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽고, 그 밖에는 팔로워에서 읽는다.
    - 실제 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요하다.
- 리더에서 읽을지 말지 결정하기 위해 다른 기준을 사용한다.
    - 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 대부분 리더에서 읽기 때문이다.
    - 예를 들어 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다. 또한 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
- 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억할 수 있다. 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다. 복제 서버가 최신 내용이 아닌 경우 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킬 수 있다.
- 복제 서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야 한다.
- 동일한 사용자가 여러 디바이스로 서비스를 접근하는 경우
    - 메타데이터를 중앙집중식으로 관리해야 한다. (사용자의 마지막 갱신 타임스탬프를 기억해야 하는 접근 방식이 어렵기 때문이다.)
- 복제 서버가 여러 데이터센터 간에 분산돼 있다면 각 디바이스가 동일한 데이터센터로 라우팅된다는 보장이 없다. 때문에 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다.

## 2-2) 단조 읽기

![image](https://github.com/user-attachments/assets/7b0b9143-5677-468d-8dbc-7143cb936eec)

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것이다.

단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장한다. 단조 읽기는 강한 일관성보다는 덜하지만 최종적 일관성보다는 더 강한 보장이다. 즉, 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다. 단조 읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다. 예를 들어 임의 선택이 아닌 사용자 ID의 해시를 기반으로 복제 서버를 선택하는 것이다.

## 2-3) 일관된 순서로 읽기

일관된 순서로 읽기(Consistent Prefix REad)같은 또 다른 유형의 보장이 필요하다. 일관된 순서로 읽기는 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제다. 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이상 현상이 없다. 하지만 많은 분산데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없다. 즉, 사용자가 데이터베이스에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.

## 2-4) 복제 지연을 위한 해결책

복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해보자. 사용자에게 좋지 않은 경험을 준다면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템을 설계해야 한다. 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것이 문제 해결 방안이다.
