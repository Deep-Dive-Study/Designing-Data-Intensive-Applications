# 01. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
- 오늘날 많은 어플리케이션은 계산 중심적(Computive Intensive)이기 보다는 **`데이터 중심적(Data Intensive)`** 임
  - 이러한 경우 CPU 성능 보다는 `데이터의 양`, `데이터 복잡도`, `데이터의 변화 속도`가 문제가 됨
  - 실제로 웹 백엔드 측면에서 보았을때도 CPU 보다 I/O 작업이 문제가 되는 경우가 훨씬 흔함

- 일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소로 만듬
 
#### 표준 구성 요소(Standard Build Block)
- DB(데이터베이스) : 나중에 다시 데이터를 찾을 수 있도록 데이터 저장함
- Cache(캐시) : 속도 향상을 위해 값비싼 수행 결과를 기억함
- Search Index(검색엔진) : 데이터를 검색하거나 필터링할 수 있도록함
- Stream Processing(스트림 처리) : 거의 실시간으로 데이터를 처리
- Message Broker(메시지 브로커) : 비동기 처리를 위해 다른 프로세스로 메시지를 보냄
- Batch Processing(일괄 처리) : 주기적으로 대량의 누적 데이터를 처리 및 분석함

## 데이터 시스템에 대한 생각
- 데이터 시스템이란? 데이터 베이스(DBMS), 데이터 저장소(Data Store), 메시지 큐(Message Queue), 등 과 같이 **`데이터를 저장하고 처리하는 시스템을 포괄적으로 묶어서 부르는 용어`**
- 용어를 포괄적인 의미로 묶어서 부르는 이유
  - 새로운 도구들은 점점 다양한 UseCase에 최적화되었고, 더이상 전통적인 방식으로 분류하기 어려워짐
  - 현대 애플리케이션들은 단일 도구로는 데이터 처리와 저장의 모든 요구를 충족시키기 어려워, 여러 도구를 결합하여 작업을 분산 처리하고 상호 연결하는 방식으로 복합적인 시스템을 구성하고 있음

  ![CleanShot 2025-03-15 at 01 53 06](https://github.com/user-attachments/assets/0c72cd87-9b38-4aab-bed7-70e55fbdc435)

## 신뢰성
- 신뢰성이란?
  - 일반적으로 신뢰성이라고 하는 것은 믿을 수 있는 것, 얼마나 기대하는 것을 지속적으로 만족하는지를 의미함
  - 그렇다면 소프트웨어에서의 신뢰성이 의미하는 것은 사용자/개발자가 소프트웨어(시스템)에 기대하는 바를 지속적으로 만족하는지를 나타낸다고 할 수 있음

- 사용자가 가진 소프트웨어에게 일반적으로 기대하는 바
  - 애플리케이션은 사용자가 기대한 기능을 수행함
  - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용함
  - 시스템 성능은 예상된 부하와 데이터 앙에서 필수적인 사용 사례를 충분히 만족함
  - 시스템은 허가되지 않은 접근과 오남용을 방지함

- 즉, 소프트웨어에서의 신뢰성은 **`무언가 지속적으로 올바르게 동작`** 하는 속성을 의미 

- 결함을 예측하고 대처할 수 있는 시스템을 `내결함성` 또는 `탄력성`을 지녔다고 말함
  - 결함은 잘못될 수 있는 일을 의미
  - 모든 종류의 결함을 견딜 수 있는 시스템은 실현 불가능 → 특정 유형의 결함 내성에 대해서만 판단
  - 즉, 발생 가능한 문제(예외)적인 상황을 고려해서 대응 가능하도록 할 수록 내결함성이 뛰어난 소프트웨어라고 할 수 있음 

- `결함`과 `장애`는 다름
  - 장애는 `사용자에게 필요한 서비스를 하지 못하고 시스템 전체가 멈춘 경우`
  - 결함이 장애로 이어질 수 있음. 반드시 그러한 것은 아님
  - 즉, 결함이 장애로 이어지지 않도록 설계/대비하는 것이 중요함

### 하드웨어 결함
- 하드웨어(물리적 기계)는 늘상(얼마든지) 결함이 발생 가능함
  - 불량, 물리적 충격, 노화 등

- 하드웨어 장비 결함을 대비하는 방법은 **`각 하드웨어 구성 요소에 중복을 추가`** 하는 것임
    - RAID 구성(백업), 예비 부품 구축, 등
    - 단일 장애는 흔한일이지만, 동시에 같은 장비에서 결함이 발생하는 경우는 드뭄

- 하드웨어 결함의 특징은 `무작위적`이고 `서로 독립적`임

### 소프트웨어 오류
- 소프트웨어 결함은 `시스템 내 체계적 오류(systematic error)`인 경우가 많음
  - 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않고, 예상하기 어려움
  - 신속하게 해결하기 어려움

- 소프트웨어 결함은 신속하게 해결하기 어렵기 때문에 예방적인 측면에서 `결함률을 낮추는 방식으로 대응`해야함
  - 가정과 상호작용에 대해 주의 깊게 생각하기
  - 빈틈없는 테스트
  - 프로세스 격리
  - 프로세스 재시작 허용
  - 시스템 동작의 모니터링 및 분석

### 인적오류
- 사실 인간은 기계보다 정밀하거나 일정하지 않은 경우가 많기 때문에, 오류 발생률이 높은 편
- 인간 오류를 대응하기 위해 다양한 방식을 결합하는 것이 좋음
  - 오류의 가능성을 최소화하는 방향으로 시스템을 설계
  - 사람의 실수로 장애가 발생할 수 있는 부분을 분리
  - 인적 오류를 빠르고 쉽게 복구할 수 있도록 준비
  - 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
  - 조작 교육과 실습을 시행 

### 신뢰성은 얼마나 중요할까?
- 신뢰성이 매우 중요한 분야의 소프트웨어 뿐만 아니라 일반 비즈니스 애플리케이션 또한 신뢰성은 매우 중요함
- 신뢰성을 저하시키는 버그는 생산성 저하의 원인이 됨
- 비즈니스 측면에서도 사용자의 만족도를 저하시키고 매출 하락에 영향을 줌 

## 확장성
- 확장성은 **`증가한 부하에 대처하는 시스템 능력`**
  - 일차원적으로 확장성이 있다/없다 혹은 얼마나 된다와 같이 표식할 수는 없음
  - 시스템이 특정 방식으로 커지면 이를 대처하기 위한 선택이 무엇인지 고려한다는 의미

### 부하 기술하기
- 확장성을 고려하기 위해서는 무엇보다도 **`현재 상태 기술`** 해야함(기준점이 필요)
- 시스템의 부하는 `부하 매개변수(load parameter)`를 통해 숫자로 나타낼 수 있음
  - 초당 요청 수
  - DB 읽기/쓰기 비율
  - 활성 사용자 수
  - 캐시 적중률
  - 등등  

- 이러한 지표들은 평균치, 피크치, 패턴, 등 **중요한 지점은 다를 수 있음**
- 또한, 애플리케이션 마다 유의미한 활동 패턴에 따른 지표가 다를 수 있음
  - 예를 들어, 트위터는 트윗 작성, 홈 타임라인 같이 복합적인 지표가 있음

- 부하를 기술하면 **`기준점으로 부터 부하를 증가시켜가면서 어떤 일이 발생하는지 조사할 수 있음`**
  - 부하가 증가할때 성능은 어떻게 변화하는지
  - 부하 증가에 따라 동일한 성능을 유지하려면 자원이 얼마나 필요한지 

### 성능 기술하기
- 배치 처리 시스템(OLAP 시스템)
  - 주로 `처리량(throughput)`, 즉 초당 처리 가능한 레코드 수나 전체 작업 처리 시간에 관심
- 온라인 시스템(OLTP의 일반 어플리케이션)
  - `서비스 응답 시간(response time)`이 핵심 지표로, 클라이언트가 요청을 보내고 응답받는 데 걸리는 시간

- 응답 시간은 단일 숫자가 아니라 `측정 가능한 값의 분포`로 생각해야 함
  - 대부분의 요청은 정상적으로 처리되지만, `특이값(outlier)`에 의해 평균치가 왜곡될 수 있음
  - 그래서 최근 APM 도구에서는 응답 시간을 **백분위수(p50, p90, p99)** 로 표기해 보다 실제 사용자 경험을 반영함
  - 특히, `꼬리 지연(tail latency)`은 사용자 경험에 큰 영향을 미치므로, 99.9분위(p99.9)까지 모니터링하는 경우도 있음(20:80 법칙)

    ![CleanShot 2025-03-16 at 20 33 37@2x](https://github.com/user-attachments/assets/e86377f6-4df6-410c-9c58-882d56cda76f)

- 이러한 백분위는 `SLO(서비스 수준 목표)`, `SLA(서비스 수준 협약서)`에서 기대 성능과 서비스 가용성을 정의하는 기준으로 자주 사용됨
  - 예를 들어, **"응답 시간 중앙값(p50)이 200ms 미만이고, p99이 1초 미만일 것"** 과 같은 기준이 SLA에 포함될 수 있음
	- SLA를 준수하지 못할 경우에 환불 정책 같은 정책에도 적용될 수도 있음
  - 아마존 같은 대형 서비스는 99.9분위 응답 시간 기준을 유지하는 것을 목표로 삼지만, 99.99분위(p99.99)까지 최적화하는 것은 비용 대비 효과가 크지 않아 일반적으로 고려하지 않음

- 큐 대기 지연(queueing delay)와 선두 차단(head-of-line blocking) 같은 현상으로 인해, 부하가 증가할수록 상위 백분위 응답 시간이 급격히 증가할 수 있음
  - 클라이언트가 여러 요청을 보내는 경우, 한 개의 느린 응답이 전체 서비스 경험을 저하시킬 가능성이 높아짐(꼬리 지연 증폭 효과)

    ![CleanShot 2025-03-16 at 20 55 11@2x](https://github.com/user-attachments/assets/9a94248e-7e1a-40d5-8934-640afce86ab3)

- 백분위를 효과적으로 측정하려면 단순 평균이 아니라 적절한 백분위 근사 알고리즘을 사용해야 함
  - 대표적인 방법으로 t-digest, HdrHistogram, forward decay 등이 있으며, 메모리와 CPU 비용을 최소화하면서도 정확한 추정이 가능함
	- 잘못된 방식으로 백분위를 평균 내거나 여러 장비의 데이터를 단순 병합하면 오차가 발생할 수 있으므로, 올바른 히스토그램 기반 집계 방식을 고려해야 함

### 부하 대응 접근 방식
- 시스템 확장 방법
  - **`스케일 업(용량 확장, 수직 확장)`**
    - 단일 장비의 스펙 업
    - 빠르고 간편하지만 가격이 비쌈

  - **`스케일 아웃(규모 확장, 수평 확장)`**
    - 여러 장비로 부하를 분산(비공유 아키텍처)
    - 아키텍처에 변경이 필요하고, 고려해야하는 요소가 많아지나 가격이 상대적으로 저렴함
    - 부하를 알 수 없거나, 부하의 편차가 큰 경우에도 탄력적으로 운용이 가능함

- 적합한 확장 방식은 현재 상황(현재 아키텍처, 조직 구성원, 비즈니스 목표,등)에 따라 다름 

## 유지 보수성
- 소프트웨어는 **초기 개발보다 유지보수에 들어가는 비용이 더 많음**
  - 유지보수 작업은 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 기능 추가, 등을 의미함

### 운용성: 운영의 편리함 만들기
- 시스템이 지속해서 원활하게 작동하려면 운영 요소가 필수임
  - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
  - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
  - 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
  - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
  - 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(예를 들어 용량 계획)
  - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
  - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
  - 설정 변경으로 생기는 시스템 보안 유지보수
  - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
  - 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함 

- 좋은 운영성이란 **`동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중`** 한다는 의미
  - 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
  - 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원을 제공
  - 개별 장비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
  - 좋은 문서와 이해하기 쉬운 운영 모델(예를 들어 "X를 하면 가 발생한다”) 제공
  - 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
  - 적절하게 자기 회복(self-healing)이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
  - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함 

### 단순성: 복잡도관리
- 프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워짐
  - 개발자들의 생산성이 저하되고, 테스트하기 어렵고, 문제가 발생하기 쉬워짐 

- 복잡도는 다양한 증상으로 발현됨
  -  모듈 간 강한 결합
  -  복잡한 의존 관계
  -  일관성 없는 코드 규칙
  -  임시 방편으로 문제를 해결한 특수 케이스

- 복잡도는 `예산과 일정을 초과하게 만드는 원인`

- 시스템을 단순하게 한다는 것은 **`우발적 복잡도`** 를 줄인다는 뜻
  - 소프트웨어가 풀어야 할 문제가 아니고 구현에서만 발생하는 문제

 - 시스템을 단순하게 하기 위한 최상의 도구는 **`추상화`**
   - 복잡한 것을 숨길 수 있음
   - 큰 시스템의 일부를 잘 정의되고 재사용 가능한 구성 요소로 추출할 수 있게함 

### 발전성: 변화를 쉽게 만들기
- 시스템의 요구사항은 끊임 없이 변할 가능성이 큼
- 데이터 시스템 변경을 쉽게 하고 변화된 요구 사항에 시스템을 맞추는 방법은 `시스템의 간단함`과 `추상화`와 밀접한 관련이 있음
  - 또한, 리팩토링, 애자일, 등도 이러한 변화에 대응하기 위한 요소 

## 정리 및 나의 생각

### 소프트웨어에서 중요한 것들에 대해 생각해보자
- 효율성
  - 응답 속도, 동시 처리량
- 유지보수성
  - 확장성, 호환성, 가독성
- 내결함성
  - 가용성 
- 관찰가능성
- 보안성
