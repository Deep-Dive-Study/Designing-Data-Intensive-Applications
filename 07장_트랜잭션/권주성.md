# 07. 트랜잭션
- **`데이터 시스템은 얼마든지 여러가지 문제가 생길 수 있음`**
  - 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있음
  - 애플리케이션은 언제라도 죽을 수 있음
  - 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 통신이 안될 수 있음
  - 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있음
  - 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있음
  - 클라이언트 사이 경쟁 조건은 예측하지 못한 버그를 유발할 수 있음

- 시스템이 신뢰성을 지니기 위해서는 이러한 결함을 처리하여, 전체 시스템 장애로 이어지지 않도록 해야함
- 트랜잭션은 이런 문제를 단순화하는 매커니즘으로, **`여러 작업을 하나의 논리적 작업 단위로 묶음`**
  - 전체 작업이 성공(커밋), 실패(롤백)하도록 보장함(원자성)
  - 이는, 어플리케이션에서 오류를 처리하기 쉬워짐(부분적인 실패를 걱정할 필요 X)

- 트랜잭션을 사용함으로써, 애플리케이션에서 어느 정도 잠잭적인 오류 시나리오와 동시성 문제를 무시할 수 있음
  - 이를 `안전성 보장(safety guarantee)`이라고 함 

- **그렇다고 해서 모든 어플리케이션에 트랜잭션이 필요한 것은 아님**
- 트랜잭션이 필요한 경우를 알기 위해서는 트랜잭션이 제공하는 안정성 보장에는 어떤 것이 있는지, 이와 연관되는 비용이 무엇인지 이해해야함

## 애매모호한 트랜잭션 개념
- 많은 NoSQL DB는 복제, 파티션닝 기능을 제공하는 대신 트랜잭션의 기능을 포기하거나, 훨씬 약한 보장을 의믜하는 단어로 트랜잭션의 의미를 재정의하였음
- 분산 데이터베이스가 유행하면서, 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 퍼졌으며, 반대로 트랜잭션은 값진 데이터가 있는 중대한 어플리케이션에서는 필수적인 요구사항이라고 주장되어 왔음
- 하지만, 이러한 두가지 관점 모두 과정되었으며, 트랜잭션의 트레이드오프 관계와 이점과 한계를 명확히 알아야 올바른 선택을 할 수 있음

### ACID 의미
- 트랜잭션이 제공하는 안정성 보장의 4가지 속성을 의미하는 약어
  - `원자성(Atomicity)`
  - `일관성(Consistency)`
  - `격리성(Isolation)`
  - `지속성(Durability)`

- 그러나 현실에서는 데이터베이스마다 ACID의 구현이 제각각임
  - 예를들어, 각 DB마다 제공하는 격리성 레벨과 정의가 다르고, 모호함 

- ACID를 따르지 않는 시스템(Ex. NoSQL)은 때로 `BASE 모델`을 채택함
  - 기본적으로 가용성 제공(Basically Available)
  - 유연한 상태(Soft state)
  - 최종적 일관성(Eventual consistency)

#### 원자성
- 원자적이란 쪼갤 수 없는 것을 의미함
  - 동시성과는 관련이 없음

- 원자성은 **`쓰기 작업에서 결함이 생겨 완료(커밋)될 수 없다면 어보트(롤백) 시켜 트랜잭션의 작업이 중간 상태에 머무르지 않는 것을 보장하는 속성`**

- 원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 적용되었고, 어떤 것은 변경되지 않았는지 알기가 어려움
  - 재시도하였을때, 중복되거나 잘못된 데이터가 만들어질 수 있음

- 즉, `어보트 능력(abortability)`으로 봐도 무방함
  - 원자적 = 오류시 롤백할 수 있음 

#### 일관성
- 일관성은 다양한 영역에서 다양한 의미로 쓰임
  - 복제 일관성, 최종적 일관성, 일관성 해싱, 등등
 
- ACID에서 일관성은 **`'좋은 상태'에 있어야 한다는 애플리케이션에 특화된 개념임`**
- 데이터가 올바름을 보장하는 속성(일관성 = 유효성)
- 데이터베이스에는 외래키 제약 조건, 유일성 제약 조건, 등을 통해 일부 특정 유효성을 보장할 수 있도록 기능을 제공하긴 하지만, 유효하지 않은 데이터를 쓰는 것은 전적으로 애플리케이션에서 책임임
  - 제약 조건에 한해서는 조건을 만족하도록 유효성을 보장함
  - 그렇지만 데이터 베이스의 속성이 아닌 애플리케이션 속성이라고 보기 때문에 ACID로 같이 묶지 않는 것이 맞음

#### 격리성
- 동일한 데이터베이스에서 동일한 데이터에 동시에 접근하면 동시성 문제(경쟁 조건)이 발생할 수 있음
- 격리성은 `동시에 실행되는 트랜잭션은 서로 격리되어 실행되는 것`을 의미함
  - 즉, **`한 트랜잭션의 작업은 다른 트랜잭션에 의해 영향을 받지 않고 작업이 수행됨을 보장하는 속성`**

- 직렬성(Serializable)으로 불리기도 하는데, 이는 여러 트랜잭션이 동시에 실행되었더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행되었을때의 결과와 동일함을 보장함을 의미
  - 다만, 현실에서는 직렬성 격리 수준은 성능 오버헤드로 인해 거의 사용되지 않음
  - 한번에 하나의 스레드만 작업할 수 있기 때문에 동시성을 해치게 되는 경우가 많음
  
  ![CleanShot 2025-05-11 at 04 09 19](https://github.com/user-attachments/assets/9cc07e4f-425c-4cb3-a607-1113953bb81c)

#### 지속성
- **`트랜잭션이 성공적으로 커밋되었을 경우, 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에 기록한 모든 데이터는 손실되지 않음을 보장하는 속성`**
  - 즉, 한번 쓴 데이터는 비휘발성 저장소에 기록되어 잃어버리지 않도록 해야함

- 보통 데이터베이스는 쓰기 전 로그(WHL)나 비슷한 수단을 통해 기록 후 반영하도록 구현이 되어 있음
- 복제 기능이 있는 데이터베이스에서의 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미함

### 단일 객체 연산과 다중 객체 연산
- ACID의 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 알려줌
  - **`원자성`** : 쓰기에 실패하면 트랜잭션은 어보트 되어야함. DB에는 전부 반영되거나 아무것도 반영되지 않음을 보장함(부분 실패는 안됨)

    ![Goodnotes 2025-05-11 04 23 22](https://github.com/user-attachments/assets/f9e69fcc-4891-492f-9580-497ff5eb28d5)

  - **`격리성`** : 동시에 실행되더라도 서로 방해하지 말아야 함. 다른 트랜잭션은 그 내용을 모두 볼 수 있거나, 아무것도 볼 수 없든지 둘 중 하나만 해야함.(일부분만 보이거나 하면 안됨)

    ![CleanShot 2025-05-11 at 04 23 00](https://github.com/user-attachments/assets/afce6c2c-8077-4cc3-a80e-deefc66e7bd5)

- 이러한 속성은 다중 객체(로우, 레코드, 문서) 연산도 지원함
  - 데이터의 여러 조각이 동기화된 상태로 유지되어할 필요가 있음

#### 단일 객체 쓰기
- 원자성과 격리성은 `단일 객체를 변경하는 경우에도 적용`됨
  - 일부분 데이터만 전달 받은 상태에서 네트워크 연결이 끊긴 경우, 이 데이터를 저장할 것인지?
  - 데이터베이스가 디스크에 새 데이터를 덮어쓰는 도중에 전원이 나갈 경우 기존 값과 새 값은 함께 붙어 있게 될까?
  - 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 부분 갱신된 값을 읽게 될까?

- 이러한 문제들은 혼란스럽기 때문에 저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성, 격리성 제공을 목표로 함
  - 원자성은 `장애 복구(cash recovery)용 로그를 통해 구현함`
  - 격리성은 `각 객체에 잠금을 사용하여 구현함`

- 어떤 데이터베이스는 `compare-and-set` 연산을 제공해 `read-modify-write` 주기 반복을 없앨 수 있게함
  - 데이터를 쓰기 전에 해당 데이터가 누군가에 의해 변경됐는지를 체크하고, 변경되지 않았을 경우에만 쓰기를 허용하는 연산
  - 여러 작업을 하나의 단일 연산 기능으로 제공

- 이러한 단일 객체 연산은 `갱신 손실(lost update)`를 방지하는데 유용함

### 다중 객체 트랜잭션 필요성
- 많은 분산 데이터베이스는 다중 객체 트랜잭션 지원을 포기하였음
  - 데이터가 여러 파티션(노드)에 걸쳐져 있는 경우가 많아, 구현하기 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문

- 많은 경우에 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션 되어야함
  - 참조된 데이터가 유효한 상태가 될 수 있게 보장해줌 (외래키, 비정규화 데이터, 등)
  - 인덱스도 함께 갱신해야함

- 트랜잭션 없이도 이러한 코디네이션 로직을 구현은 가능하나, 복잡해지고 어려움 

### 오류와 어보트 처리
- 트랜잭션의 핵심은 **`어보트되고 안전하게 재시도가 가능한 것`** 임
  - 오류 복구는 애플리케이션에게 책임이 있음
  - 어보트된 트랜잭션을 재시도하는 것은 간단하고 효율적인 오류 처리 메커니즘이지만 완벽하진 않음
    - 트랜잭션이 성공했지만, 커밋 성공을 알리기 전 네트워크가 끊기고, 애플리케이션은 모르고 재시도하는 경우(중복 제거 메커니즘이 없는 경우)
    - 오류가 과부하 때문이라면 재시도는 문제를 악화시킬 수 있음(재시도 횟수 제한 및 방식 고려)
    - 일시적 오류만 재시도 가치가 있음(영구 오류라면 의미 없음)
    - 트랜잭션이 데이터베이스 외부에 부수 효과가 있는 경우 (이메일은 이미 전송됐는데 트랜잭션을 재시도했다고 이메일이 또 재전송되길 바라지 않음)
    - 클라이언트 프로세스가 재시도 중 죽어버리면 쓰기 데이터가 모두 손실됨

## 완화된 격리 수준
- 두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행이 가능함
- 동시성 문제(경쟁 조건)는 동일한 데이터에 대해 동시에 같이 쓰려고 할 경우에만 나타남

- 데이터베이스는 **트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감춰주고자 했음**
- 다만, 완벽하게 (직렬성 격리 수준) 동시성을 제공하는 것은 성능상 비용이 커서 완화된 격리 수준을 사용하고자 하는 시스템들이 많음
- 각 격리 수준마다, 어떤 문제가 발생하고 어떤 문제가 해결되는지를 올바르게 알면 완화된 격리 수준을 통해서도 신뢰성 있고 올바르게 동작하는 애플리케이션을 구축할 수 있음

### 커밋 후 읽기(read committed)
- 가장 기본적인 수준의 격리 수준
  - **데이터베이스에서 읽을 때 커밋된 데이터만 보게 됨(`더티 읽기`가 없음)**
  - **데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 됨(`더티 쓰기`가 없음)**

#### 더티 읽기 방지
- 다른 트랜잭션이 커밋되지 않은 쓰기 데이터를 읽는(보는) 경우를 **`더티 읽기(dirty read)`** 라고 함
- 커밋 후 읽기 격리 레벨에서는 더티 읽기가 발생해서는 안됨

  ![CleanShot 2025-05-11 at 04 51 40](https://github.com/user-attachments/assets/646801f3-76cb-472b-9b8b-5424a3635374)

- 더티 리드를 막았을 때 유용한 이유
  - 다른 트랜잭션이 잘못된 값으로 인해 잘못된 결정을 하지 않게 함
  - 트랜잭션이 롤백되면, 다른 트랜잭션은 결코 커밋되지 않을 데이터를 볼 수 있게 됨 

#### 더티 쓰기 방지
- 두 트랜잭션이 동일한 객체를 동시에 쓰려고 할때, 아직 커밋되지 않은 상태에서 나중에 쓴 내용이 먼저 쓴 내용을 덮어쓰는 경우를 **`더티 쓰기(dirty write)`** 라고 함
- 커밋 후 읽기 격리 레벨에서는 더티 쓰기를 방지해야함

  ![CleanShot 2025-05-11 at 04 58 52](https://github.com/user-attachments/assets/79abd435-632a-4444-aa66-20ec75fc238c)

  - 트랜잭션들이 여러 객체를 갱신하면서 더티 쓰기는 기대하지 않은 결과를 유발할 수 있음

#### 커밋 후 읽기 구현
- **로우 수준 잠금을 사용해 더티 쓰기를 방지할 수 있음**
  - 트랜잭션에서는 쓰기를 하기 전에 해당 로우에 대한 잠금을 획득하고, 트랜잭션이 커밋/어보트 될 때까지 잠금을 보유하고 있어야 함

- 더티 읽기도 동일하게 잠금을 사용해 구현할 수 있지만, 읽기만 실행하는 여러 트랜잭션들이 쓰기 트랜잭션이 완료되길 기다려야 할 수 있기 때문에 현실적으로 잘 사용되진 않음
  - 데이터베이스는 커밋되기 이전 데이터를 가지고, 다른 트랜잭션에게 커밋 이전의 과거 데이터를 볼 수 있도록 제공 

### 스냅숏 격리와 반복 읽기
- 커밋 후 읽기를 사용하더라도 동시성 버그가 생기는 경우는 존재함

  ![CleanShot 2025-05-11 at 05 05 44](https://github.com/user-attachments/assets/573df055-893f-478b-968b-b5e6cd5b5219)

  - 이러한 이상 현상을 **`비반복 읽기(nonrepeatable read)`** 나 **`읽기 스큐(read skew)`** 라고 함

- 스냅숏 격리는 이 문제의 가장 흔한 해결책임
  - 각 트랜잭션은 일관된 데이터를 읽을 수 있음
  - 중간에 데이터가 다른 트랜잭션에 의해 변경되더라도, 트랜잭션은 특정한 시점의 과거 데이터를 보게됨

- 스냅숏 격리 수준은 백업이나 분석처럼 오래 걸리며 읽기만 실행하는 질의에서 유용함
- Postgresql, Mysql(InnoDB), Oracle, 등에서 지원됨

#### 스냅숏 격리 구현
- 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용하지만, 읽기 작업에 대한서는 차단을 하지 않음
  - 즉, 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않음

- 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있음

- 많은 데이터베이스에서 더티 읽기를 막는데 쓰는 매커니즘을 일반화한 방법을 사용함(과거 데이터를 보도록 하는 방식)
  - 즉, 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지하며 트랜잭션마다 서로 다른 시점의 데이터를 볼 수 있도록 함
  - 이러한 방식을 **`다중 버전 동시성 제어(MVCC)`** 라고 함

    ![CleanShot 2025-05-11 at 05 21 31](https://github.com/user-attachments/assets/506363ff-538a-4a41-b1e3-98e9776ed5f3)

    - 해당 로우를 삽입/삭제 요청을 한 트랜잭션 ID를 저장하며, 삭제 요청 로우에 대해서 접근하지 않음이 확실해지면 데이터베이스 가비지 컬렉션 프로세스가 해당 로우들을 실제 삭제함
    - 갱신은 내부에서 삭제와 생성으로 변환됨

#### 일관된 스냅숏을 보는 가시성 규칙
- **트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용하여 판단함**
  - 트랜잭션이 시작할 때 그 시점에 진행중인 모든 트랜잭션 목록을 만듬
    - 이 트랜잭션이 쓴 데이터는 모두 무시됨(커밋이 되더라도) 
  - 어보트된 트랜잭션이 쓴 데이터는 모두 무시됨
  - 트랜잭션이 더 큰 트랜잭션이 쓴 데이터는 모두 무시됨

- 즉, **`읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태이어야 함`**
  - 읽기 대상 객체가 삭제된 것으로 표시되지 않아야함
  - 삭제된 것으로 표시됐지만 읽기 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않아야함

- 오래 실행되는 트랜잭션은 오래동안 동일한 스냅숏을 사용하여 데이터를 읽음
- 데이터베이스는 갱신할 때 값을 교체하지 않고 값이 변할때마다 새 버전을 생성하여 일관된 스냅숏을 제공함

#### 색인과 스냅숏 격리
- 다중 버전 데이터베이스에서 색인은 단순하게 객체의 모든 버전을 가리키고, `색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내는 방식`으로 동작함
- DB마다 약간씩 구현 상 차이가 있어 다른 방식으로 동작함

#### 반복 읽기와 혼란스러운 이름
- Oracle은 직렬성, Mysql, Postgresql 은 `반복 읽기(repeatable read)`라고 하는데, 그 이유는 초창기엔 스냅숏 격리 개념이 없었기 때문임
- SQL 표준은 반복 읽기로 정의하고 있음
- 다만, 이러한 표준 정의에는 실제로 제공하는 보장이 모호하고 부정확한 결함이 있음 

### 갱신 손실 방지
- 지금까지 알아본 커밋 후 읽기와 스냅숏 격리 수준은 주로 동시에 실행되는 쓰기 작업이 있을 때 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 내용임
  - 더티 쓰기는 **`쓰기-쓰기 충돌(write-write conflict)`** 의 특별한 종류 중 하나 

- 동시에 데이터베이스 쓰기를 할 경우 발생할 수 있는 또 다른 문제는 **`갱신 손실(lost update)`** 이 있음
  - 동시에 쓸 경우 먼저 쓴 데이터가 손실(clobber, 덮어씀)될 수 있다. (LWW)

- 해당 경우는 여러가지 시나리오 상에서 문제가 될 수 있음
  - 현재 값을 읽어서 새로운 값을 계산하고 갱신하는 경우
  - 복잡한 값을 지역적으로 변경하는 경우
  - 여러 사용자가 동시에 같은 페이지를 편집하는 경우

### 원자적 쓰기 연산
- 여러 데이터베이스는 원자적 갱신 연산을 제공함
  - 여러가지 작업을 한번의 쿼리로 실행할 수 있는 기능
  - 어플리케이션 코드에서 `read-modify-write` 주기를 구현하지 않도록 함

    ```sql
      UPDATE counters SET value = value + 1 WHERE key = 'foo';
    ``` 

- 모든 쓰기가 원자적 연산으로 표현되는 것은 아님

- 원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인(Exclusive) 잠금을 획득해서 구현함
  - 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못함 
  - 이 기법을 **커서 안정성(cursor stability)** 라고도 부름

### 명시적인 잠금
- 또 다른 방법 중 하나는 **`애플리케이션에서 명시적으로 갱신할 객체를 잠그는 것`** 이 있음

   ```sql
     BEGIN TRANSACTIONl;
   
     SELECT * FROM figures
       WHERE name  = 'foo' AND id = 123
     FOR UPDATE;

     -- 이동이 유효한지 확인한 후
     -- 이전의 SELECT에서 반환된 것의 위치를 갱신
     UPDATE figures SET position = 'c4' WHERE id = 123;
   
     COMMIT;
    ``` 

  - FOR UPDATE 절은 데이터베이스가 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가르킴

- 해당 방법을 올바르게 사용하려면 어플리케이션 로직에 대해 신중하게 생각해야함
- 잘못 사용하였을 때 경쟁 조건이 발생할 수 있음

### 갱신 손실 자동 감지
- `원자적 연산과 잠금은 read-modify-write 주기가 순차적으로 실행되도록 해서 갱신 손실을 방지하는 것임`
- 대안으로 **`병렬 실행을 허용하고, 트랜잭션 관리자가 갱신 손실을 발견하면 어보트 시키고 재시도하게끔 하는 방법`** 도 있음
  - 어떠한 신경도 안 써도 자동으로 되기 때문에 편리함
  - Mysql(InnoDB) 에서는 갱신 손실 감지하지 않음
    - 참고 : https://velog.io/@praisebak/Repetable-Read%EB%8A%94-Lost-Update%EB%A5%BC-%EB%A7%89%EC%A7%80-%EC%95%8A%EC%9D%84%EC%88%98%EB%8F%84-%EC%9E%88%EB%8B%A4.feat.-mvccinnodb-engine 

### Compare-and-set
- 트랜잭션을 제공하지 않는 DB 중에는 원자적 `compare-and-set` 연산을 제공하기도 함
  - 값을 마지막으로 읽은 후 해당 객체에 변경이 이루어졌는지 확인하고, 변경이 없었다면 갱신함 ( **갱신 손실을 회피하는 방식** )
  - 즉, 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 재시도해야함

   ```sql
     -- 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있음
     UPDATE wiki SET content = 'new content'
       WHERE id = 123 AND content = 'old content'; 
    ``` 

- 이 방식은 **`데이터베이스가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용하는 경우, 갱신 손실을 막지 못할 수 있음`**

### 충돌 해소와 복제
- 복제가 적용된 데이터베이스 환경에서는 최신 복사본이 여러개 존재할 수 있기 때문에 갱신 손실을 방지하기 위해서는 추가 단계가 필요함
  - 잠금과 compare-and-set 기법은 최신 복사본이 하나라고 가정하기 때문에 사용할 수 없음

- 복제 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러개의 충돌된 버전(형제, subling)을 생성하는 것을 허용하고, 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전을 병합하는 방식을 사용함

- 교환 법칙이 성립(다른 순서로 연산을 적용해도 같은 결과가 나오는 경우)하는 원자적 연산은 복제 상황에서도 잘 동작함
  - 어떤 갱신도 손실되지 않는 방식을 써서 자동으로 갱신을 병합함(리악)

- 최종 쓰기 승리(LWW) 충돌 해소 방법의 경우 갱신 손실이 발생하기 쉽지만, 많은 복제 데이터베이스는 LWW가 기본 설정임

## 쓰기 스큐와 팬텀
- 더티 쓰기, 갱신 손실 외에 동시에 실행되는 쓰기 작업 사이에 잠재적으로 발생할 수 있는 경쟁 조건으로 **`쓰기 스큐(write skew)`** 가 있음

  ![CleanShot 2025-05-11 at 15 41 37](https://github.com/user-attachments/assets/199ac107-2ec5-48c7-a30a-6e726e33e771)

    - 최소한 한 명의 의사가 대기해야 하는 시스템에서 두 트랜잭션이 모두 커밋되면 대기하는 의사가 한명도 없게 됨

### 쓰기 스큐를 특징짓기
- 더티 쓰기, 갱신 손실은 다른 트랜잭션이 하나의 동일한 객체를 갱신할 때 발생 가능
- 하지만, 쓰기 스큐의 경우는
  - 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 발생 가능
  - 다른 트랜잭션은 다른 객체를 갱신

- 쓰기 스큐 막기 위해서는
  - 원자적 단일 객체 연산 과 갱신 손실 자동 감지 X
  - 여러 객체와 연관된 제약 조건 설정 → 트리거/구체화 뷰(materialized view) 사용하여 구현 가능
  - 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그기(for update)

### 추가적인 쓰기 스큐의 예
- 회의실 예약 시스템
  - 다른 사용자가 동시에 충돌되는 회의 삽입을 막을 수 없음 → 직렬성 격리 필요

    ![CleanShot 2025-05-11 at 15 49 49](https://github.com/user-attachments/assets/c540b625-c175-4a2a-98dd-7d1d2943e99c)

- 다중 플레이어 게임
  - 플레이어들이 두 개의 다른 물체를 게임판 위의 같은 위치로 옮기거나 규칙을 위반하는 다른 이동을 막을 수 없음 → 규칙에 따라 유일성 제약 사용 가능

- 사용자명 획득
  - 웹사이트에서 두 명의 사용자가 동시에 같은 사용자명으로 계정 생성 시도 → 유일성 제약 조건으로 해결

- 이중 사용 방지
  - 두 개의 지불 항목이 모여서 잔고가 음수가 되게 하는 경우 발생 가능

### 쓰기 스큐를 유발하는 팬텀
- 위의 예시는 비슷한 패턴을 따름
  - 1단계 : SELECT로 특정 검색 조건에 부합하는 로우를 검색하여 요구사항 만족하는지 판단
  - 2단계 : 1단계 질의 결과에 따라 연산을 계속 처리할지 오류 보고/중단할지 결정
  - 3단계 : 계속 연산을 처리하는 경우에 INSERT, UPDATE, DELETE 트랜잭션을 커밋
    - 의사 대기 예시 → 1단계의 로우를 SELECT … FOR UPDATE로 잠궈서 쓰기 스큐 회피 가능
    - 나머지 예시 → 검색 조건에 부합하는 로우가 존재하지 않으면 쓰기 작업이 실행되는 구조이므로 1단계 질의가 아무 로우도 반환하지 않아서 SELECT … FOR UPDATE 사용 불가

- 이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 **`팬텀(phantom)`** 이라고 함
  - 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 설명한 예시처럼 읽기 쓰기 트랜잭션에서는 문제가 될 수 있음 

### 충돌 구체화
- **`materializing conflict`** : 구체화 뷰를 사용해서 팬텀을 해당 뷰의 로우 집합에 대한 잠금 충돌로 변환
  - 명시적이고 인위적인 외부 락 테이블을 만드는 방식이라고 보면 됨

- 회의실 예약 시스템에서 회의실과 시간 범위의 모든 조합에 대해 로우를 미리 만들어 둠
- 원하는 회의실과 시간 범위에 해당하는 로우를 SELECT … FOR UPDATE로 잠금
- 하지만, 이는 어렵고 오류가 발생하기 쉬움
- 또한, 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나오는 것도 보기 좋지 않음
- 따라서, 다른 대안(직렬성 격리)이 불가능할 때 사용하는 최후의 수단임

## 직렬성
- 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장함 → 가장 강력한 격리 수준
- 트랜잭션을 개별적으로 실행할 때 올바르게 동작한다면 동시에 실행할 때도 올바르게 동작할 것을 보장 → DB가 발생할 수 있는 모든 경쟁 조건을 막아줌

- 오늘날 직렬성을 제공하는 데이터베이스는 대부분 아래 세가지 방법 중 하나를 사용함
  - `트랜잭션을 순차적으로 실행(단일 스레드)`
  - `2단계 잠금(2PL)`
  - `낙관적 동시성 제어 (직렬성 스냅숏 격리, SSI)`

### 실제적인 직렬 실행
- 동시성 문제를 피하는 가장 간단한 방법은 **`한 번에 트랜잭션 하나만 직렬로 단일 스레드에서 실행`** 하는 것임
- 하지만, 이는 최근에서야 가능하게 된 것임. 그전에는 성능 저하 때문에 고려하지 않았으나 여러 이유로 단일 스레드로 실행되도록 설계 된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 수도 있게됨
  - 램 가격이 저렴해져서 데이터셋 전체를 메모리에 유지할 수 있을정도가 됨(디스크 I/O X)
  - OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는걸 깨달음 

- 레디스, 볼트DB/H 스토어, 데이토믹, 등에서는 단일 스레드를 통해 트랜잭션을 순차적으로 실행하도록 구현되어 있음
- 잠금을 코디네이션하는 오버헤드를 피할수 있기 때문에 성능이 나은 경우가 있음
- 다만, 이들의 처리량은 CPU 코어 하나의 처리량으로 제한됨
- 따라서, 단일 스레드를 최대한 활용할 수 있도록 트랜잭션이 다르게 구조화되어야함

#### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
- 대부분의 데이터베이스와 OLTP 어플리케이션은 트랜잭션 내에서 대화식으로 사용자 응답을 대기하는 것을 회피함으로써 트랜잭션을 짧게 유지함 
  - 새로운 HTTP 요청은 새로운 트랜잭션을 시작
  - 사용자의 전체 작업을 하나의 트랜잭션으로 가져가기에는 사용자의 반응이 너무 느림

- 그럼에도 대부분의 트랜잭션은 상호작용 방식의 클라이언트/서버 스타일로 실행되어 왔음
  - 애플리케이션이 질의를 실행하여 결과를 읽고, 첫 번째 질의 결과에 따라 다른 질의를 실행
  - 애플리케이션과 DB 사이의 네트워크 통신에 많은 시간 소비
  - 만약 DB에서 동시성을 허용하지 않고 한 번에 트랜잭션 하나씩만 처리하면 처리량 매우 낮음 (다음 질의까지의 대기시간이 길어지므로)

- 단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템들은 상호작용하는 다중 구문 트랜잭션을 허용하지 않음
  - 대신 애플리케이션은 트랜잭션 코드 전체를 **`스토어드 프로시저`** 형태로 데이터베이스에 미리 제출해야함
 
![CleanShot 2025-05-11 at 19 17 29](https://github.com/user-attachments/assets/d13906f2-96e1-4e35-b310-2ee302b2a505)

#### 스토어드 프로시저의 장단점
- 현재는 RDBMS에서 등장한지 시간이 꽤 지났고, SQL 표준으로 자리 잡게 되었음
- 다만, 여러 이유로 인해 좋지 않은 평가를 받고 있음
  - DB 벤더마다 다른 SP(스토어드 프로시저)용 언어
    - 오라클 : PL/SQL, SQL 서버 : T-SQL, Postgre : PL/pgSQL → PL/SQL 대신 범용 프로그래밍 언어 사용 (볼트DB : Java/Groovy, 데이토믹 : Java/Clojure, 레디스 : Lua)
  - 애플리케이션 코드에 비해 DB 실행 코드는 디버깅 버렵고 버전 관리/배포 불편
  - 잘못 작성된 SP가 코드단의 오류가 애플리케이션 서버에 미치는 것보다 DB에 훨씬 더 악영향 줄 수 있음

- 데이터가 메모리가 저장되고 모든 트랜잭션을 단일 스레드에서 처리되는 경우, SP가 오히려 적절할 수 있음
  - 다른 동시성 제어 메커니즘의 오버헤드를 회피하여 단일 스레드로 좋은 처리량 얻을 수 있음

- 볼트DB는 복제에도 SP 사용함
  - SP는 결정적이어야 함(다른 노드에서 실행돼도 같은 결과가 나와야 함)

#### 파티셔닝
- 직렬 실행은 DB의 트랜잭션 처리량이 단일 장비에 있는 단일 CPU 코어의 속도로 제한됨
  - 읽기는 다른 노드에서 실행될 수 있어 문제가 되지 않지만, 쓰기 처리량이 높은 어플리케이션에서는 심각한 병목이 될 수 있음

- **`여러 CPU 코어와 여러 노드로 확장하기 위해 파티셔닝할 수 있음`** (볼트DB 지원)
  - 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티션할 수 있다면 각 파티션은 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있음
  - 이 경우 각 CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 코어 개수에 맞게 선형적으로 확장 가능

- 하지만, 여러 파티션에 접근해야 하는 트랜잭션은 모든 파티션에 걸쳐 코디네이션을 해주어야함
  - 직렬성 보장을 위해 모든 파티션에서 잠금을 획득한 다음 실행 해야 하며 이 경우 엄청나게 느리므로 유의 필요
  - 단순 키 값 데이터는 쉽지만, 여러 보조 색인이 있는 데이터는 코디네이션 필요함

#### 직렬 실행 요약
- **`트랜잭션 직렬 실행(단일 스레드)은 몇 가지 제약 사항 안에서 직렬성 격리 수준을 보장할 수 있는 실용적인 방안임`**
- 제약 사항
  - 모든 트랜잭션은 작고 빨라야 함 (느린거 하나가 다른 트랜잭션 처리를 지연시키면 안됨)
  - 활성화된 데이터셋이 디스크가 아닌 메모리에 적재될 수 있어야 함
  - 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 낮아야 함
  - 여러 파티션에 걸친 코디네이션이 필요하지 않도록 파티셔닝 해야 함

### 2단계 잠금(2PL)
- **`2PL(two-phase locking)`** 란, **쓰기 트랜잭션은 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 허용하지 않는 방식** (반대로, 읽고 있는 경우에는 쓸 수 없음)
  - 쓰기를 실행하는 트랜잭션이 없는 객체에는 여러 트랜잭션이 동시에 읽을 수 있음. 그러나 누군가 어떤 객체에 쓰려고 하면 독점적인 접근이 필요함
  - **트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰려고 시도하면 B가 진행되기 전에 A가 커밋되거나 어보트 되어야 함** (⇒ B가 A 몰래 객체 변경 안됨)
  - **트랜잭션 A가 객체에 쓰고 트랜잭션 B가 그 객체를 읽으려고 하면 B가 진행되기 전에 A가 커밋되거나 어보트 되어야 함** (⇒ 객체의 과거 버전 읽기 안됨)

- 2PL에서는 **`쓰기 트랜잭션이 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막음`** . 이는 **`스냅숏 격리`** 에서 읽는 쪽은 결코 쓰는 쪽을 막지 않으며 반대도 허용하는 것과는 차이가 있음
- 2PL은 직렬성을 제공하여 모든 경쟁 조건으로 부터 보호함

#### 2단계 잠금 구현
- 읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용하여 구현함
- 잠금은 **`공유 모드(shared mode)`** 과 **`독점 모드(exclusive mode)`** 가 있음
  - 트랜잭션이 객체를 읽기 원하면 공유 모드로 잠금 획득 필요(다른 트랜잭션이 독점 모드를 가지고 있는 경우 대기, 공유 모드인 경우는 획득 가능)
  - 트랜잭션이 객체를 쓰기 원하면 독점 모드로 잠금 획득 필요(다른 트랜잭션에서 공유 모드 잠금을 가지고 있는 경우 대기해야함)
  - 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드 필요
  - 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료(커밋/어보트)될 때까지 잠금을 가지고 있어야 함

- 해당 방식은 잠금이 많이 사용되기 때문에 **`교착 상태(데드락)`** 가 매우 쉽게 발생할 수 있음(주의 필요)
  - A가 B의 잠금 해제 대기 & B가 A의 잠금 해제 대기
  - 다만, DB가 자동으로 감지하여 트랜잭션 중 하나를 어보트 시킴(어보트된 트랜잭션은 어플리케이션에서 재시도 필요)

- MySQL, SQL 서버에서 직렬성 격리 수준 구현에 사용됨

#### 2단계 잠금의 성능
- 2PL의 큰 단점은 성능이 좋지 않다는 것
  - 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠짐
  - 동시성이 줄어듬(잠금 획득/해제의 오버헤드 및 다른 트랜잭션 대기 시간)
  - RDBMS에서 트랜잭션의 실행 시간을 제한하지 않으므로 경쟁이 있다면 매우 느려지거나 멈추게 할 수 있음
  - 교착 상태가 자주 발생

### 서술 잠금
- 직렬성 격리는 `팬텀 문제`(한 트랜잭션이 다른 트랜잭션의 검색 질의 결과를 바꿔버리는 문제)를 막아야함
  - **`서술 잠금(predicate lock)`** 으로 해결 가능함

- 특정 객체 (테이블 내의 한 row)에 속하지 않고 어떤 검색 조건에 부합하는 모든 객체에 속하는 경우, DB에 아직 존재하지 않지만 미래에 추가될 수 있는 객체(팬텀)에 적용 가능
  - 트랜잭션 A가 조건에 부합하는 객체를 읽으려면 공유 모드 서술 잠금이 필요, 다른 트랜잭션 B가 독점 잠금을 가지고 있으면 A는 B의 잠금 해제까지 대기 필요
  - 트랜잭션 A가 객체 삽입/갱신/삭제를 시도할 때 부합하는 서술 잠금을 트랜잭션

### 색인 범위 잠금
- 서술 잠금은 진행 중인 트랜잭션들이 획득한 잠금이 많으면 조건에 부합하는 잠금을 확인하는데 오래 걸려서 잘 동작하지 않음
- 그래서 2PL을 지원하는 대부분의 DB에서는 실제로는 **`색인 범위 잠금(index-range locking)`** ( **`다음 키 잠금(next-key locking)`** )을 구현함
  - 더 많은 객체가 부합하도록 서술 조건을 간략하게 근사한 것

- 예를들어, 12시-1시 사이 123번 예약에 대한 서술 잠금은 모든 시간 범위의 123번 예약 잠금 or 12시 1시 사이의 모든 방 잠금으로 구현한 것
    - room_id에 색인이 있는 경우 123번 예약이 있는지 확인하는데 색인 사용
    - start_time / end_time에 색인이 있는 경우 12시-1시 사이의 예약이 있는지 확인하는데 색인 사용

- 쓰기 팬텀과 쓰기 스큐로부터 보호함
- 서술 잠금보다 정밀하지는 않지만 오버헤드가 훨씬 낮음
- 색인이 없다면 테이블 전체에 공유 잠금 사용함

### 직렬성 스냅숏 격리(SSI)
- 2008년 마이클 카힐에 의해 소개된 **`Serializable Snapshot Isolation`** 는 완전한 직렬성을 제공하면서도 스냅숏 격리에 비해 약간의 성능 손해만 있음
  - 단일 노드 DB와 분산 DB에서 모두 사용됨

#### 비관적 동시성 제어 대 낙관적 동시성 제어
- **`2PL은 비관적 동시성 제어 메커니즘`** 이고, **`SSI는 낙관적 동시성 제어 메커니즘`** 임
  - 비관적 동시성 제어 : 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때가지 대기하는 방식(상호 배제)
  - 낙관적 동시성 제어 : 작업을 완료하는 시점에 나쁜 상황이 발생했는지 확인하는 방식

- SSI는 트랜잭션이 커밋되기를 원할 때 격리가 위반되었는지 확인하여 어보트함(어플리케이션에서 재실행). 즉, 직렬로 실행된 트랜잭션만 커밋 허용함
- 스냅숏 격리(트랜잭션에서 실행되는 모든 읽기가 DB의 일관된 스냅숏을 보게함)에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘 추가하면 됨
    - 장점 : 예비 용량이 충분하고 트랜잭션 사이의 경쟁이 심하지 않으면 비관적 동시성 제어에 비해 성능이 좋음, 경쟁은 commutative(순서와 상관없이 결과 동일) 원자적 연산을 통해 줄일 수 있음
    - 단점 : 많은 트랜잭션이 같은 객체에 접근하려는 경쟁이 심하면 어보트 시켜야 할 트랜잭션의 비율이 높아져서 성능이 떨어짐

### 뒤처진 전제에 기반한 결정
- 트랜잭션은 어떤 전제 (읽기 결과)을 기반으로 동작을 하는데, 나중에 해당 트랜잭션이 커밋하려고 할 때 원래의 데이터가 바뀌어서 해당 전제가 참이 아닐 수 있음
- 따라서, 직렬성 격리를 제공하려면 뒤처진 전제를 기반으로 동작하는 트랜잭션을 감지하고 어보트 시켜야함
  - 오래된 MVCC 객체 버전을 읽었는지 감지 (읽기 전에 커밋되지 않은 쓰기가 발생함)
  - 과거의 읽기에 영향을 미치는 쓰기 감지 (읽은 후에 쓰기가 실행됨)

### 오래된 MVCC 읽기 감지하기

![CleanShot 2025-05-11 at 20 33 50](https://github.com/user-attachments/assets/44a1267b-2f83-4cd5-aca7-b8cbb917da5d)

- 트랜잭션 43이 읽을때는 (과거의) 스냅숏을 보지만 커밋하려고 할 때는 트랜잭션 42가 커밋된 상태이므로 읽을 때는 무시됐던 쓰기가 영향이 있어지고 트랜잭션 43의 전제가 유효하지 않음
  → 트랜잭션이 커밋하려고 할 때, DB가 무시된 쓰기 중 커밋된게 있는지를 추적/확인해야 하며 이 트랜잭션을 어보트 시킴

### 과거의 읽기에 영향을 미치는 쓰기 감지하기

![CleanShot 2025-05-11 at 20 35 12](https://github.com/user-attachments/assets/e91d9e79-0fad-402c-a30c-c49bfc4dc9ba)

- 트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야함
- 트랜잭션 43이 커밋하려고 할 때 트랜잭션 42의 충돌되는 쓰기가 이미 커밋됐으므로 트랜잭션 43은 어보트됨

### 직렬성 스냅숏 격리의 성능
- 얼마나 세밀하게 추적하느냐에 따른 트레이드 오프가 있음
  - 세밀한 경우, 어보트 되어야 하는 트랜잭션을 정확하게 판별하나 오버헤드가 큼
  - 세밀하지 않은 경우, 지나치게 많은 트랜잭션이 어보트될 수 있음

- 어보트 비율은 SSI의 전체적인 성능에 영향을 줌
  - 오래 걸리는 트랜잭션은 어보트될 확률이 높아 악영향을 줌 

## 정리
- 트랜잭션은 어플리케이션이 어떤 동시성 문제와 어떤 종류의 하드웨어와 소프트웨어 결함이 존재하지 않는 것처럼 동작할 수 있게 도와주는 추상층임
  - 많은 종류의 오류가 간단한 트랜잭션 어보트로 줄어들고 어플리케이션은 단순하게 재시도만 하면됨
  - 접근 패턴이 복잡한 경우 트랜잭션은 상상할 수 있는 잠재적인 오류 상황의 수를 크게 줄여줌
  - 트랜잭션이 없는 경우 다양한 오류 시나리오에서 다양한 방식으로 데이터의 일관성이 깨질 수 있음

- 트랜잭션의 동시성 제어(격리 수준)
  - 커밋 후 읽기 : 더티 읽기/더티 쓰기 방지 보장
  - 스냅숏 격리(반복 읽기) : 각 트랜잭션이 DB의 일관된 스냅숏으로 부터 읽음
  - 직렬성 격리 : 모든 동시성 문제에서 보호됨. 각 트랜잭션이 격리되어 순차적으로 실행됨을 보장

- 발생가능한 경쟁 조건 예시
  - 더티 읽기 : 한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 읽음
  - 더티 쓰기 : 한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 덮어씀
  - 읽기 스큐(비반복 읽기) : 클라이언트가 다른 시점에 DB의 다른 부분을 봄 → 스냅숏 격리로 해결(MVCC)
  - 갱신 손실 : 두 클라이언트가 동시에 read-modify-write 주기를 실행하여 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 상태로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터 손실 → 수동 잠금(SELECT … FOR UPDATE)로 해결
  - 쓰기 스큐 : 트랜잭션이 읽은 값을 기반으로 결정을 한 뒤 해당 결정을 DB에 쓰지만 쓰기 시점에 결정의 전제가 참이 아닐 수 있음 → 직렬성 격리로 해결
  - 팬텀 읽기 : 트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽고 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행 → 색인 범위 잠금 필요

- 직렬성 격리
  - 단일 스레드 : 실제 트랜잭션을 순서대로 실행
  - 2단계 잠금 : 표준 방식이나 성능 이슈 존재
  - 직렬성 스냅숏 격리 : 낙관적 동시성 제어 방식 사용 (커밋을 원할때에 확인해서 직렬적이지 않으면 어보트시킴)
