트랜잭션은 자연의 법칙이 아니다.

- 트랜잭션 목적
    - 애플리케이션 프로그래밍 모델 단순화할 수 있다.
    - 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다.

모든 애플리케이션에서 트랜잭션이 필요하지는 않다. 트랜잭션적인 보장을 완화하거나 아예 쓰지 않는 게 이득일 수도 있다. 트랜잭션 필요 여부를 알기 위해서는 여러 중요한 세부 사항이 작용한다.

이제 다양한 종류의 경쟁 조건과 데이터베이스에서 커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability) 같은 격리 수준을 어떻게 구현하는지 알아보자.

# 1. 애매모호한 트랜잭션의 개념

- 새로운 세대의 데이터베이스
    - 다수는 트랜잭션을 완전히 포기했다.
    - 다수는 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의했다.

새로 탄생한 분산 데이터베이스는 트랜잭션은 확장성의 인티테제이며 대규모 시스템이라도 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 있다.

반면 데이터베이스 벤더에서는 트랜잭션적인 보장은 “값진 데이터”, “중대한 애플리케이션”에 필수적인 요구사항이라고 한다.

물론 다른 모든 기술적 선택과 마찬가지로 트랜잭션은 이점과 한계가 있다.

## 1) ACID의 의미

트랜잭션이 제공하는 안전성 보장은 ACID로 잘 알려져 있다.

하지만 현실에서 데이터베이스마다 ACID 구현이 제각각이다. 특히 “격리성”의 의미 주변에는 모호함이 많이 있다. ACID 표준을 따르지 않는 시스템은 “BASE”라고도 불리는데 ACID보다 정의가 더 모호하다.

### 1-1) 원자성 (Atomicity)

- 원자성
    - 클라이언트가 실행하는 몇 개 쓰기 작업 중 일부만 처리된 후 결함이 생기면 무슨 일이 생기는지 설명한다.
    - 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여있어 결함 시에 commit 될 수 없다면 abort되고 데이터베이스는 트랜잭션에서 실행한 쓰기를 무시하거나 취소한다.

### 1-2) 일관성 (Consistency)

- 일관성
    - 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존한다.
- 애플리케이션의 책임
    - 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.
- 데이터베이스의 책임
    - 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다. (외래 키 제약 조건, 유일성 제약 조건의 경우가 있지만 데이터베이스는 데이터를 저장할 뿐이다.)

원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성이다. 따라서 애플리케이션에서 일관성 달성을 위해 데이터베이스의 원자성, 격리성 속성에 기댈 수 있지만 데이터베이스만으로 되지 않는다. 따라서 일관성(C)는 ACID에 속하지 않는다.

### 1-3) 격리성 (Isolation)

![image](https://github.com/user-attachments/assets/76c72ac4-60e5-4223-b3a5-1e4c53d4a989)

- 격리성
    - 동시에 실행되는 트랜잭션은 서로 격리도는 것을 의미한다.
    - 데이터베이스는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
- 직렬성 격리
    - 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다.
    - 오라클에서는 직렬성이라는 격리 수준이 있지만 직렬성보다 보장이 약한 스냅숏 격리를 구현했다.

### 1-4) 지속성 (Durability)

- 지속성
    - 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함, 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장을 의미한다.
- 쓰기 전 로그 (write-ahead log)
    - 디스크에 저장된 데이터 구조가 오염 됐을 때 복구할 수 있게 도와준다.

물론 완벽한 지속성은 존재하지 않는다.

## 2) 단일 객체 연산과 다중 객체 연산

- ACID에서 원자성(A), 격리성(I)
    - 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야 하는지 서술한다.
- 원자성
    - 트랜잭션 abort, 쓰여진 내용 폐기
        - 쓰기를 실행하는 도중 오류가 발생 시
- 격리성
    - 동시에 실행된 트랜잭션들은 서로 방해하지 않는다.
        - 각 트랜잭션이 서로의 내용을 전부 볼 수 있거나 아무것도 볼 수 없도록 함

**다중 객체 트랜잭션**

“다중 객체 트랜잭션”은 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

- 격리성 위반(dirty read) 예시
    1. 사용자1 insert emails (’Hello’, true)
    2. 사용자2 select emails → (’Hello’, true)
    3. 사용자2 select mailboxes → 0
    4. 사용자1 update mailboxes → 1

트랜잭션이 다른 트랜잭션에서 썼지만 커밋되지 않은 데이터를 읽었기 때문이다. (dirty read)

![image](https://github.com/user-attachments/assets/870b207a-1d5b-4d3b-b677-f9bfe315624d) 

- 원자성 위반 예시
    1. 사용자1 insert emails (’Hello’, true)
    2. 사용자1 update mailboxes `ERROR!!`
    3. rollback

원자성은 오류가 발생하면 트랜잭션에서 이전에 실행한 쓰기를 취소해서 일관성이 깨진 상태가 되지 않게 한다.

![image](https://github.com/user-attachments/assets/b0f6b7c4-958f-43ce-89f7-b4dc9f68962b)

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.

- 관계형 데이터베이스
    - TCP 연결을 기반으로 클라이언트와 데이터베이스 사이에서 BEGIN TRANSACTION, COMMIT 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 판단한다.
- 비관계형 데이터베이스
    - 관계형 데이터베이스와 같은 연산을 묶는 방법이 없는 경우가 많다.
    - 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 뜻하지 않는다.
        - 키-값 저장소에서 한 연산 내에서 여러 키를 갱신하는 다중 put(multi-put) 연상을 제공할 수도 있다. → 하지만 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

### 2-1) 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.

- 문제 상황 (20KB JSON 문서를 데이터베이스에 쓸 때)
    - 첫 10KB 보낸 후 네트워크 연결이 끊기면 데이터베이스는 파싱 불가능한 10KB JSON 조각을 어떻게 저장할 것인가?
    - 데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중에 전원이 나가면 기존 값과 새 값이 함께 붙어 있게 될까?
    - 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 부분적으로 갱신된 값을 일게 될까?

이러한 문제들은 복잡하여 저장소 엔진들은 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.

- 원자성
    - 장애 복구(crash recovery)용 로그를 써서 구현한다.
- 격리성
    - 각 객체에 잠금을 사용해 구현한다.

어떤 데이터베이스는 증가 연산 처럼 더 복잡한 원자적 연산을 제공하기도 한다.

증가 연산은 read-modify-write 주기를 반복할 필요를 없앤다.

비슷하게 CAS(Compare-And-Set) 연산이 있다. 물론 CAS 연산은 일반적으로 쓰이는 의미의 트랜잭션이 아니다. 트랜잭션은 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘이다.

### 2-2) 다중 객체 트랜잭션의 필요성

많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했지만 근본적으로 트랜잭션을 막는 곳은 없다.

키-값 데이터 모델과 단일 객체 연산만 사용해서 애플리케이션을 구현하는 사례도 있긴하다. 하지만 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션 돼야 한다.

- 코디네이션 돼야하는 사례
    - 관계형 데이터 모델에서 외래 키를 갖는 경우 다중 객체 트랜잭션이 참조가 유효한 상태로 유지되도록 보장
    - 문서 데이터베이스는 비정규화를 장려하기도하여 비정규화된 정보를 갱신할 때는 한 번에 여러 문서를 갱신해야 한다.
    - 보조 색인이 있는 데이터베이스는 값을 변경할 때마다 색인도 같이 갱신돼야 한다.

### 2-3) 오류와 어보트(abort) 처리

트랜잭션의 핵심 기능은 오류가 생기면 abort되고 안전하게 재시도할 수 있다는 것이다.

**ACID 데이터베이스는 이 철학을 바탕으로하지만 모든 시스템이 따르지는 않는다.**

**“리더 없는 복제”**를 사용하는 데이터스토어는 오류가 발생하면 이미 한 일은 취소하지 않아 오류 복구를 애플리케이션에게 책임을 묻는다.

abort된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지 않다.

- 완벽하지 않는 사례
    - 트랜잭션이 실제로는 성공했지만 서버가 클라이언트에게 **commit 성공을 알리는 도중 네트워크가 끊겼을 때** (클라이언트는 실패 상태로 판단한다.) 재시도하면 트랜잭션이 두 번 실행된다. → 애플리케이션이 추가적인 중복 제거 메커니즘을 처리해야 한다.
    - **오류가 과부하 때문이라면 트랜잭션 재시도는 문제 개선이 아닌 악화가 될 수 있다.** 이런 피드백 주기를 피하려면 재시도 횟수를 제한하든지 지수적 백오프를 사용하거나 과부화와 관련된 오류를 다른 오류와 별도로 처리하는 방법을 써야 한다.
    - 일시적인 오류 (교착 상태, 격리성 위반, 일시적인 네트워크 단절, 장애 복구)만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 아무 소용이 없다.
    - 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 abort 될 때도 부수 효과가 실행될 수 있다. 여러 개의 다른 시스템들이 반드시 함께 커밋되거나 abort 되게 만들고 싶다면 2단계 커밋이 도움될 수 있다.
    - 클라이언트 프로세스가 재시도 중에 죽으면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

# 2. 완화된 격리 수준

동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다. 그래서 데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.

- 직렬성 격리
    - 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장한다는 것을 의미 (동시성 없이 한 번에 트랜잭션 하나만 실행)

하지만 직렬성 격리는 성능 비용이 있다. 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지 않는 **“완화된 격리 수준”**을 사용하는 시스템들이 흔하다. 이러한 격리성 수준은 이해하기 어렵고 미묘한 버그를 유발할 수 있음에도 현장에서 사용된다.

## 1) 커밋 후 읽기 (Read Committed)

- 보장
    - 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (dirty read 없음)
    - 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (dirty write 없음)

### 1-1) 더티 읽기 방지 (dirty read)

- dirty read
    - 트랜잭션이 데이터베이스에 데이터를 썼지만 아직 commit 되거나 abort 되지 않은 경우에 다른 트랜잭션에서 볼 수 있는 상황을 의미한다.
- dirty read 막는 게 유용한 이유
    - 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스럽다. 또한 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수도 있다.
    - 트랜잭션이 abort 되면 그때까지 쓴 내용을 모두 rollback해야 한다. dirty read가 허용되면 트랜잭션이 나중에 rollback될 데이터를 볼 수도 있다.

![image](https://github.com/user-attachments/assets/32d9a275-d890-49c0-9fad-f63e8397845c)

### 1-2) 더티 쓰기 방지 (dirty write)

- dirty write
    - 아직 commit 되지 않은 트랜잭션에서 쓴 내뇬을 나중에 실행된 쓰기 작업이 commit 되지 않은 값을 덮어 쓰는 경우

![image](https://github.com/user-attachments/assets/52dcea63-e5ae-4563-9327-b9c062fb1b9a)

### 1-3) 커밋 후 읽기 구현

로우 수준 잠금을 사용해 dirty write를 방지한다.

dirty read를 막기 위해서는 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하면 된다.

하지만 읽기 잠금은 현실에서 잘 동작하지 않는다. 잠금 대기 때문에 지연이 발생할 수 있기 때문이다. 이를 MVCC 같은 쓰여진 모든 객체에 대해 데이터베이스가 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 값을 기억하는 방식으로 처리할 수 있다.

## 2) 스냅숏 격리와 반복 읽기

- 비반복 읽기 (nonrepeatable read), 읽기 스큐 (read skew)
    - 엘리스 계좌 잔고는 1,000인데 엘리스가 보는 계좌 잔고는 900 일 수 있다.

![image](https://github.com/user-attachments/assets/209ef445-4b0b-4d68-be86-74bd569dc5ec)

이러한 계좌 잔고 문제가 지속적인 문제는 아니다. 하지만 이러한 일시적인 상황이 문제가 되는 경우도 있다.

- 백업
    - 백업 프로세스가 실행되는 동안에도 계속 데이터베이스에 쓰기가 실행된다. 따라서 백업의 일부는 데이터의 과거 버전을, 다른 부분은 새 버전을 갖고 있을 수 있다. 이런 백업을 사용해서 복원하면 비일관성이 영속적이게 된다.
- 분석 질의와 무결성 확인
    - 데이터베이스의 큰 부분을 스캔하는 질의를 실행하고 싶은 경우가 있다. 이런 질의는 다른 시점의 데이터베이스의 일부를 보게 되면 불합리한 결과를 반환할 수도 있다.

**“스냅숏 격리”**는 이런 문제를 가장 흔하게 해결할 수 있다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다. 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.

### 2-1) 스냅숏 격리 구현

스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 dirty write를 방지하기 위해 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요 없다.

- 핵심 원리
    - 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다. → 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.

**다중 버전 동시성 제어 (Multi-Version Concurrency Control, MVCC)**

커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용한다.

![image](https://github.com/user-attachments/assets/bf443050-7087-4db5-9869-d2aeae2177c4)

### 2-2) 일관된 스냅숏을 보는 가시성 규칙

- 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다.
- abort 된 트랜잭션이 쓴 데이터는 모두 무시된다.
- 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 commit 여부에 관계 없이 모두 무시된다.
- 그 밖의 모든 데이터는 애플리케이션 질의로 볼 수 있다.

### 2-3) 색인과 스냅숏 격리

다중 버전 데이터베이스에서 색인 동작

- 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러낸다.

여러 구현 세부 사항에 따라 다중 버전 동시성 제어의 성능이 결정된다.

- postgres
    - 동일한 객체의 다른 버전들이 같은 페이지(page)에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다.
- 카우치DB, 데이토믹, LMDB
    - (B트리를 사용하지만 추가 전용이며 쓸 때 복사되는(append-only/copy-on-write) 변종을 사용한다.)
    - 트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다. 트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고 그것들의 자식 페이지들의 새 버전을 가리키도록 갱신된다. 쓰기에 영향을 받지 않는 페이지들은 복사될 필요가 없고 변함 없는 상태로 남는다. → 복사한다고…?

**추가 전용 B 트리**를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B 트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다. 나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B 트리를 변경할 수 없으므로 트랜잭션 ID를 기반으로 객체를 걸러낼 필요가 없다. 이 방법도 **컴팩션과 가비지 컬렉션을 실행하는 백드라운드 프로세스가 필요하다.**

### 2-4) 반복 읽기와 혼란스러운 이름

스냅숏 격리를 유용한 격리 수준으로 읽기 전용 트랜잭션에 유용하다. 데이터베이스에서는 서로 다른 이름을 사용한다. SQL 표준에 스냅숏 격리의 개념이 없기 때문이다.

- oracle
    - 직렬성
- postgres, mysql
    - 반복 읽기

## 3) 갱신 손실 방지

- 갱신 손실 (lost update) 문제
    - 애플리케이션이 데이터베이스에서 값을 읽고 → 변경하고 → 변경된 값을 다시 쓸 때 발생할 수 있다. (read-modify-write 주기)

### 3-1) 원자적 쓰기 연산

원자적 쓰기 연산은 애플리케이션 코드에서 read-modify-write 주기를 구현할 필요를 없애 준다.

아래 명령은 대부분의 관계형 데이터베이스에서 동시성에 안전하다.

```sql
UPDATE counters
SET value = value + 1
WHERE key = 'foo'
```

원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. 이 기법을 **“커서 안전성(cursor stability)”**이라고 부른다. 다른 선택지는 모든 원자적 연산을 단일 스레드에서 실행디도록 강제하는 것이다.

### 3-2) 명시적인 잠금

데이터베이스에서 내장된 원자적 연산이 필요한 기능을 제공하지 않는다면 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다. 이를 통해 애플리케이션이 read-modify-write 주기를 수행할 수 있다. (다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 대기하도록 만든다.)

```sql
BEGIN TRANSACTION;

SELECT *
FROM figures
WHERE name = 'robot'
AND game_id = 222
FOR UPDATE;

UPDATE figures
SET position = 'c4'
WHERE id = 1234;

COMMIT;
```

### 3-3) 갱신 손실 자동 감지

원자적 연산과 잠근은 read-modify-write 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다. 대안으로 이들을 병렬 실행하고 트랜잭션 관리자가 갱신 손실 발견 시에 abort 하고 재시도 하도록 하는 방법이 있다.

mysql/innoDB의 반복 읽기는 갱신 손실을 감지하지 않지만 postgres, oracle, sql은 갱신 손실이 발생하면 자동으로 발견해서 문제가 되는 트랜잭션을 abort 시킨다.

### 3-4) Compare-and-Set

트랜잭션을 제공하지 않는 데이터베이스 중에서는 원자적 CAS 연산을 제공하는 것도 있다. 그러나 데이터베이스가 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다.

### 3-5) 충돌 해소와 복제

복제가 적용된 데이터베이스에서 갱신 손실을 막는 것은 다른 차원의 문제다.

- 해결 방식
    - 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합한다.
    - 교환 법칙이 성립하는 연산이라면 원자적 연산은 복제 상황에서도 잘 동작한다. (다른 복제본에 다른 순서로 연산을 적용해도 같은 결과가 나오는 경우)

최종 쓰기 승리(Last Write Wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽지만 많은 복제 데이터베이스에서 LWW가 기본 설정이다.

## 4) 쓰기 스큐와 팬텀

앞에서 dirty write와 lost update를 살펴봤다. 하지만 동시에 실행되는 쓰기 작업 사이에 잠재적으로 발생할 수 있는 경쟁 조건은 이게 전부가 아니다.

![image](https://github.com/user-attachments/assets/82900c10-80cf-4244-b904-9dbe0fa09fdb)

### 4-1) 쓰기 스큐(write skew)를 특징 짓기

- 쓰기 스큐
    - 두 트랜잭션이 두 개의 다른 객체를 갱신하므로 dirty write도 lost update도 아니다.
- 쓰기 스큐 선택지
    - 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움 되지 않는다.
    - 일부 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움 되지 않는다. 직렬성 격리가 필요하다.
    - 제약 조건을 사용하여 데이터베이스에 의해 엄격하게 준수하게 할 수 있다. (trigger, materialized view)
    - 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다.

### 4-2) 추가적인 쓰기 스큐 예

- 회의실 예약 시스템
- 다중플레이어 게임
- 사용자명 획득
- 이중 사용 방지

### 4-3) 쓰기 스큐를 유발하는 팬텀

위에서의 의사 호출 대기 예시의 경우 SELECT FOR UPDATE을 이용해 로우를 잠금으로써 write skew를 회피할 수 있다. 하지만 검색 조건에 부합하는 로우가 존재하지 않는다면 아무것도 잠글 수 없다.

이처럼 어떤 트랜잭션에서 실행한 쓰기 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 **팬텀(phantom)**이라고 한다.

### 4-4) 충돌 구체화

팬텀의 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가할 수도 있다. 이러한 방식을 “충돌 구체화 (materializing conflic)”라고 한다. 

- 단점
    - 충돌을 구체화하는 방법을 알아내기 어렵고 오류가 발생하기 쉽다.
    - 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나온다.

대부분의 경우 직렬성 격리 수준이 훨씬 더 선호된다.

# 3. 직렬성

직렬성 격리는 가장 강력한 격리 수준이다. 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 떄와 같도록 보장한다.

하지만 직렬성 격리가 여러 완화된 격리 수준보다 훨씬 더 좋은데 사용하지 않는 이유가 뭘까? 오늘날 직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.

- 말 그대로 트랜잭션을 순차적으로 실행하기
- 수십 년 동안 유일한 수단이었던 2PL
- 직렬성 스냅숏 격리 같은 낙관적 동시성 제어 기법

## 1) 실제적인 직렬 실행

동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하면 된다. → 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다.

- 단일 스레드 실현 가능하게된 이유
    - 램 가격이 저렴해짐 → 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다. → 트랜잭션이 접근해야 하는 모든 데이터가 메모리에 있다면 데이터를 디스크에서 읽어 오기를 기다려야 할 때보다 트랜잭션이 훨씬 빨리 실행될 수 있다.
    - OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달음 → 반대로 오래 실행되는 분석 질의는 전형적으로 읽기 전용이라서 직렬 실행 루프 밖에서 일관된 스냅숏을 사용해 실행할 수 있다.

트랜잭션을 순차적으로 실행하는 방법은 볼트DB/H-스토어, 레디스, 데이토믹에서 구현돼있다.

단일 스레드로 실행되도록 설계된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 떄도 있다. → 잠금을 코디네이션하는 오버헤드를 피할 수 있다.

하지만 처리량은 CPU 코어 하나의 처리량으로 제한된다. → 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.

### 1-1) 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

거의 OLTP 애플리케이션은 트랜잭션 내에서 대화식으로 사용자 응답을 대기하는 것을 회피하여 트랜잭션을 짧게 유지한다.

![image](https://github.com/user-attachments/assets/5c5e513c-1e40-4299-beba-5aa848cf227f)

- 상호작용식 트랜잭션
    - 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비한다.
    - 데이터베이스에서 동시성을 허용하지 않고 한 번에 트랜잭션 하나씩만 처리하면 처리량이 매우 낮을 것이다.
    - 데이터베이스가 애플리케이션에서 현재 트랜잭션의 다음 질의를 발행하기를 대기하는 데 대부분의 시간을 쓰게 되기 때문이다.
- 단일 스레드
    - 트랜잭션을 순차적으로 처리하는 시스템들은 상호작용하는 다중 구문 트랜잭션을 허용하지 않는다.
    - 애플리케이션은 트랜잭션 코드 전체를 “스토어드 프로시저” 형태로 데이터베이스에 미리 제출해야 한다.
    - 트랜잭션에 필요한 데이터는 모두 메모리에 있고 스토어드 프로시저는 네트워크나 디스크 I/O 대기 없이 매우 빨리 실행된다고 가정한다.

### 1-2) 스토어드 프로시저의 장단점

- 단점
    - 데이터베이스 벤더마다 제각각 스토어드 프로시저용 언어가 있다. → 범용 프로그래밍 언어의 발전을 따라잡지 못해서 오늘날의 관점에서 조잡하고 낡아 보인다.
    - 데이터베이스에서 실행되는 코드는 관리하기 어렵다. → 애플리케이션 서버와 비교할 때 디버깅하기 어렵고 버전 관리 및 배포가 불편하며 테스트하기도 까다롭고 모니터링용 지표 수집 시스템과 통합하기도 어렵다.
    - 데이터베이스는 애플리케이션 서버보다 훨씬 더 성능에 민간할 때가 많다. → 여러 애플리케이션에서 데이터베이스 인스턴스 하나를 공유하기 때문이다.
- 단점 극복
    - 현대 스토어드 프로시저 구현은 범용 프로그래밍 언어를 사용한다. → 볼트DB는 자바, 그루비를 사용한다.
    - 스토어드 프로시저가 있고 데이터가 메모리에 저장된다면 모든 트랜잭션을 단일 스레드에서 실행하는게 현실성 있다. → I/O 대기가 필요없고 다른 동시성 제어 메커니즘의 오버헤드를 회피하므로 단일 스레드로 좋은 처리량을 얻을 수 있다.

### 1-3) 파티셔닝

여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수도 있다.

각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝 할 수 있다면 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스세드를 가질 수 있다. 각 CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 코어 개수에 맞춰 선형적으로 확장할 수 있다.

여러 파티션에 접근해야 하는 트랜잭션이 있다면 스토어드 프로시저는 전체 시스템에 걸쳐 직렬성을 보장하기 위해 모든 파티션에 걸쳐 잠금을 획득한 단계에서 실행돼야 한다. → 단일 파티션 트랜잭션보다 느리다.

트랜잭션이 단일 파티션에서 실행될 수 있는지 여부는 애플리케이션에서 사용되는 데이터 구조에 매우 크게 의존한다. 

### 1-4) 직렬 실행 요약

- 모든 트랜잭션은 작고 빨라야 한다.
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다.
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 사용하는 정도에는 엄격한 제한이 있다.

## 2) 2단계 잠금(2PL)

데이터베이스 직렬성을 구현하는데 널리 쓰인 알고리즘으로 2PL(two-phase locking)이 있다.

- 2PL
    - 쓰기 트랜잭션은 다른 쓰기 뿐만아니라 읽기 트랜잭션도 진행하지 못하게 막고 진행한다.
    - 직렬성을 제공하므로 lost update, write skew를 포함한 모든 경쟁 조건으로부터 보호해준다.

### 2-1) 2PL 구현

2PL은 MySQL, SQL 서버에서 직렬성 격리 수준을 구현하는데 사용되고 DB2에서는 반복 읽기 격리 수준을 구현하는데 사용된다.

- 잠금
    - 트랜잭션이 객체를 일기 원한다면 공유 모드로 잠금을 획득한다. → 공유 모드인 경우 동시에 여러 트랜잭션이 잠금을 획득할 수 있지만 이미 객체에 독점 모드로 잠금을 획득한 트랜잭션이 있다면 완료될 때까지 기다린다.
    - 트랜잭션이 객체를 읽다가 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다.
    - 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 한다.
    - 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때까지 잠금을 갖고 있어야 한다. → 2PL이라고 하는 이유는 첫 번째 단계는 잠금 획득을, 두 번째 단계는  모든 잠금 해제를 의미한다.

### 2-2) 2PL 성능

2PL의 큰 약점은 성능이다.

- 부분적으로 잠금을 획득하고 해제하는 오버헤드
- 동시성이 줄어든다.

잠금 기반 커밋 후 읽기 격리 수준에서도 교착 상태가 생길 수 있지만 2PL 직렬성 격리에서는 더 자주 발생할 수 있다. → 교착 상태는 부가적인 성능 문제가 될 수 있다.

### 2-3) 서술 잠금 (predicate lock)

서술 잠금은 공유/독점 잠금과 비슷하지만 특정 객체(테이블 내의 한 레코드)에 속하지 않고 검색 조건에 부합하는 모든 객체에 속한다.

```sql
SELECT *
FROM bookings
WHERE room_id = 123
AND end_time > '2018-01-01 12:00'
AND start_time < '2018-01-01 13:00'
```

서술 잠금은 데이터베이스에 아직 존재하지 않지만 미래에 추가될 수 있는 객체(팬텀)에도 적용할 수 있다.

### 2-4) 색인 범위 잠금

서술 잠금은 잘 동작하지 않는다. 진행 중인 트랜잭션들이 획득한 잠금이 많으면 조건에 부합하는 잠금을 확인하는데 시간이 오래 걸린다. 이 때문에 2PL을 지원하는 대부분의 데이터베이스는 실제로는 색인 범위 잠금(index-range locking, 다음 키 잠금(next-key locking))을 구현한다.

- room_id에 색인이 있는 경우
    - 데이터베이스는 이 색인 항목에 공유 잠금을 잡아서 트랜잭션이 123번 방에 대한 예약을 검색했다고 표시할 수 있다.
- 데이터베이스에서 존재하는 예약을 찾는데 시간 기반 색인을 사용하는 경우
    - 색인에 있는 값들의 범위에 공유 잠금을 잡는다.

색인 범위 잠금은 서술 잠금보다 정밀하지 않지만 오버 헤드가 훨씬 낮아 좋은 타협안이 된다.

## 3) 직렬성 스냅숏 격리(SSI)

직렬성 스냅숏 격리(serializable snapshot isolation, ssi)라는 알고리즘이 위에서 얘기한 것보다 성능이 좋다.

완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있을 뿐이다.

### 3-1) 비관적 동시성 제어 대 낙관적 동시성 제어

2PL은 비관적 동시성 제어 메커니즘이다.

직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다. 위험한 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아질 것이라는 생각으로 계속 진행한다. 트랜잭션이 커밋되기 전에 나쁜 상황이 발생했는지 확인하고 그럴 경우 트랜잭션은 abort 되고 재시도해야 한다. → 직렬로 실행된 트랜잭션만 커밋이 허용된다.

### 3-2) 뒤처진 전제에 기반한 결정

스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최신이 아닐 수 있다.

직렬성 격리를 제공하려면 데이터베이스는 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 abort 시켜야 한다.

- 질의 결과가 바뀌었는지 아는 방법
    - 오래된 MVCC 객체 버전을 읽었는지 감지하기
    - 과거의 읽기에 영향을 미치는 쓰기 감지하기

### 3-3) 오래된 MVCC 읽기 감지하기

다른 트랜잭션의 쓰기를 무시하는 경우를 찾아서 커밋된게 있다면 abort 해야 한다.

![image](https://github.com/user-attachments/assets/4c7725f6-9d32-4b13-b0be-72eab35c39d7)

### 3-4) 과거의 읽기에 영향을 미치는 쓰기 감지하기

데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인한다. 트랜잭션이 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려주면 abort 해야 한다.

![image](https://github.com/user-attachments/assets/c9cc333d-4c23-44a6-b190-b08a94ed8695)

### 3-5) 직렬성 스냅숏 격리의 성능

트레이드 오프는 트랜잭션의 읽기 쓰기를 추적하는 세밀함의 정도다. 데이터베이스가 각 트랜잭션의 동작을 매우 상세하게 추적하면 abort 돼야 하는 트랜잭션을 정확히 판별할 수 있지만 기록 오버헤드가 심해질 수 있다.

postgres의 경우 때로는 데이터가 덮여쓰여졌음에도 실행 결과가 직렬적이라는 것이 가능하면 불필요한 abort 개수를 줄인다.

2PL과 비교했을 때 읽는 쪽도 쓰는 쪽도 막지 않는다.

순차 실행과 비교하면 단일 CPU 코어의 처리량에 제한되지 않는다.

abort 비율은 SSI의 전체 성능에 큰 영향을 미친다. 그러나 SSI는 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감하다.
