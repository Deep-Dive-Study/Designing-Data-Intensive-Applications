# 7장 트랜잭션

현실 세계에서의 데이터 시스템은 어떤 문제든 생길 수 있다.

- ﻿﻿데이터베이스 소프트웨어나 하드웨어는 (쓰기 연산이 실행 중일 때를 포함해서) 언제라도 실패할 수 있다.
- ﻿﻿애플리케이션은 (연속된 연산이 실행되는 도중도 포함해서) 언제라도 죽을 수 있다.
- ﻿﻿네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- ﻿﻿여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- ﻿﻿클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- ﻿﻿클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

트랜잭션은 시스템 신뢰성을 높이기 위해, 전체 시스템의 장애로 이어지는것을 단순화 하기 위한 메커니즘이다.

몇개의 읽기와 쓰기를 하나의 논리적 단위로 한 연산으로 묶는것이다.

트랜잭션을 사용함으로써 어느정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다. 

다양한 경쟁 조건과 read committed, snapshot isolation, serializability같은 격리 수준의 원리를 알아보자

## 애매모호한 트랜잭션의 개념

2000년대 후반 NoSQL DB를 주되게 사용함으로써, 이 DB들의 다수는 트랜잭션을 포기하거나 과거보다 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의 했다. 그러나 트랜잭션이 제공하는 세부 사항을 상세히 확인해보고 적합하게 사용해야 한다

### ACID의 의미

**ACID 특성**

- **Atomicity(원자성)**: 트랜잭션의 모든 연산이 전부 성공하거나 전부 실패(Abort/롤백)
- **Consistency(일관성)**: 트랜잭션 전후의 데이터베이스가 정의된 제약조건을 항상 만족
- **Isolation(격리성)**: 동시에 실행되는 트랜잭션 간의 상호 간섭 방지
- **Durability(내구성)**: 커밋된 결과는 시스템 오류가 나도 보존

* ACID 표준을 따르지 않는 시스템은 BASE라고 하며, 기본 가용성(Basicially Available), 유연한 상태(Soft state), 최종 일관성(Eventual consistency)를 지닌다는 것.

#### 원자성 (Atomicity)

원자 : 더 작은부분으로 쪼갤 수 없는 무언가. 원자성은 동시성과 관련이 없음

ACID에서 말하는 원자성은, 여러 쓰기 작업 수행시 일부만 처리되는 케이스는 없도록 한것.

원자성 없이는 여러 변경 적용 도중 오류 발생시, 어떤 변경은 효과가 있꼬 어떤 것은 그렇지 않은지 알기 어려움.

오류 생겼을 시 트랜잭션을 abort하고 취소하는 것은 원자성의 특징이다.

#### 일관성(consistency)

일관성은 여러 의미로 쓰임

원자성 격리성 지속성은 DB속성인 반면, 일관성은 애플리케이션의 속성이다. 외래키 제약조건이나 유니크 제약조건을 쓸 순 있지만 일반적으로 DB는 애플리케이션에서 데이터가 유효한지 아닌지 판단하고 그걸 저장할 뿐이다. 

#### 격리성 (isolation)

여러 클라이언트에서 동시 DB 접속시 동일 레코드에 접근하면 동시성 문제가 생긴다.

ACID에서 격리성은 동시 실행 트랜잭션은 서로 격리된다는것을 의미하며, 다른 트랜잭션을 방해할 수 없는것으로 정의한다.

#### 지속성(durability, 내구성)

지속성은 트랜잭션이 성공적으로 커밋된다면, 하드웨어 결함이나 DB가 죽더라도 기록한 모든 데이터는 손실되지 않는다는 보장이다.

### 단일 객체 연산과 다중 객체 연산

ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 쓰기를 하면 DB가 어떻게 해야하는지를 정의함

* 원자성 : 쓰기 이어 실행 도중 오류 발생시 트랜잭션은 어보트 돼야 하고, 쓰여진 내용은 폐기되어서 전부 반영되거나 전부 실패해야함.
* 격리성 : 동시 실행되는 트랜잭션들은 서로를 발해하지 말아야 함. 한 트랜잭션이 여러번쓴다면, 다른 트랜잭션은 그 내용을 전보 볼수있던지 아무것도 볼수없든지 해야 함.

### 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다. 예를 들어 20KB의 JSON 문서를 데 이터베이스에 쓴다고 해보자.

- ﻿﻿첫 10KB를 보낸 후에 네트워크 연결이 끊기면 데이터베이스는 파싱 불가능한 10KB의 JSON 조각을 저장할 것인가?
- ﻿﻿데이터베이스가 디스크에 저장된 기존 값을 덮어쓰는 도중에 전원이 나가면 기존 값과 새 값이 함께 붙어 있게 될까?
- ﻿﻿문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면 부분적으로 갱신된 값을 읽게 될까?

위 문제를 방지할 수도 있지만 트랜잭션은 보통 다중 연산을 하나의 실행단위로 묶는 메커니즘

### 다중 객체 트랜잭션의 필요성

많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기함. 여러 노드에 걸쳐 구현하기가 어렵고 가용성과 성능이 잘 안나오기 때문

많은 경우에는 여러 쓰기 작업이 중재 되어야 함

* 몽고디비같은경우, 데이터가 비정규화되어있어 중복되어있는데 갱신할때 한번에 여러 문서를 갱신해야 해서 트랜잭션이 필요함
* 보조 색인이 있는 DB에서는 값 변경시 보조 색인도 변경되어야하는데 트랜잭션 관점에서 색인과 보조 색인은 다른 객체임. 이 둘이 일치하지 않을수도 있음

### 오류와 어보트 처리

많은 애플리케이션은 어보트된 트랜잭션을 재시도하지 않음. 왜?

* 실제로는 성공했지만 커밋 성공을 알리는 네트워크가 끊겻을 시 재시도시하면 트랜잭션이 두번 실행됌. 중복 처리 메커니즘이 없으면 큰일
* 오류가 과부하때문이라면 재시도시 장애를 추가로 유발 가능.
* 일시적인 오류만 재시도할 가치가 있음. 제약조건 위반 등은 재시도할 필요가 없음 
* 클라이언트가 재시도중에 죽어버리면 db에 쓰려고 했던 데이터가 모두 손실됌

## 완화된 격리 수준

같은 데이터를 동시에 쓰려는 동시성 문제를 트랜잭션은 격리로 해결하려고 한다.

그러나 직렬로(serialize)처리하려고 하면 간단하지않다. 

* 성능 비용이 있음 매우 느려질 수 있음.

때문에 완화된 격리 수준을 사용하는 시스템들이 흔함. 왜? 어차피 100% 보장할 수 없기 때문임

애플리케이션에서 좀더 완화된 방법을 알아보자

### 커밋후 읽기

가장 기본적인 수준. read committed. 이것은 2가지를 보장해줌

1. 읽을때 커밋된 데이터만 보게 됌 - 더티 읽기가 없음
2. 쓸때 커밋된 데이터만 덮어씀 - 더티 쓰기가 없음

#### 더티 읽기 방지

다른 트랜잭션에서 커밋되지 않은 데이터를 보는것이 더티 읽기이다. 

왜 필요할까?

* 더티 읽기가 생기면, 어떤 트랜잭션은 갱신된 값을, 어떤 트랜잭션은 갱신되지 않은 값을 읽어 버그 유발 가능
* 트랜잭션 어보트시 모두 롤백되어야 하는데, 디비가 더티 읽기를 허용하면 트랜잭션이 롤백될 데이터 즉 아직 커밋되지 않은 데이터를 볼 수 있게 됌

#### 더티 쓰기 방지

나중에 쓴 내용이 먼저 쓴 내용을 덮어 쓰는 문제.

먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴것이고 나중에 쓴것이커밋되지 않은 값을 덮어써버리는 문제.

이걸 막으므로써 아래를 회피한다.

* 밥과 앨리스가 같은 차를 사려고 할 때, 밥에게 판매됐지만, 이후 앨리스가 바로 덮어써서 앨리스에게 송장이 전달될 수 있음
* 그리고 숫자 카운트를 두번 증가시켜야하는데 한번만 증가될 수도 있음.

### 커밋 후 읽기 구현

2단계로 매우 널리 쓰이는 격리 수준, 오라클, pg 등의 기본 설정

로우 수준 가벼운 잠금을 사용해 더티 쓰기를 방지하고, 트랜잭션이 객체를 변경하고 싶다면 객체에 대한 잠금을 획득해야 함. 

더티 읽기는 어떻게 막을 수 있을까? 잠금을 쓰면 너무 느려짐.

과거 값을 유지해서 다른 트랜잭션이 과거 값을 읽게 만들면 됌 -> 스냅숏

#### 스냅숏 격리와 반복 읽기

스냅숏 격리는, 트랜잭션 시작 시점의 스냅숏을 만들어 놓고 **스냅숏(정합된 복사본)**을 읽게 하는것.

non repeateable read 문제는, 한 트랜잭션 내에서 같은 데이터를 읽는데 외부 트랜잭션에서 읽는 도중 수정해서 두번째 읽었을 때 읽은 값이 바뀐 문제.

스냅숏 격리는 이런 문제의 가장 흔한 해결책으로  DBMS마다 다르지만 MVCC 기반으로 동작함. 그러나 팬텀 리드 자체는 방지하지 못함

* 팬텀리드 : 트랜잭션 내에서 같은 조건의 쿼리를 두 번 실행했는데, 두 번째에 새로운 행(=팬텀)이 튀어나오는 현상

* 스냅숏의 핵심은 읽는 쪽에서 쓰는 쪽을 차단하지 않고 쓰는 쪽에서 읽는 쪽을 차단하지 않는것.,

postgresql은 트랜잭션 마다 id를 부여해 트랜잭션에 의해 생성되거나 수정된 row의 페이지에 txid 값을 붙이고, 다음 트랜잭션 id값으로 비교하면서 이것을 구현함.

#### 일관된 스냅숏을 보는 가시성 규칙

txid를 이용해 어떤것을 볼 수 있는지 없는지 결정한다.

1. ﻿﻿﻿데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인(아직 커밋이나 어보트가 되지 않은) 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다. 설령 데이터를 쓴 트랜잭션이 나중에 커밋되더라도 마찬가지다.
2. ﻿﻿﻿어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. ﻿﻿﻿트랜잭션 ID가 더 큰(즉 현재 트랜잭션이 시작한 후에 시작한) 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없 이 모두 무시된다.
4. ﻿﻿﻿그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

#### 반복 읽기

스냅숏 격리는 읽기 전용 트랜잭션에 유용하다. 이름이 헷갈리긴 하는데 오라클에서는 직렬성,

pg와 mysql에서는 repeatable read라고 한다

* 이런 이유는 SQL 표준에는 스냅숏 격리라는 개념이 없음

### 갱신 손실 방지

지금까지는 더티 리드를 방지하는 방법이고 갱신 손실은 다른 문제다.

갱신손실은 두 개 이상의 트랜잭션이 같은 데이터를 읽고 수정한 뒤, 마지막에 커밋된 트랜잭션이 이전 트랜잭션의 수정을 덮어써서 손실이 발생하는 것

주로 아래 와 같은 시나리오에서 발생

* 카운터 증가 및 계좌 잔고 갱신시
* JSON 문서 내에 리스트에 엘레먼트 추가시

해결방법

#### 원자적 쓰기 연산

read-modify-write 대신하는 방법들을 제공함

rdb같은경우는 이렇게하면 안전하다고 한다

```
UPDATE counters SET value = value + 1 WHERE key = 'foo'
```

* DB가 내부적으로 이 문장을 **원자적(atomic)** 으로 처리하기 때문
* 해당 행에 내부적으로 exclusive lock락을 걸음 -> `UPDATE` 명령어는 자동으로 `FOR UPDATE` 락을 내재적으로 사용

몽고 DB도 일부를 변경하는 원자 연산을 제공하고, 레디스는  prioritiy queue같은 구조에서 right out left in은 원자적 연산을 제공함 

#### 명시적 잠금

이건 LOCK임

 Row-level Lock 종류

| 락 이름             | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| `FOR UPDATE`        | update/delete 충돌 방지용, 다른 트랜잭션의 동일 행 접근 대기 |
| `FOR NO KEY UPDATE` | foreign key 등 key 변경 없을 때 사용                         |
| `FOR SHARE`         | 읽기 용도                                                    |
| `FOR KEY SHARE`     | 외래 키 읽기용                                               |

데드락, 성능저하 유발 가능

#### 갱신 손실 자동 감지 - compare-and-set

이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을때만 갱신을 허용하는것임 (어떻게 보면 낙관적 락)

```
UPDATE pages SET content = 'new content'
WHERE id = 1234 AND content = 'old content';
```



### 쓰기 스큐와 팬덤

동시 실행된 두 트랜잭션이 조건을 만족하고 각각 다른 객체를 갱신하지만, 그 결과로 전체 시스템 제약을 위반하게 되는 현상.

* 더티쓰기도 갱신 손실도 아님.

다른 한명이 존재해서 최소 한명이라는 조건을 위반함.

* **동시에 실행된 트랜잭션들이 각각 “조건을 만족한다고 착각”하고 데이터를 수정해서**,
  **결과적으로 시스템 규칙이나 불변 조건(invariant)을 깨뜨리는 현상**

**대표 예시: 의사 호출 대기 시스템**

- 병원은 항상 **최소 한 명**의 의사가 대기 중이어야 함
- 앨리스와 밥 모두 동시에 “다른 사람이 있으니 나는 나가도 되겠지”라고 판단하고 각각 자신의 대기 상태를 끔
- 두 트랜잭션 모두 커밋 → **결과적으로 아무도 대기하지 않게 됨**
- 💥 시스템 제약 위반 (동시성 문제지만 row 충돌은 없음)

**특징**

- **동일한 객체를 수정하지 않아도 발생**
- **스냅숏 격리 수준에서는 감지되지 않음**

다른 예

* 회의실 예약 시스템 : 중복 예약할 수 없게 하고 싶을 때 충돌하는 예약이 있는지 확인하고 없다면 예약 
  * 스냅숏 격리로 막을 수 없음
* 다중 플레이어 게임 : 갱신 손실 방지위에 잠금을 사용해도, 두 플레이어가 다른 아이템을 움직이는것 자체를 막아주진 않음
* 사용자명 획득 : 유일한 사용자명을 가져야 할 때, 동시에 같은 사용자명으로 계정 생성 시도 불가능 -> 이케이스는 유일 제약 조건이 해결책

#### 쓰기 스큐를 유발하는 팬텀 

이 모든 예는 비슷한 패턴을 따름

1. SELECT가 조건에 맞는 로우를 검색함으로써 요구사항을 만족하는지 확인함. 

2. 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정함
3. 처리하기로 했다면 DB에 쓰고 트랜잭션을 커밋함. 그러나 질의를 재실행하면 다른 결과를 얻게됌

즉. 어떤 트랜잭션에서 실행한 쓰기가, 다른 트랜잭션의 질의 결과를 바꾸는 효과를 팬텀 리드라고 한다.

## 직렬성

경쟁 조건 감지에 도움이 되는 좋은 도구도 없고, 테스트하기도 어렵다.

이경우 직렬성을 이용하면 된다

싱글스레드로 요청을 처리하는 레디스 같은 방식도 있다.

그러나 DB에서 한번에 하나 트랜잭션만 처리하면 처리량은 매우 낮아진다.

## 2단계 잠금

2PL 말고 2단계 잠금.

트랜잭션에서 **잠금(lock)** 을 사용하는 방식 중 하나로,
 **모든 잠금을 먼저 획득하고** → **모두 해제하는 규칙**을 따르는 동시성 제어 기법

- ﻿﻿트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때 까지 기다려야 한다(이렇게 하면 B가 A 몰래 갑자기 객체를 변경하지 못하도록 보장된다).
- ﻿﻿트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기 다려야 한다(그림 7-4에 나왔듯이 2PL을 쓸 때는 객체의 과거 버전을 읽는 게 허용되지 않는다).

구현 방법

각 객체에 잠금을 사용해 구현함. 잠금음 shard랑 exclusive로 할 수 있음. -> 비관적 동시성 제어 

단점으로 교착 상태 발생 가능하게도 함.

### 2단계 잠금의 성능

동시성이 줄어들어 처리량과 질의 응답 시간이 매우 느려짐. 또한 데드락도 매우 발생 확률이 높아짐

### 서술 잠금

predicate lock : **특정 조건(Predicate)을 만족하는 모든 레코드에 대한 잠금**
 → 심지어 **아직 존재하지 않는 데이터까지 포함해서** 락을 거는 방식

```sql
select * from bookings
where room_id = 123 and
end_time > 2024~
and start_time < 2025~
```

이케이스는 미래에 추가될 팬텀에도 적용할 수 있게 됌. 

### 직렬성 스냅숏 격리 SSI

이 알고리즘은 스냅숏 격리에 비해 약간의 성능 손해만 있을 분 좋은 알고리즘

#### 비관적 동시성 제어 vs 낙관적 동시성 제어

2단계 잠금은 비관적 동시성 제어 메커니즘임 .

SSI는 낙관적 동시성 제어 기법임

충돌이 발생하지 않는다고 보거나, 충돌이 발생하면 어보트하고 재시도 가능하게 하는것.

계속 재시도되면 부하를 어느정도 유발하겠지만, 그래도 비관적 동시성 제어보다는 성능이 좋은 경향이 있다.

스냅숏 격리를 기반으로 일관된 스냅숏을 보고 충돌을 감지한다

* 낙관적 락이랑은 다른거 같음. DB의 Serializable isolation level 같음. 

**오래된 읽기를 기반으로 잘못된 판단을 하면 안 됨** → 감지 필요

```
1. 트랜잭션이 스냅숏에서 읽기 수행 → 읽은 범위 기록 (SIREAD lock)
2. 다른 트랜잭션이 해당 범위에 쓰기 시도 → 충돌 정보 기록
3. 커밋 시:
   - 충돌 감지 → 충돌이 직렬화를 위배하면 어보트
   - 충돌 없거나 무해하면 커밋 허용
```

PostgreSQL은 이를 위해 **SIREAD (Serializable Read) 락** 을 사용

**정리: Serializable Snapshot Isolation(SSI) 핵심 메커니즘**

| 항목               | 설명                                                       |
| ------------------ | ---------------------------------------------------------- |
| **읽기 시점**      | MVCC 기반 스냅숏에서 읽음 (쓰기 무시)                      |
| **충돌 감지 시점** | 커밋 시점에 과거 읽기가 최신 데이터에 영향을 받았는지 확인 |
| **트랜잭션 추적**  | 색인 범위 기반 추적, 읽기/쓰기 기록 일시적으로 유지        |
| **지뢰선 방식**    | 락 대신 감시 → 차단 없이 동작, 커밋 시 충돌 판단           |
| **장점**           | 지연 적음, 읽기 성능 높음, 병렬 처리에 유리                |
| **단점**           | 추적 비용 있음, 커밋 시 어보트, 긴 트랜잭션에 취약         |

낙관적 락(Optimistic Locking) vs SSI 완전 비교

| 항목           | 낙관적 락 (Optimistic Locking)                            | Serializable Snapshot Isolation (SSI)                  |
| -------------- | --------------------------------------------------------- | ------------------------------------------------------ |
| 적용 위치      | **애플리케이션/ORM 레벨**에서 직접 구현 (e.g. `@Version`) | **DB 내부 엔진 수준**에서 자동으로 작동                |
| 충돌 감지 시점 | **쓰기 직전 또는 커밋 직전** → 버전 비교로 감지           | **커밋 시점**에 읽기-쓰기 충돌 관계 기반으로 감지      |
| 충돌 감지 방식 | `version` 필드 같은 메타데이터 비교                       | **읽기-쓰기 추적 그래프**, predicate lock, 지뢰선 방식 |
| 범위           | **개별 row 단위** 충돌 방지                               | **범위 기반 predicate 충돌**까지 감지 (팬텀까지 포함)  |
| 장점           | 구현 단순, 애플리케이션 단에서 제어                       | MVCC 기반으로 직렬성 보장, 락 안 걸고 처리 가능        |
| 단점           | 개발자가 직접 처리 로직 추가 필요                         | 구현 복잡, 추적 비용 존재, 어보트 발생 가능            |
| 사용 예        | JPA, Hibernate, Spring Data의 `@Version`                  | PostgreSQL, FoundationDB의 `SERIALIZABLE` 격리 수준    |

