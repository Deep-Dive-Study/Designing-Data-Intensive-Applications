# 06. 파티셔닝
- 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족함
- 데이터를 파티션(보다 작은 단위)으로 쪼갤 필요가 있음. 이러한 작업을 **`샤딩`** 이라고도 함
  - 파티셔닝을 원하는 주된 이유는 **`확장성`**
    - 파티션은 그 자체로 작은 데이터베이스라고 볼 수 있음
    - 쿼리를 독립적으로 실행할 수 있는 노드가 추가되어 부하가 분산되며 병렬 실행이 가능해짐 

### 파티셔닝과 복제
- 보통은 **복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장하는 방식으로 함**
- 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있음
- 한 노드에 여러 파티션을 저장할 수 있기 때문에, 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있음

  ![CleanShot 2025-05-03 at 16 55 03@2x](https://github.com/user-attachments/assets/8917f6a2-55e6-4536-bfb3-6673d8baf2ad)

## 키-값 데이터 파티셔닝
- **`파티셔닝의 주 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것`**
- 파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 **`쏠렸다(skewed)`** 고 말하며, 불균형하게 부하가 높은 파티션을 **`핫스팟`** 이라고 함
  - 이러한 경우, 파티션닝을 한 효과가 매우 떨어짐 → 부하가 제대로 분산되지 않은 것

- 그러면 레코드를 어떻게 할당하는 것이 좋을까?
  - 파티션을 수행할때, 어떤 레코드를 어느 노드에 저장할지에 대한 결정 전략
  - `랜덤 파티셔닝`: 데이터는 고르게 분배되지만, 모든 노드에 대한 병렬 질의가 필요함
  - `키 범위 기준 파티셔닝` : 범위 스캔이 유용하지만, 핫스팟을 유발할 수 있음
  - `키 해시값 기준 파티셔닝` : 쏠림, 핫스팟을 방지할 수 있지만, 범위 질의를 효율적으로 실행할 수 없음

#### 트레이드 오프
- 즉, 레코드를 할당할 노드를 무작위로 선택하면 핫스팟을 피할 수 있음
- 하지만, 어떤 레코드를 읽으려고 할 때 레코드가 어느 노드에 저장되어있는지 찾기 위해 모든 노드에서 병렬적으로 질의를 실행해야하는 문제가 있음

### 키 범위 기준 파티셔닝
- 각 파티션에 연속된 범위의 키를 할당하는 방식
  - 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 알 수 있음
  
  ![CleanShot 2025-05-03 at 17 40 21@2x](https://github.com/user-attachments/assets/5cc398d9-b7b5-4e75-afaf-61f2f064f0c4)

- 키 범위 크기가 동일할 필요는 없음
- 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 함
- 파티션 경계는 관리자가 수동으로 하거나, 자동으로 DB가 선택하게 할 수 있음
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있음

- `장점`
  - 범위 스캔이 쉬워짐
  - 질의 하나로 관련 레코드 여러 개를 읽어올 수 있음
  - ex) 측정 값의 타임스탬프를 파티션 키로 사용하게 되면 범위 스캔이 매우 유용

- `단점`
  - 특정한 접근 패턴이 핫스팟을 유발
  - ex) 타임스탬프가 파티션 키라면 특정 피크 타임의 파티션은 핫스팟 가능성 있음

### 키의 해시값 기준 파티셔닝
- 키의 파티션을 정하는 데 해시 함수를 사용함
  - 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 함
  - 입력 문자열이 거의 유사해도, 해시값은 숫자 범위 내에서 균일하게 분산됨

- 해시 함수를 정한 후 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 파티션에 할당하면 됨

  ![CleanShot 2025-05-03 at 17 41 22@2x](https://github.com/user-attachments/assets/4e1c94e0-fd84-42a9-83a6-0ea9013c35f7)

  - 파티션 경계 나누는 방법
    - 크기가 동일하도록 나누는 방법
    - 무작위에 가깝게 선택하는 방법 → 일관성 해싱이라고 부르기도 함

- 다만, 키의 해시값을 기준으로 파티셔닝하는 경우, 범위 질의를 효율적으로 실행할 수 없다는 단점이 있음
  - 카산드라의 경우, 복합 기본키를 지정하는 방식으로 타협함
    - 키의 첫 부분만 해싱하고 남은 키는 데이터를 정렬하는 연쇄된 Index로 사용함
    - 해싱 키는 범위 질의를 할 수 없지만, 해싱 키를 고정된 값을 지정하면, 다른 컬럼에 대해서는 범위 스캔을 할 수 있음

### 쏠린 작업부하와 핫스팟 완화
- 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 될 수 있음
  - ex) 유명 연예인의 게시글에 많은 사람들이 댓글을 다는 경우, 특정 게시글의 해싱 값을 계속 사용하기 때문에 핫스팟이 생김

- 즉, 핫스팟은 완벽히 제거할 수 없음
- 이러한 경우 애플리케이션에서 완화시켜야 함
  - 가장 간단한 해결책은 키의 시작이나 끝에 임의의 숫자를 붙이는 것
  - 한 키에 대한 쓰기 작업을 다른 키로 균등하게 분산시키고 그 키들은 다른 파티션으로 분산될 수 있도록 함
  - 다만, 다른 키에 쪼개서 쓰는 경우에는 읽기를 실행할 때 추가적인 작업이 필요함

- 해당 방식은 트레이드 오프를 잘 고려하여 필요한 부분에만 적용시키는 것이 좋음
  - 아무곳이나 적용하면 오버헤드가 발생하고, 어디에도 적용하지 않으면 핫스팟이 발생함

## 파티셔닝과 보조 색인
- 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 `검색하는 수단`임
  - 예시) 특정 사용자가 실행한 액션을 모두 찾거나 특정 단어를 포함하는 글을 모두 찾거나, 등의 작업
  - 보조 색인은 RDB에선 핵심이며, 문서 DB에서도 흔함. 또한, ELK나 솔라 같은 전문 검색에서는 **존재의 이유** 임

- 보조 색인은 2가지 방법으로 나뉨 
  - **`문서 기준`** : Document ID 기준으로 파티셔닝하고, scatter/gather 형식으로 질의. 쓰기 효율적임
  - **`용어 기준`** : 모든 파티션의 데이터를 담당하는 전역 색인이 파티셔닝되어 있음. 읽기가 효율적, 원하는 용어를 포함하는 파티션으로만 요청을 보내면 됨.

### 문서 기준 보조 색인 파티셔닝
- 문서(Document) ID를 기준으로 파티셔닝
  - 색상과 제조사로 파티셔닝 하기 위해 color, make 보조색인 생성.
  - DB 파티션은 자동으로 그것을 color:OO 색인 항목에 해당하는 문서 ID 목록에 추가

  ![CleanShot 2025-05-03 at 17 30 09@2x](https://github.com/user-attachments/assets/1c8fae67-eb16-4718-b92a-650ab3222929)

- 각 파티션은 자신의 보조 색인을 유지하며, 그 파티션에 속하는 문서만 담당함
- 이렇게 하면 각 파티션이 완전히 독립적으로 동작할 수 있음. 즉, 다른 파티션은 전혀 신경쓰지 않을 수 있다.
- 따라서, 지역 색인(Local Index)이라고도 부름

- 하지만 이렇게 할 경우 모든 파티션에 질의를 보내 얻은 결과를 모아야 함
  - 이러한 방식을 **`스캐터/개더(scatter/gather)`** 라고 함
  - 다만, 이 방식은 꼬리 지연 시간이 증폭되기 쉬움

- 대부분은 단일 파티션에서만 사용하도록 하는것을 권장하며 많은 DB에서 이러한 방식을 사용함

### 용어 기준 보조 색인 파티셔닝
- 자신만의 보조 색인을 갖게하는 대신, 모든 파티션의 데이터를 담당하는 **`전역 색인(Global Index)`** 를 만들 수 있음

  ![CleanShot 2025-05-03 at 17 34 16@2x](https://github.com/user-attachments/assets/416b317b-4dfb-49d4-8b9c-dead109d3420)

- 이러한 색인을 파티셔닝 할 때 용어(인덱스 컬럼)의 해시값을 사용할 수도 있음
- 용어 자체로 하면 범위 스캔에 유용함
- 해시값을 사용하면 부하가 좀 더 고르게 분산됨

- 스캐터/개더를 할 필요가 없기 때문에, 읽기가 효율적임
- 다만, 쓰기가 느리고 복잡함
  - 쓰기에 영향받는 모든 파티션에 걸친 분산 트랜잭션을 실행해야함
  - 또한, 전역 색인은 비동기로 갱신되는데, 실제 갱신하는데에는 보통 오래 걸리지 않지만 여러 결함 문제로 인해 지연시간이 길어질 수도 있음

## 파티션 재균형화
- 시간이 지나면서 데이터베이스와 데이터에 변화가 생기게 됨
  - 쿼리 사용량이 증가하여 늘어난 부하를 처리하기 위해 CPU를 추가하는 경우
  - 데이터셋 크기가 증가해서 저장 용량을 늘리고자 하는 경우
  - 장비에 장애가 발생하여 장비를 변경해야하는 경우

- 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 **`재균형화(rebalancing)`** 이라고 함
  - 재균형화 요구사항
    - 재균형화 후, 부하가 클러스터 내에 있는 노드들 사이에 균등하게 분배되어야 함
    - 재균형화 도중에도 DB는 정상적으로 읽기/쓰기를 처리할 수 있어야함
    - 빨리 실행되어야 하고, 네트워크와 디스크 I/O 부하를 최소화 할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안됨

#### 재균형화 전략
- `해시값에 모드 N 연산을 실행`
- `파티션 개수 고정`
- `동적 파티셔닝` 
- `노드 비례 파티셔닝`

### 쓰면 안되는 방법 : 해시값에 모드 N 연산을 수행
- 노드 개수 N이 바뀌게 되면 키가 노드 사이에서 옮겨져야 된다는 문제가 있음
- 키가 자주 이동하게 되면 재균형화 비용이 지나치게 커짐
- 데이터를 필요 이상으로 이동하지 않는 방법이 필요함

### 파티션 개수 고정
- 파티션을 노드 대수보다 많이 만들고, 각 노드에 여러 파티션을 할당하는 방식
- 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇 개를 뺏어올 수 있음
- 클러스터에서 노드가 제거되면 이 과정이 반대로 실행됨

  ![CleanShot 2025-05-03 at 17 59 33@2x](https://github.com/user-attachments/assets/fbb9da59-a880-455d-8e7c-04e016a3c388)

- 파티션은 노드 사이에서 통째로 이동하기만 함
- 파티션 개수는 변하지 않고, 파티션에 할당된 키도 변경되지 않음
- 하지만 네트워크를 통해 대량의 데이터를 전송해야 하므로 시간이 많이 걸림

- 이러한 방식을 사용하게 되면 처음 DB를 구축할 때 파티션 개수가 고정되고 이후엔 변하지 않음
  - 처음 설정된 파티션 개수가 사용 가능한 노드 대수의 최대치가 되므로 미래에 증가될 것을 수용하기에 충분히 높은 값으로 설정해야 함
  - 하지만, 관리 오버헤드가 있으므로 너무 큰 수를 선택하면 역효과를 낳을 수 있음

### 동적 파티셔닝
- 파티션 크기가 설정된 값을 넘어가면 (ex. 10GB) 파티션을 두 개로 쪼개 각각에 파티션의 절반 정도의 데이터가 포함되게 하는 방식
  - 반대로 많이 삭제될 경우 임계값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있음

- 장점
  - 파티션 개수가 전체 데이터 용량에 맞춰 조정됨
  - 데이터 양이 작으면 파티션 개수도 적음
  - 데이터 양이 많으면 개별 파티션의 크기는 설정된 최대치로 제한돰

- 처음 시작하는 데이터베이스는 파티션 경계를 어디로 정해야 하는지에 관한 사전 정보가 없으므로 시작할 때는 파티션이 하나라는 문제가 있음
- 즉, 데이터 셋이 작을 때는 모든 쓰기 요청이 하나의 노드에서 실행되고, 다른 노드들은 유휴 상태에 머물게 됨
- 또한 해시 파티셔닝에서도 사용할 수 있음

### 노드 비례 파티셔닝
- 노드 대수가 변함이 없으면 개별 파티션 크기가 데이터셋 크기에 비례해서 증가함
- 노드 대수를 늘리면 파티션 크기는 다시 작아잠

- 새 노드가 클러스터에 추가되면 고정된 개수의 파티션을 무작위로 선택해 분할함
- 균등하지 않은 분할이 생길 수 있지만 평균적으로는 균등한 몫을 할당받게 됨

- 또한 파티션 경계를 무작위로 선택하려면 **`해시 기반 파티셔닝`** 을 사용해야 함

## 운영: 자동 재균형화와 수동 재균형화
- `자동 재균형화`
  - 유지보수에 손이 덜 가므로 편리함
  - 예측하기 어려움

- `수동 재균형화`
  - 관리자가 직접 파티션을 노드에 할당하도록 설정

- 카우치베이스, 리악, 볼드모트는 자동으로 할당을 제안하지만 반영하려면 수동으로 하는 방법을 사용함
- 재균형화 과정에는 사람이 개입하는게 좋음. 속도는 느릴 수 있지만, 운영상 예상치 못한 일을 방지하는데 도움이 됨

## 요청 라우팅
- 파티션이 재균형화되면서 노드에 할당되는 파티션이 바뀜
  - 클라이언트는 쿼리를 보내기 위해 어떤 노드로 접근해야 할 지 알아야 함

- 이러한 문제는 DB에 국한되지 않은 **`서비스 찾기(Service discovery)`** 의 일종임
  - 네트워크를 이용하며, 고가용성을 보장하는 시스템은 모두 겪음 

- **`요청을 라우팅하는 방법`**

  ![CleanShot 2025-05-03 at 18 10 03@2x](https://github.com/user-attachments/assets/2e273b46-d000-4909-852f-1363a26047db)

    1. 클라이언트가 아무 노드에나 접속하게 한다.(ex. 라운드 로빈 로드밸런서를 통해)
        - 자신이 처리할 수 있다면 처리함
        - 처리를 못한다면 다음 노드에게 넘김
    2. 클라이언트의 모든 요청을 라우팅 계층으로 먼저 보낸다.
        - 라우팅 계층에서 노드를 찾음
        - 찾은 노드에 요청을 전달함
    3. 클라이언트가 파티션 방법과 파티션이 어떤 노드에 할당됐는지 알게 한다.
        - 바로 해당 노드로 요청을 전송함


- 핵심 문제는 라우팅 결정을 내리는 구성 요소가 노드에 할당된 파티션의 변경 사항을 어떻게 아는냐임 
- 이 문제는 참여하는 모든 곳에서 정보가 일치해야 하므로 다루기 어려움

- 그래서 보통 대부분은 클러스터 메타데이터를 추적하기 위해 주키퍼(ZooKeeper) 같은 별도의 코디네이션 서비스를 사용함
- 각 노드는 주키퍼에 자신을 등록하고, 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리함
- 라우팅 계층은 주키퍼에 있는 정보를 구독할 수 있음
- 노드가 추가되거나 삭제되거나, 파티션 소유자가 바뀌게 되면 주키퍼는 라우팅 계층에 이를 알려서 라우팅 정보를 최신으로 유지함
  
  ![CleanShot 2025-05-03 at 18 13 57@2x](https://github.com/user-attachments/assets/a4a3da17-079f-4b58-9b30-a586a363b55c)

- 클라이언트는 라우팅 계층을 사용하거나, 임의의 노드로 요청을 보낼 때도 접속할 IP 주소를 알아내야 함
- IP 주소는 노드에 할당된 파티션 정보만큼 자주 바뀌지 않으므로 IP 주소를 찾는 데는 대개 DNS를 쓰는 것으로 충분함

## 병렬 질의 실행
- 분석용으로 자주 사용되는 대규모 병렬 처리(massively parallel processing, MPP) 관계형 데이터베이스는 훨씬 복잡한 질의를 지원함
- MPP Query Optimizer는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있음
  - join, filtering, grouping, aggregation 연산을 포함함
  - MPP 옵티마이저는 복잡한 질의를 여러 실행 단계와 파티션으로 분해함
  - 병렬적으로 실행됨
